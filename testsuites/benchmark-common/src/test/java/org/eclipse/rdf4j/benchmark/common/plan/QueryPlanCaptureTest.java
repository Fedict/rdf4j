/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common.plan;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.lang.reflect.Proxy;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.EnumMap;
import java.util.Optional;
import java.util.function.Supplier;

import org.eclipse.rdf4j.query.QueryLanguage;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.helpers.QueryModelTreeToGenericPlanNode;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.query.explanation.ExplanationImpl;
import org.eclipse.rdf4j.query.parser.QueryParserUtil;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

class QueryPlanCaptureTest {

	private static final Path EXPECTED_DEFAULT_OUTPUT_DIR = Path.of("testsuites/benchmark/src/main/resources/plan");

	@TempDir
	Path tempDir;

	@Test
	void defaultsOutputDirectoryToBenchmarkResourcesPlanPath() {
		String propertyKey = QueryPlanCaptureContext.OUTPUT_DIRECTORY_PROPERTY;
		String previous = System.getProperty(propertyKey);
		try {
			System.clearProperty(propertyKey);
			assertEquals(EXPECTED_DEFAULT_OUTPUT_DIR, QueryPlanCapture.resolveOutputDirectory());
			assertEquals(EXPECTED_DEFAULT_OUTPUT_DIR, QueryPlanCaptureContext.builder().build().getOutputDirectory());
		} finally {
			if (previous == null) {
				System.clearProperty(propertyKey);
			} else {
				System.setProperty(propertyKey, previous);
			}
		}
	}

	@Test
	void capturesAllExplanationLevelsAndIrRenderedQueries() throws IOException {
		ProbeTarget probe = new ProbeTarget();
		QueryPlanCapture capture = new QueryPlanCapture();

		String query = "SELECT ?s ?p ?o WHERE { ?s ?p ?o . FILTER(?s = ?s) }";
		Supplier<TupleQuery> tupleQuerySupplier = () -> stubTupleQueryFor(query);

		FeatureFlagCollector featureFlags = new FeatureFlagCollector()
				.addValue("direct.flag", "on")
				.addReflectiveField("reflection.enabled", probe, "enabled")
				.addReflectiveGetter("reflection.mode", probe, "mode");

		QueryPlanCaptureContext context = QueryPlanCaptureContext.builder()
				.outputDirectory(tempDir)
				.queryId("simple-select")
				.queryString(query)
				.benchmark("QueryPlanCaptureTest")
				.addMetadata("purpose", "test")
				.featureFlagCollector(featureFlags)
				.tupleExprRenderer(tupleExpr -> "SELECT * WHERE { # " + tupleExpr.getClass().getSimpleName() + " }")
				.build();

		Path outputFile = capture.captureAndWrite(context, tupleQuerySupplier);
		assertTrue(Files.exists(outputFile), "Expected query-plan snapshot file to exist");

		QueryPlanSnapshot snapshot = capture.readSnapshot(outputFile);
		assertEquals(QueryPlanCapture.FORMAT_VERSION, snapshot.getFormatVersion());
		assertNotNull(snapshot.getCapturedAt());
		assertFalse(snapshot.getUnoptimizedFingerprint().isBlank(),
				"Expected unoptimized fingerprint for direct query lookup");
		assertEquals("test", snapshot.getMetadata().get("purpose"));
		assertEquals("on", snapshot.getFeatureFlags().get("direct.flag"));
		assertEquals("true", snapshot.getFeatureFlags().get("reflection.enabled"));
		assertEquals("ir-path", snapshot.getFeatureFlags().get("reflection.mode"));

		QueryPlanExplanation unoptimized = snapshot.getExplanations().get("unoptimized");
		QueryPlanExplanation optimized = snapshot.getExplanations().get("optimized");
		QueryPlanExplanation executed = snapshot.getExplanations().get("executed");
		assertNotNull(unoptimized, "Expected unoptimized explanation");
		assertNotNull(optimized, "Expected optimized explanation");
		assertNotNull(executed, "Expected executed explanation");
		assertFalse(unoptimized.getTupleExprJson().isBlank(), "Expected tuple expression JSON payload");
		assertTrue(optimized.getIrRenderedQuery().contains("SELECT"),
				"Expected optimized IR-rendered SPARQL");
		assertTrue(executed.getIrRenderedQuery().contains("SELECT"),
				"Expected executed IR-rendered SPARQL");

		TupleExprJsonCodec codec = new TupleExprJsonCodec();
		assertNotNull(codec.fromJson(unoptimized.getTupleExprJson()),
				"Expected tuple expression JSON to be loadable");

		Optional<Path> byFingerprint = capture.findByUnoptimizedFingerprint(tempDir,
				snapshot.getUnoptimizedFingerprint());
		assertTrue(byFingerprint.isPresent(), "Expected lookup by unoptimized fingerprint to find artifact");
		assertEquals(outputFile.getFileName(), byFingerprint.get().getFileName());
	}

	private static TupleQuery stubTupleQueryFor(String query) {
		EnumMap<Explanation.Level, Explanation> explanations = new EnumMap<>(Explanation.Level.class);
		for (Explanation.Level level : Explanation.Level.values()) {
			TupleExpr tupleExpr = QueryParserUtil.parseQuery(QueryLanguage.SPARQL, query, null).getTupleExpr();
			explanations.put(level, toExplanation(tupleExpr));
		}

		return (TupleQuery) Proxy.newProxyInstance(
				QueryPlanCaptureTest.class.getClassLoader(),
				new Class<?>[] { TupleQuery.class },
				(proxy, method, args) -> {
					if ("explain".equals(method.getName())) {
						return explanations.get((Explanation.Level) args[0]);
					}
					if ("toString".equals(method.getName())) {
						return "StubTupleQuery";
					}
					if (method.getReturnType().isPrimitive()) {
						return primitiveDefault(method.getReturnType());
					}
					return null;
				});
	}

	private static Explanation toExplanation(TupleExpr tupleExpr) {
		QueryModelTreeToGenericPlanNode converter = new QueryModelTreeToGenericPlanNode(tupleExpr);
		tupleExpr.visit(converter);
		return new ExplanationImpl(converter.getGenericPlanNode(), false, tupleExpr);
	}

	private static Object primitiveDefault(Class<?> primitiveType) {
		if (primitiveType == boolean.class) {
			return false;
		}
		if (primitiveType == byte.class) {
			return (byte) 0;
		}
		if (primitiveType == short.class) {
			return (short) 0;
		}
		if (primitiveType == int.class) {
			return 0;
		}
		if (primitiveType == long.class) {
			return 0L;
		}
		if (primitiveType == float.class) {
			return 0f;
		}
		if (primitiveType == double.class) {
			return 0d;
		}
		if (primitiveType == char.class) {
			return '\0';
		}
		return null;
	}

	private static final class ProbeTarget {
		private final boolean enabled = true;

		@SuppressWarnings("unused")
		private String mode() {
			return "ir-path";
		}
	}
}
