/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common.plan;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Function;

import org.eclipse.rdf4j.common.annotation.Experimental;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.explanation.Explanation;

/**
 * Context/configuration for a query-plan capture run.
 */
@Experimental
public final class QueryPlanCaptureContext {

	public static final String OUTPUT_DIRECTORY_PROPERTY = "rdf4j.query.plan.capture.outputDir";
	public static final String METADATA_PROPERTY_PREFIX = "rdf4j.query.plan.capture.metadata.";

	private final Path outputDirectory;
	private final String queryId;
	private final String queryString;
	private final String benchmark;
	private final Map<String, String> metadata;
	private final FeatureFlagCollector featureFlagCollector;
	private final Function<TupleExpr, String> tupleExprRenderer;
	private final List<Explanation.Level> levels;
	private final Set<Explanation.Level> irRenderedLevels;

	private QueryPlanCaptureContext(Builder builder) {
		this.outputDirectory = builder.outputDirectory;
		this.queryId = builder.queryId;
		this.queryString = builder.queryString;
		this.benchmark = builder.benchmark;
		this.metadata = Collections.unmodifiableMap(new LinkedHashMap<>(builder.metadata));
		this.featureFlagCollector = builder.featureFlagCollector;
		this.tupleExprRenderer = builder.tupleExprRenderer;
		this.levels = Collections.unmodifiableList(new ArrayList<>(builder.levels));
		if (builder.irRenderedLevels.isEmpty()) {
			this.irRenderedLevels = Collections.emptySet();
		} else {
			this.irRenderedLevels = Collections.unmodifiableSet(EnumSet.copyOf(builder.irRenderedLevels));
		}
	}

	public static Builder builder() {
		return new Builder();
	}

	public Path getOutputDirectory() {
		return outputDirectory;
	}

	public String getQueryId() {
		return queryId;
	}

	public String getQueryString() {
		return queryString;
	}

	public String getBenchmark() {
		return benchmark;
	}

	public Map<String, String> getMetadata() {
		return metadata;
	}

	public FeatureFlagCollector getFeatureFlagCollector() {
		return featureFlagCollector;
	}

	public Function<TupleExpr, String> getTupleExprRenderer() {
		return tupleExprRenderer;
	}

	public List<Explanation.Level> getLevels() {
		return levels;
	}

	public Set<Explanation.Level> getIrRenderedLevels() {
		return irRenderedLevels;
	}

	@Experimental
	public static final class Builder {
		private Path outputDirectory = Paths
				.get(System.getProperty(OUTPUT_DIRECTORY_PROPERTY, QueryPlanCapture.DEFAULT_OUTPUT_DIRECTORY));
		private String queryId = "query";
		private String queryString;
		private String benchmark;
		private final LinkedHashMap<String, String> metadata = new LinkedHashMap<>();
		private FeatureFlagCollector featureFlagCollector = new FeatureFlagCollector();
		private Function<TupleExpr, String> tupleExprRenderer;
		private final List<Explanation.Level> levels = new ArrayList<>(List.of(
				Explanation.Level.Unoptimized,
				Explanation.Level.Optimized,
				Explanation.Level.Executed));
		private final EnumSet<Explanation.Level> irRenderedLevels = EnumSet.of(
				Explanation.Level.Optimized,
				Explanation.Level.Executed);

		private Builder() {
		}

		public Builder outputDirectory(Path outputDirectory) {
			this.outputDirectory = Objects.requireNonNull(outputDirectory, "outputDirectory");
			return this;
		}

		public Builder queryId(String queryId) {
			Objects.requireNonNull(queryId, "queryId");
			if (queryId.isBlank()) {
				throw new IllegalArgumentException("queryId must not be blank");
			}
			this.queryId = queryId;
			return this;
		}

		public Builder queryString(String queryString) {
			this.queryString = queryString;
			return this;
		}

		public Builder benchmark(String benchmark) {
			this.benchmark = benchmark;
			return this;
		}

		public Builder addMetadata(String key, String value) {
			Objects.requireNonNull(key, "key");
			metadata.put(key, value == null ? FeatureFlagCollector.NULL_VALUE : value);
			return this;
		}

		public Builder addMetadata(Map<String, String> metadataMap) {
			Objects.requireNonNull(metadataMap, "metadataMap");
			metadataMap.forEach(this::addMetadata);
			return this;
		}

		public Builder addMetadataFromSystemProperties(String prefix) {
			Objects.requireNonNull(prefix, "prefix");
			TreeSet<String> names = new TreeSet<>();
			System.getProperties()
					.stringPropertyNames()
					.stream()
					.filter(name -> name.startsWith(prefix))
					.forEach(names::add);
			names.forEach(name -> addMetadata(name.substring(prefix.length()), System.getProperty(name)));
			return this;
		}

		public Builder featureFlagCollector(FeatureFlagCollector featureFlagCollector) {
			this.featureFlagCollector = Objects.requireNonNull(featureFlagCollector, "featureFlagCollector");
			return this;
		}

		public Builder tupleExprRenderer(Function<TupleExpr, String> tupleExprRenderer) {
			this.tupleExprRenderer = Objects.requireNonNull(tupleExprRenderer, "tupleExprRenderer");
			return this;
		}

		public Builder levels(List<Explanation.Level> levels) {
			Objects.requireNonNull(levels, "levels");
			if (levels.isEmpty()) {
				throw new IllegalArgumentException("At least one explanation level is required");
			}
			this.levels.clear();
			this.levels.addAll(levels);
			return this;
		}

		public Builder irRenderedLevels(Set<Explanation.Level> irRenderedLevels) {
			Objects.requireNonNull(irRenderedLevels, "irRenderedLevels");
			this.irRenderedLevels.clear();
			this.irRenderedLevels.addAll(irRenderedLevels);
			return this;
		}

		public QueryPlanCaptureContext build() {
			if (levels.isEmpty()) {
				throw new IllegalStateException("No explanation levels configured");
			}
			return new QueryPlanCaptureContext(this);
		}
	}
}
