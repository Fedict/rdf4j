/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common.plan;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.eclipse.rdf4j.common.annotation.Experimental;

/**
 * Collects feature-flag values from system properties, direct suppliers, and reflection probes.
 */
@Experimental
public final class FeatureFlagCollector {

	static final String NULL_VALUE = "<null>";
	static final String ERROR_PREFIX = "<error:";

	private final LinkedHashMap<String, Supplier<String>> probes = new LinkedHashMap<>();

	public FeatureFlagCollector addSystemProperty(String propertyKey) {
		return addSystemProperty(propertyKey, propertyKey);
	}

	public FeatureFlagCollector addSystemProperty(String flagName, String propertyKey) {
		Objects.requireNonNull(propertyKey, "propertyKey");
		return addValue(flagName, () -> System.getProperty(propertyKey));
	}

	public FeatureFlagCollector addSystemPropertiesWithPrefix(String propertyPrefix) {
		Objects.requireNonNull(propertyPrefix, "propertyPrefix");
		Set<String> keys = System.getProperties()
				.stringPropertyNames()
				.stream()
				.filter(name -> name.startsWith(propertyPrefix))
				.collect(Collectors.toCollection(java.util.TreeSet::new));
		keys.forEach(this::addSystemProperty);
		return this;
	}

	public FeatureFlagCollector addSystemPropertiesFromCsvProperty(String csvPropertyName) {
		Objects.requireNonNull(csvPropertyName, "csvPropertyName");
		String csv = System.getProperty(csvPropertyName, "");
		if (csv.isBlank()) {
			return this;
		}
		Arrays.stream(csv.split(","))
				.map(String::trim)
				.filter(value -> !value.isEmpty())
				.forEach(this::addSystemProperty);
		return this;
	}

	public FeatureFlagCollector addValue(String flagName, Object value) {
		return addValue(flagName, () -> value);
	}

	public FeatureFlagCollector addValue(String flagName, Supplier<?> valueSupplier) {
		Objects.requireNonNull(flagName, "flagName");
		Objects.requireNonNull(valueSupplier, "valueSupplier");
		probes.put(flagName, () -> stringify(valueSupplier.get()));
		return this;
	}

	public FeatureFlagCollector addReflectiveField(String flagName, Object target, String fieldName) {
		Objects.requireNonNull(target, "target");
		Objects.requireNonNull(fieldName, "fieldName");
		return addValue(flagName, () -> {
			Field field = findField(target.getClass(), fieldName);
			if (field == null) {
				throw new IllegalArgumentException("No field '" + fieldName + "' in " + target.getClass().getName());
			}
			try {
				field.setAccessible(true);
				return field.get(target);
			} catch (ReflectiveOperationException e) {
				throw new IllegalStateException("Failed to read field '" + fieldName + "'", e);
			}
		});
	}

	public FeatureFlagCollector addReflectiveGetter(String flagName, Object target, String methodName) {
		Objects.requireNonNull(target, "target");
		Objects.requireNonNull(methodName, "methodName");
		return addValue(flagName, () -> {
			Method method = findZeroArgMethod(target.getClass(), methodName);
			if (method == null) {
				throw new IllegalArgumentException(
						"No zero-arg method '" + methodName + "' in " + target.getClass().getName());
			}
			try {
				method.setAccessible(true);
				return method.invoke(target);
			} catch (ReflectiveOperationException e) {
				throw new IllegalStateException("Failed to invoke method '" + methodName + "'", e);
			}
		});
	}

	public Map<String, String> snapshot() {
		LinkedHashMap<String, String> snapshot = new LinkedHashMap<>();
		probes.forEach((key, probe) -> snapshot.put(key, readSafely(probe)));
		return Collections.unmodifiableMap(snapshot);
	}

	private static String readSafely(Supplier<String> probe) {
		try {
			return probe.get();
		} catch (Exception e) {
			return ERROR_PREFIX + e.getClass().getSimpleName() + ": " + e.getMessage() + ">";
		}
	}

	private static String stringify(Object value) {
		if (value == null) {
			return NULL_VALUE;
		}

		Class<?> valueClass = value.getClass();
		if (valueClass.isArray()) {
			return arrayToString(value);
		}

		return String.valueOf(value);
	}

	private static String arrayToString(Object array) {
		int length = Array.getLength(array);
		StringBuilder builder = new StringBuilder("[");
		for (int i = 0; i < length; i++) {
			if (i > 0) {
				builder.append(", ");
			}
			builder.append(stringify(Array.get(array, i)));
		}
		return builder.append(']').toString();
	}

	private static Field findField(Class<?> type, String fieldName) {
		Class<?> current = type;
		while (current != null) {
			try {
				return current.getDeclaredField(fieldName);
			} catch (NoSuchFieldException ignored) {
				current = current.getSuperclass();
			}
		}
		return null;
	}

	private static Method findZeroArgMethod(Class<?> type, String methodName) {
		Class<?> current = type;
		while (current != null) {
			Method[] methods = current.getDeclaredMethods();
			for (Method method : methods) {
				if (method.getName().equals(methodName) && method.getParameterCount() == 0) {
					return method;
				}
			}
			current = current.getSuperclass();
		}
		return null;
	}
}
