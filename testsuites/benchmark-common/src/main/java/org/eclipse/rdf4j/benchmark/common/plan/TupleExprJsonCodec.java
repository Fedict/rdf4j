/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.common.plan;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Objects;

import org.eclipse.rdf4j.common.annotation.Experimental;
import org.eclipse.rdf4j.query.algebra.TupleExpr;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

/**
 * Encodes a {@link TupleExpr} into JSON and decodes it back.
 * <p>
 * The JSON payload is explicit and versioned; it stores a Base64-encoded Java-serialized TupleExpr for robust
 * round-trip reconstruction and additional text/fingerprint fields for quick inspection and indexing.
 */
@Experimental
public final class TupleExprJsonCodec {

	public static final String FORMAT = "java-serialized-base64-v1";

	private final ObjectMapper mapper = new ObjectMapper()
			.configure(SerializationFeature.INDENT_OUTPUT, true)
			.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
			.setSerializationInclusion(JsonInclude.Include.NON_NULL);

	public String toJson(TupleExpr tupleExpr) {
		Objects.requireNonNull(tupleExpr, "tupleExpr");

		TupleExprPayload payload = new TupleExprPayload();
		payload.setFormat(FORMAT);
		payload.setTupleExprClass(tupleExpr.getClass().getName());
		payload.setTupleExprTree(tupleExpr.toString());
		payload.setFingerprintSha256(sha256(payload.getTupleExprTree()));
		payload.setPayloadBase64(serializeToBase64(tupleExpr));

		try {
			return mapper.writeValueAsString(payload);
		} catch (JsonProcessingException e) {
			throw new IllegalStateException("Failed to serialize tuple expression payload", e);
		}
	}

	public TupleExpr fromJson(String json) {
		Objects.requireNonNull(json, "json");
		try {
			TupleExprPayload payload = mapper.readValue(json, TupleExprPayload.class);
			if (!FORMAT.equals(payload.getFormat())) {
				throw new IllegalArgumentException(
						"Unsupported tuple expression payload format: " + payload.getFormat());
			}
			if (payload.getPayloadBase64() == null || payload.getPayloadBase64().isBlank()) {
				throw new IllegalArgumentException("Missing payloadBase64 in tuple expression payload");
			}
			Object decoded = deserializeFromBase64(payload.getPayloadBase64());
			if (!(decoded instanceof TupleExpr)) {
				throw new IllegalArgumentException(
						"Decoded payload is not a TupleExpr: " + (decoded == null ? "null" : decoded.getClass()));
			}
			return (TupleExpr) decoded;
		} catch (IOException e) {
			throw new IllegalStateException("Failed to parse tuple expression payload", e);
		}
	}

	public String fingerprint(TupleExpr tupleExpr) {
		Objects.requireNonNull(tupleExpr, "tupleExpr");
		return sha256(tupleExpr.toString());
	}

	public String fingerprintFromText(String text) {
		Objects.requireNonNull(text, "text");
		return sha256(text);
	}

	public String fingerprintFromJson(String json) {
		Objects.requireNonNull(json, "json");
		try {
			TupleExprPayload payload = mapper.readValue(json, TupleExprPayload.class);
			if (payload.getFingerprintSha256() != null && !payload.getFingerprintSha256().isBlank()) {
				return payload.getFingerprintSha256();
			}
			if (payload.getTupleExprTree() != null && !payload.getTupleExprTree().isBlank()) {
				return sha256(payload.getTupleExprTree());
			}
			return sha256(json);
		} catch (IOException e) {
			return sha256(json);
		}
	}

	private static String serializeToBase64(TupleExpr tupleExpr) {
		try (ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
				ObjectOutputStream objectStream = new ObjectOutputStream(byteStream)) {
			objectStream.writeObject(tupleExpr);
			objectStream.flush();
			return Base64.getEncoder().encodeToString(byteStream.toByteArray());
		} catch (IOException e) {
			throw new IllegalStateException("Failed to Java-serialize TupleExpr", e);
		}
	}

	private static Object deserializeFromBase64(String payloadBase64) throws IOException {
		byte[] bytes = Base64.getDecoder().decode(payloadBase64);
		try (ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
				ObjectInputStream objectStream = new ObjectInputStream(byteStream)) {
			try {
				return objectStream.readObject();
			} catch (ClassNotFoundException e) {
				throw new IOException("Could not deserialize TupleExpr payload", e);
			}
		}
	}

	private static String sha256(String value) {
		try {
			MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
			byte[] digest = messageDigest.digest(value.getBytes(StandardCharsets.UTF_8));
			StringBuilder hex = new StringBuilder(digest.length * 2);
			for (byte current : digest) {
				hex.append(String.format("%02x", current));
			}
			return hex.toString();
		} catch (NoSuchAlgorithmException e) {
			throw new IllegalStateException("SHA-256 algorithm not available", e);
		}
	}

	static final class TupleExprPayload {
		private String format;
		private String tupleExprClass;
		private String tupleExprTree;
		private String fingerprintSha256;
		private String payloadBase64;

		public String getFormat() {
			return format;
		}

		public void setFormat(String format) {
			this.format = format;
		}

		public String getTupleExprClass() {
			return tupleExprClass;
		}

		public void setTupleExprClass(String tupleExprClass) {
			this.tupleExprClass = tupleExprClass;
		}

		public String getTupleExprTree() {
			return tupleExprTree;
		}

		public void setTupleExprTree(String tupleExprTree) {
			this.tupleExprTree = tupleExprTree;
		}

		public String getFingerprintSha256() {
			return fingerprintSha256;
		}

		public void setFingerprintSha256(String fingerprintSha256) {
			this.fingerprintSha256 = fingerprintSha256;
		}

		public String getPayloadBase64() {
			return payloadBase64;
		}

		public void setPayloadBase64(String payloadBase64) {
			this.payloadBase64 = payloadBase64;
		}
	}
}
