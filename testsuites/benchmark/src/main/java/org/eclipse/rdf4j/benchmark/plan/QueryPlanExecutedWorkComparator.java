/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;

final class QueryPlanExecutedWorkComparator {

	private static final BigDecimal HUNDRED = new BigDecimal("100");
	private static final BigDecimal EPSILON_RATIO = new BigDecimal("0.03");
	private static final BigDecimal JOIN_INPUT_WEIGHT = new BigDecimal("0.02");
	private static final BigDecimal ROW_FLOW_WEIGHT = new BigDecimal("0.005");
	private static final BigDecimal BARRIER_WEIGHT = new BigDecimal("15");
	private static final BigDecimal ESTIMATE_QERROR_WEIGHT = new BigDecimal("10");
	private static final BigDecimal JOIN_ESTIMATE_QERROR_WEIGHT = new BigDecimal("12");
	private static final BigDecimal HAS_NEXT_CALL_WEIGHT = new BigDecimal("0.001");
	private static final BigDecimal NEXT_CALL_WEIGHT = new BigDecimal("0.0005");
	private static final BigDecimal HAS_NEXT_TIME_WEIGHT = BigDecimal.ONE;
	private static final BigDecimal NEXT_TIME_WEIGHT = BigDecimal.ONE;
	private static final BigDecimal JOIN_RIGHT_ITERATOR_CREATE_WEIGHT = new BigDecimal("0.05");
	private static final BigDecimal JOIN_RIGHT_BINDINGS_CONSUMED_WEIGHT = new BigDecimal("0.001");
	private static final BigDecimal SOURCE_ROWS_FILTERED_WEIGHT = new BigDecimal("0.001");
	private static final BigDecimal SOURCE_FILTER_RATIO_WEIGHT = new BigDecimal("5");
	private static final BigDecimal FILTER_REJECT_RATIO_WEIGHT = new BigDecimal("5");
	private static final BigDecimal ADDITIONAL_TELEMETRY_SIGNAL_WEIGHT = new BigDecimal("0.1");
	private static final BigDecimal NANOS_PER_MILLI = new BigDecimal("1000000");
	private static final int TOP_DELTA_LIMIT = 3;
	private static final String[] EXECUTED_LEVEL_ALIASES = { "telemetry", "executed" };
	private static final Set<String> CORE_EXECUTED_METRIC_KEYS = Set.of(
			"modeledWorkUnits",
			"modeledJoinInputRowsSum",
			"modeledJoinOutputRowsSum",
			"modeledInputRowsSum",
			"modeledOutputRowsSum",
			"modeledSelfTimeActualSum",
			"estimateActualQErrorP95",
			"joinEstimateActualQErrorP95",
			"modeledFilterRejectRatio",
			"modeledHasNextCallCountSum",
			"modeledHasNextTrueCountSum",
			"modeledHasNextTimeNanosSum",
			"modeledNextCallCountSum",
			"modeledNextTimeNanosSum",
			"modeledJoinRightIteratorCreateCountSum",
			"modeledJoinLeftBindingSetConsumedCountSum",
			"modeledJoinRightBindingSetConsumedCountSum",
			"modeledJoinRightBindingsPerLeftRatio",
			"modeledJoinTelemetryNodeCount",
			"modeledJoinRightBindingSetConsumedPerRightIteratorAverage",
			"modeledJoinRightIteratorCreatePerJoinNodeAverage",
			"modeledJoinLeftBindingSetConsumedPerJoinNodeAverage",
			"modeledJoinRightBindingSetConsumedPerJoinNodeAverage",
			"modeledSourceRowsScannedSum",
			"modeledSourceRowsMatchedSum",
			"modeledSourceRowsFilteredSum",
			"modeledSourceFilterOutRatio",
			"modeledBarrierCount",
			"modeledWorkByCategory",
			"operatorWorkByTypeAlgorithm",
			"operatorWorkTopContributors");

	private QueryPlanExecutedWorkComparator() {
	}

	static ExecutedWorkComparison compare(QueryPlanSnapshot leftSnapshot, QueryPlanSnapshot rightSnapshot) {
		PlanVector leftVector = extractExecutedVector(leftSnapshot);
		PlanVector rightVector = extractExecutedVector(rightSnapshot);
		if (!leftVector.available || !rightVector.available) {
			String reason = !leftVector.available ? leftVector.unavailableReason : rightVector.unavailableReason;
			return ExecutedWorkComparison.unavailable(reason);
		}

		BigDecimal leftScore = modeledScore(leftVector);
		BigDecimal rightScore = modeledScore(rightVector);
		BigDecimal scoreDeltaPct = percentDelta(leftScore, rightScore);
		Decision decision = decide(leftVector, rightVector, leftScore, rightScore);
		Map<String, BigDecimal> leftResourceComponents = resourceComponents(leftVector);
		Map<String, BigDecimal> rightResourceComponents = resourceComponents(rightVector);

		String topCategoryDeltas = formatTopDeltas(leftVector.modeledWorkByCategory, rightVector.modeledWorkByCategory);
		String topOperatorDeltas = formatTopDeltas(leftVector.operatorWorkUnits, rightVector.operatorWorkUnits);
		String topVectorDeltas = formatTopDeltas(vectorDimensions(leftVector), vectorDimensions(rightVector));
		String topResourceDeltas = formatTopDeltas(leftResourceComponents, rightResourceComponents);
		String dominantResourceLeft = dominantResource(leftResourceComponents);
		String dominantResourceRight = dominantResource(rightResourceComponents);
		return ExecutedWorkComparison.available(leftScore, rightScore, scoreDeltaPct, decision.winner,
				decision.decisionBasis, topCategoryDeltas, topOperatorDeltas, topVectorDeltas, dominantResourceLeft,
				dominantResourceRight, topResourceDeltas);
	}

	private static PlanVector extractExecutedVector(QueryPlanSnapshot snapshot) {
		Map<String, String> metrics = executedDebugMetrics(snapshot);
		BigDecimal modeledWorkUnits = parseDecimal(metrics.get("modeledWorkUnits"));
		if (modeledWorkUnits == null) {
			return PlanVector.unavailable("missing-executed-modeledWorkUnits");
		}

		BigDecimal joinInputRows = parseDecimalOrZero(metrics.get("modeledJoinInputRowsSum"));
		BigDecimal joinOutputRows = parseDecimalOrZero(metrics.get("modeledJoinOutputRowsSum"));
		BigDecimal modeledInputRowsSum = parseDecimalOrZero(metrics.get("modeledInputRowsSum"));
		BigDecimal modeledOutputRowsSum = parseDecimalOrZero(metrics.get("modeledOutputRowsSum"));
		BigDecimal modeledSelfTimeActualSum = parseDecimalOrZero(metrics.get("modeledSelfTimeActualSum"));
		BigDecimal estimateActualQErrorP95 = parseDecimalOrZero(metrics.get("estimateActualQErrorP95"));
		BigDecimal joinEstimateActualQErrorP95 = parseDecimalOrZero(metrics.get("joinEstimateActualQErrorP95"));
		BigDecimal filterRejectRatio = parseDecimalOrZero(metrics.get("modeledFilterRejectRatio"));
		long hasNextCallCountSum = parseLongOrZero(metrics.get("modeledHasNextCallCountSum"));
		long hasNextTrueCountSum = parseLongOrZero(metrics.get("modeledHasNextTrueCountSum"));
		long hasNextTimeNanosSum = parseLongOrZero(metrics.get("modeledHasNextTimeNanosSum"));
		long nextCallCountSum = parseLongOrZero(metrics.get("modeledNextCallCountSum"));
		long nextTimeNanosSum = parseLongOrZero(metrics.get("modeledNextTimeNanosSum"));
		long joinRightIteratorCreateCountSum = parseLongOrZero(metrics.get("modeledJoinRightIteratorCreateCountSum"));
		long joinLeftBindingSetConsumedCountSum = parseLongOrZero(
				metrics.get("modeledJoinLeftBindingSetConsumedCountSum"));
		long joinRightBindingSetConsumedCountSum = parseLongOrZero(
				metrics.get("modeledJoinRightBindingSetConsumedCountSum"));
		BigDecimal joinRightBindingsPerLeftRatio = parseDecimalOrZero(
				metrics.get("modeledJoinRightBindingsPerLeftRatio"));
		long joinTelemetryNodeCount = parseLongOrZero(metrics.get("modeledJoinTelemetryNodeCount"));
		BigDecimal joinRightBindingSetConsumedPerRightIteratorAverage = parseDecimalOrZero(
				metrics.get("modeledJoinRightBindingSetConsumedPerRightIteratorAverage"));
		BigDecimal joinRightIteratorCreatePerJoinNodeAverage = parseDecimalOrZero(
				metrics.get("modeledJoinRightIteratorCreatePerJoinNodeAverage"));
		BigDecimal joinLeftBindingSetConsumedPerJoinNodeAverage = parseDecimalOrZero(
				metrics.get("modeledJoinLeftBindingSetConsumedPerJoinNodeAverage"));
		BigDecimal joinRightBindingSetConsumedPerJoinNodeAverage = parseDecimalOrZero(
				metrics.get("modeledJoinRightBindingSetConsumedPerJoinNodeAverage"));
		long sourceRowsScannedSum = parseLongOrZero(metrics.get("modeledSourceRowsScannedSum"));
		long sourceRowsMatchedSum = parseLongOrZero(metrics.get("modeledSourceRowsMatchedSum"));
		long sourceRowsFilteredSum = parseLongOrZero(metrics.get("modeledSourceRowsFilteredSum"));
		BigDecimal sourceFilterOutRatio = parseDecimalOrZero(metrics.get("modeledSourceFilterOutRatio"));
		long barrierCount = parseLongOrZero(metrics.get("modeledBarrierCount"));
		Map<String, BigDecimal> modeledWorkByCategory = parseSimpleNumberMap(metrics.get("modeledWorkByCategory"));
		Map<String, BigDecimal> operatorWorkUnits = parseOperatorWorkUnits(metrics.get("operatorWorkByTypeAlgorithm"));
		if (operatorWorkUnits.isEmpty()) {
			operatorWorkUnits = parseSimpleNumberMap(metrics.get("operatorWorkTopContributors"));
			if (operatorWorkUnits.isEmpty()) {
				operatorWorkUnits = parseSimpleNumberMap(metrics.get("operatorWorkTopContributors"), ':');
			}
		}
		Map<String, BigDecimal> additionalTelemetryScalars = parseAdditionalTelemetryScalars(metrics);
		return PlanVector.available(modeledWorkUnits, modeledInputRowsSum, modeledOutputRowsSum, joinInputRows,
				joinOutputRows, modeledSelfTimeActualSum, estimateActualQErrorP95, joinEstimateActualQErrorP95,
				filterRejectRatio,
				barrierCount,
				hasNextCallCountSum, hasNextTrueCountSum, hasNextTimeNanosSum, nextCallCountSum, nextTimeNanosSum,
				joinRightIteratorCreateCountSum, joinLeftBindingSetConsumedCountSum,
				joinRightBindingSetConsumedCountSum,
				joinRightBindingsPerLeftRatio, joinTelemetryNodeCount,
				joinRightBindingSetConsumedPerRightIteratorAverage,
				joinRightIteratorCreatePerJoinNodeAverage, joinLeftBindingSetConsumedPerJoinNodeAverage,
				joinRightBindingSetConsumedPerJoinNodeAverage,
				sourceRowsScannedSum, sourceRowsMatchedSum, sourceRowsFilteredSum,
				sourceFilterOutRatio,
				modeledWorkByCategory,
				operatorWorkUnits,
				additionalTelemetryScalars);
	}

	private static Map<String, String> executedDebugMetrics(QueryPlanSnapshot snapshot) {
		if (snapshot == null || snapshot.getExplanations() == null || snapshot.getExplanations().isEmpty()) {
			return Collections.emptyMap();
		}

		for (String levelAlias : EXECUTED_LEVEL_ALIASES) {
			QueryPlanExplanation explanation = snapshot.getExplanations().get(levelAlias);
			if (explanation != null && explanation.getDebugMetrics() != null
					&& !explanation.getDebugMetrics().isEmpty()) {
				return explanation.getDebugMetrics();
			}
		}

		for (QueryPlanExplanation candidate : snapshot.getExplanations().values()) {
			String level = candidate == null ? null : candidate.getLevel();
			if (level == null || candidate.getDebugMetrics() == null || candidate.getDebugMetrics().isEmpty()) {
				continue;
			}
			for (String levelAlias : EXECUTED_LEVEL_ALIASES) {
				if (levelAlias.equalsIgnoreCase(level)) {
					return candidate.getDebugMetrics();
				}
			}
		}

		return Collections.emptyMap();
	}

	private static BigDecimal modeledScore(PlanVector vector) {
		BigDecimal score = BigDecimal.ZERO;
		for (BigDecimal component : resourceComponents(vector).values()) {
			score = score.add(component);
		}
		return score;
	}

	private static BigDecimal percentDelta(BigDecimal left, BigDecimal right) {
		if (left == null || right == null) {
			return null;
		}
		if (left.signum() == 0) {
			if (right.signum() == 0) {
				return BigDecimal.ZERO;
			}
			return null;
		}
		return right.subtract(left)
				.multiply(HUNDRED)
				.divide(left.abs(), 3, RoundingMode.HALF_UP)
				.stripTrailingZeros();
	}

	private static Decision decide(PlanVector leftVector, PlanVector rightVector, BigDecimal leftScore,
			BigDecimal rightScore) {
		BigDecimal baseline = leftScore.abs().max(rightScore.abs());
		BigDecimal threshold = baseline.multiply(EPSILON_RATIO);
		BigDecimal scoreDifference = leftScore.subtract(rightScore).abs();
		if (scoreDifference.compareTo(threshold) > 0) {
			return new Decision(leftScore.compareTo(rightScore) < 0 ? "left" : "right", "score");
		}

		int compareWorkUnits = leftVector.modeledWorkUnits.compareTo(rightVector.modeledWorkUnits);
		if (compareWorkUnits != 0) {
			return new Decision(compareWorkUnits < 0 ? "left" : "right", "tie-breaker-modeledWorkUnits");
		}

		int compareJoinInputRows = leftVector.joinInputRows.compareTo(rightVector.joinInputRows);
		if (compareJoinInputRows != 0) {
			return new Decision(compareJoinInputRows < 0 ? "left" : "right", "tie-breaker-modeledJoinInputRowsSum");
		}

		if (leftVector.barrierCount != rightVector.barrierCount) {
			return new Decision(leftVector.barrierCount < rightVector.barrierCount ? "left" : "right",
					"tie-breaker-modeledBarrierCount");
		}

		int compareEstimateQError = leftVector.estimateActualQErrorP95.compareTo(rightVector.estimateActualQErrorP95);
		if (compareEstimateQError != 0) {
			return new Decision(compareEstimateQError < 0 ? "left" : "right",
					"tie-breaker-estimateActualQErrorP95");
		}

		int compareJoinEstimateQError = leftVector.joinEstimateActualQErrorP95
				.compareTo(rightVector.joinEstimateActualQErrorP95);
		if (compareJoinEstimateQError != 0) {
			return new Decision(compareJoinEstimateQError < 0 ? "left" : "right",
					"tie-breaker-joinEstimateActualQErrorP95");
		}

		int compareAdditionalTelemetry = additionalTelemetrySignalTotal(leftVector)
				.compareTo(additionalTelemetrySignalTotal(rightVector));
		if (compareAdditionalTelemetry != 0) {
			return new Decision(compareAdditionalTelemetry < 0 ? "left" : "right",
					"tie-breaker-additionalTelemetry");
		}

		return new Decision("tie", "tie");
	}

	private static Map<String, BigDecimal> vectorDimensions(PlanVector vector) {
		LinkedHashMap<String, BigDecimal> dimensions = new LinkedHashMap<>();
		dimensions.put("modeledWorkUnits", vector.modeledWorkUnits);
		dimensions.put("modeledInputRowsSum", vector.modeledInputRowsSum);
		dimensions.put("modeledOutputRowsSum", vector.modeledOutputRowsSum);
		dimensions.put("modeledJoinInputRowsSum", vector.joinInputRows);
		dimensions.put("modeledJoinOutputRowsSum", vector.joinOutputRows);
		dimensions.put("modeledSelfTimeActualSum", vector.modeledSelfTimeActualSum);
		dimensions.put("modeledHasNextCallCountSum", BigDecimal.valueOf(vector.hasNextCallCountSum));
		dimensions.put("modeledHasNextTrueCountSum", BigDecimal.valueOf(vector.hasNextTrueCountSum));
		dimensions.put("modeledHasNextTimeNanosSum", BigDecimal.valueOf(vector.hasNextTimeNanosSum));
		dimensions.put("modeledNextCallCountSum", BigDecimal.valueOf(vector.nextCallCountSum));
		dimensions.put("modeledNextTimeNanosSum", BigDecimal.valueOf(vector.nextTimeNanosSum));
		dimensions.put("modeledJoinRightIteratorCreateCountSum",
				BigDecimal.valueOf(vector.joinRightIteratorCreateCountSum));
		dimensions.put("modeledJoinLeftBindingSetConsumedCountSum",
				BigDecimal.valueOf(vector.joinLeftBindingSetConsumedCountSum));
		dimensions.put("modeledJoinRightBindingSetConsumedCountSum",
				BigDecimal.valueOf(vector.joinRightBindingSetConsumedCountSum));
		dimensions.put("modeledJoinRightBindingsPerLeftRatio", vector.joinRightBindingsPerLeftRatio);
		dimensions.put("modeledJoinTelemetryNodeCount", BigDecimal.valueOf(vector.joinTelemetryNodeCount));
		dimensions.put("modeledJoinRightBindingSetConsumedPerRightIteratorAverage",
				vector.joinRightBindingSetConsumedPerRightIteratorAverage);
		dimensions.put("modeledJoinRightIteratorCreatePerJoinNodeAverage",
				vector.joinRightIteratorCreatePerJoinNodeAverage);
		dimensions.put("modeledJoinLeftBindingSetConsumedPerJoinNodeAverage",
				vector.joinLeftBindingSetConsumedPerJoinNodeAverage);
		dimensions.put("modeledJoinRightBindingSetConsumedPerJoinNodeAverage",
				vector.joinRightBindingSetConsumedPerJoinNodeAverage);
		dimensions.put("modeledSourceRowsScannedSum", BigDecimal.valueOf(vector.sourceRowsScannedSum));
		dimensions.put("modeledSourceRowsMatchedSum", BigDecimal.valueOf(vector.sourceRowsMatchedSum));
		dimensions.put("modeledSourceRowsFilteredSum", BigDecimal.valueOf(vector.sourceRowsFilteredSum));
		dimensions.put("modeledSourceFilterOutRatio", vector.sourceFilterOutRatio);
		dimensions.put("modeledFilterRejectRatio", vector.filterRejectRatio);
		dimensions.put("modeledBarrierCount", BigDecimal.valueOf(vector.barrierCount));
		dimensions.put("estimateActualQErrorP95", vector.estimateActualQErrorP95);
		dimensions.put("joinEstimateActualQErrorP95", vector.joinEstimateActualQErrorP95);
		dimensions.putAll(vector.additionalTelemetryScalars);
		return dimensions;
	}

	private static Map<String, BigDecimal> resourceComponents(PlanVector vector) {
		LinkedHashMap<String, BigDecimal> components = new LinkedHashMap<>();
		BigDecimal rowFlow = vector.modeledInputRowsSum
				.add(vector.modeledOutputRowsSum)
				.add(vector.joinInputRows)
				.add(vector.joinOutputRows)
				.multiply(ROW_FLOW_WEIGHT);
		BigDecimal barrierPenalty = BigDecimal.valueOf(vector.barrierCount).multiply(BARRIER_WEIGHT);
		BigDecimal estimatePenalty = vector.estimateActualQErrorP95.multiply(ESTIMATE_QERROR_WEIGHT)
				.add(vector.joinEstimateActualQErrorP95.multiply(JOIN_ESTIMATE_QERROR_WEIGHT));
		BigDecimal joinInputPenalty = vector.joinInputRows.multiply(JOIN_INPUT_WEIGHT);
		BigDecimal hasNextCallPenalty = BigDecimal.valueOf(vector.hasNextCallCountSum).multiply(HAS_NEXT_CALL_WEIGHT);
		BigDecimal nextCallPenalty = BigDecimal.valueOf(vector.nextCallCountSum).multiply(NEXT_CALL_WEIGHT);
		BigDecimal hasNextTimePenalty = nanosToMillis(vector.hasNextTimeNanosSum).multiply(HAS_NEXT_TIME_WEIGHT);
		BigDecimal nextTimePenalty = nanosToMillis(vector.nextTimeNanosSum).multiply(NEXT_TIME_WEIGHT);
		BigDecimal joinRightIteratorCreatePenalty = BigDecimal.valueOf(vector.joinRightIteratorCreateCountSum)
				.multiply(JOIN_RIGHT_ITERATOR_CREATE_WEIGHT);
		BigDecimal joinRightBindingsConsumedPenalty = BigDecimal.valueOf(vector.joinRightBindingSetConsumedCountSum)
				.multiply(JOIN_RIGHT_BINDINGS_CONSUMED_WEIGHT);
		BigDecimal sourceRowsFilteredPenalty = BigDecimal.valueOf(vector.sourceRowsFilteredSum)
				.multiply(SOURCE_ROWS_FILTERED_WEIGHT)
				.add(vector.sourceFilterOutRatio.multiply(SOURCE_FILTER_RATIO_WEIGHT));
		BigDecimal filterRejectPenalty = vector.filterRejectRatio.multiply(FILTER_REJECT_RATIO_WEIGHT);

		components.put("workUnits", vector.modeledWorkUnits);
		components.put("rowFlowPenalty", rowFlow);
		components.put("joinInputPenalty", joinInputPenalty);
		components.put("barrierPenalty", barrierPenalty);
		components.put("estimatePenalty", estimatePenalty);
		components.put("hasNextCallPenalty", hasNextCallPenalty);
		components.put("nextCallPenalty", nextCallPenalty);
		components.put("hasNextTimePenalty", hasNextTimePenalty);
		components.put("nextTimePenalty", nextTimePenalty);
		components.put("joinRightIteratorCreatePenalty", joinRightIteratorCreatePenalty);
		components.put("joinRightBindingsConsumedPenalty", joinRightBindingsConsumedPenalty);
		components.put("sourceRowsFilteredPenalty", sourceRowsFilteredPenalty);
		components.put("filterRejectPenalty", filterRejectPenalty);
		components.put("selfTimePenalty", vector.modeledSelfTimeActualSum);
		for (Map.Entry<String, BigDecimal> additional : vector.additionalTelemetryScalars.entrySet()) {
			BigDecimal signal = additionalTelemetrySignal(additional.getKey(), additional.getValue());
			if (signal.signum() != 0) {
				components.put("telemetry." + additional.getKey(), signal);
			}
		}
		return components;
	}

	private static String dominantResource(Map<String, BigDecimal> components) {
		String dominant = "<none>";
		BigDecimal dominantValue = BigDecimal.ZERO;
		for (Map.Entry<String, BigDecimal> entry : components.entrySet()) {
			BigDecimal value = entry.getValue();
			if (value == null) {
				continue;
			}
			if (dominant.equals("<none>") || value.compareTo(dominantValue) > 0) {
				dominant = entry.getKey();
				dominantValue = value;
			}
		}
		return dominant;
	}

	private static BigDecimal nanosToMillis(long nanos) {
		return BigDecimal.valueOf(Math.max(0L, nanos))
				.divide(NANOS_PER_MILLI, 6, RoundingMode.HALF_UP);
	}

	private static BigDecimal nanosToMillis(BigDecimal nanos) {
		if (nanos == null || nanos.signum() <= 0) {
			return BigDecimal.ZERO;
		}
		return nanos.divide(NANOS_PER_MILLI, 6, RoundingMode.HALF_UP);
	}

	private static BigDecimal additionalTelemetrySignalTotal(PlanVector vector) {
		BigDecimal total = BigDecimal.ZERO;
		for (Map.Entry<String, BigDecimal> entry : vector.additionalTelemetryScalars.entrySet()) {
			total = total.add(additionalTelemetrySignal(entry.getKey(), entry.getValue()));
		}
		return total;
	}

	private static BigDecimal additionalTelemetrySignal(String key, BigDecimal value) {
		if (value == null || value.signum() <= 0) {
			return BigDecimal.ZERO;
		}
		BigDecimal normalized = key != null && (key.endsWith("Nanos") || key.endsWith("NanosSum"))
				? nanosToMillis(value)
				: value;
		double compressed = Math.log1p(normalized.doubleValue());
		if (!Double.isFinite(compressed) || compressed <= 0) {
			return BigDecimal.ZERO;
		}
		return BigDecimal.valueOf(compressed).multiply(ADDITIONAL_TELEMETRY_SIGNAL_WEIGHT);
	}

	private static String formatTopDeltas(Map<String, BigDecimal> leftValues, Map<String, BigDecimal> rightValues) {
		TreeSet<String> keys = new TreeSet<>();
		keys.addAll(leftValues.keySet());
		keys.addAll(rightValues.keySet());
		ArrayList<DeltaToken> deltas = new ArrayList<>();
		for (String key : keys) {
			BigDecimal left = leftValues.getOrDefault(key, BigDecimal.ZERO);
			BigDecimal right = rightValues.getOrDefault(key, BigDecimal.ZERO);
			BigDecimal delta = right.subtract(left);
			if (delta.compareTo(BigDecimal.ZERO) != 0) {
				deltas.add(new DeltaToken(key, delta));
			}
		}

		if (deltas.isEmpty()) {
			return "<none>";
		}

		deltas.sort(Comparator.<DeltaToken, BigDecimal>comparing(delta -> delta.delta.abs())
				.reversed()
				.thenComparing(delta -> delta.key));

		ArrayList<String> tokens = new ArrayList<>();
		for (int i = 0; i < Math.min(TOP_DELTA_LIMIT, deltas.size()); i++) {
			DeltaToken delta = deltas.get(i);
			tokens.add(delta.key + ":" + signedToken(delta.delta));
		}
		return String.join(";", tokens);
	}

	private static Map<String, BigDecimal> parseSimpleNumberMap(String raw) {
		return parseSimpleNumberMap(raw, '=');
	}

	private static Map<String, BigDecimal> parseSimpleNumberMap(String raw, char delimiter) {
		if (raw == null || raw.isBlank() || "<none>".equals(raw)) {
			return Collections.emptyMap();
		}
		LinkedHashMap<String, BigDecimal> parsed = new LinkedHashMap<>();
		String[] entries = raw.split(";");
		for (String entry : entries) {
			String trimmed = entry.trim();
			if (trimmed.isEmpty()) {
				continue;
			}
			int delimiterIndex = trimmed.indexOf(delimiter);
			if (delimiterIndex <= 0 || delimiterIndex == trimmed.length() - 1) {
				continue;
			}
			String key = trimmed.substring(0, delimiterIndex);
			BigDecimal value = parseDecimal(trimmed.substring(delimiterIndex + 1));
			if (value != null) {
				parsed.put(key, value);
			}
		}
		return parsed;
	}

	private static Map<String, BigDecimal> parseOperatorWorkUnits(String raw) {
		if (raw == null || raw.isBlank() || "<none>".equals(raw)) {
			return Collections.emptyMap();
		}

		LinkedHashMap<String, BigDecimal> parsed = new LinkedHashMap<>();
		String[] entries = raw.split(";");
		for (String entry : entries) {
			String trimmed = entry.trim();
			if (trimmed.isEmpty()) {
				continue;
			}
			String[] parts = trimmed.split("\\|");
			if (parts.length == 0) {
				continue;
			}
			String key = parts[0];
			for (int i = 1; i < parts.length; i++) {
				String part = parts[i];
				if (!part.startsWith("workUnits=")) {
					continue;
				}
				BigDecimal workUnits = parseDecimal(part.substring("workUnits=".length()));
				if (workUnits != null) {
					parsed.put(key, workUnits);
				}
				break;
			}
		}
		return parsed;
	}

	private static Map<String, BigDecimal> parseAdditionalTelemetryScalars(Map<String, String> metrics) {
		if (metrics == null || metrics.isEmpty()) {
			return Collections.emptyMap();
		}
		LinkedHashMap<String, BigDecimal> additional = new LinkedHashMap<>();
		for (Map.Entry<String, String> metric : metrics.entrySet()) {
			if (metric.getKey() == null || CORE_EXECUTED_METRIC_KEYS.contains(metric.getKey())) {
				continue;
			}
			BigDecimal parsed = parseDecimal(metric.getValue());
			if (parsed == null || parsed.signum() < 0) {
				continue;
			}
			additional.put(metric.getKey(), parsed);
		}
		return additional;
	}

	private static BigDecimal parseDecimalOrZero(String value) {
		BigDecimal parsed = parseDecimal(value);
		return parsed == null ? BigDecimal.ZERO : parsed;
	}

	private static long parseLongOrZero(String value) {
		if (value == null || value.isBlank()) {
			return 0L;
		}
		try {
			return Long.parseLong(value);
		} catch (NumberFormatException ignored) {
			return 0L;
		}
	}

	private static BigDecimal parseDecimal(String value) {
		if (value == null || value.isBlank()) {
			return null;
		}
		try {
			return new BigDecimal(value);
		} catch (NumberFormatException ignored) {
			return null;
		}
	}

	private static String signedToken(BigDecimal value) {
		if (value == null) {
			return "<null>";
		}
		String sign = value.signum() >= 0 ? "+" : "-";
		return sign + toPlainString(value.abs());
	}

	private static String toPlainString(BigDecimal value) {
		if (value == null) {
			return "";
		}
		BigDecimal stripped = value.stripTrailingZeros();
		if (stripped.scale() < 0) {
			stripped = stripped.setScale(0);
		}
		return stripped.toPlainString();
	}

	private static final class Decision {
		private final String winner;
		private final String decisionBasis;

		private Decision(String winner, String decisionBasis) {
			this.winner = winner;
			this.decisionBasis = decisionBasis;
		}
	}

	private static final class DeltaToken {
		private final String key;
		private final BigDecimal delta;

		private DeltaToken(String key, BigDecimal delta) {
			this.key = key;
			this.delta = delta;
		}
	}

	private static final class PlanVector {
		private final boolean available;
		private final String unavailableReason;
		private final BigDecimal modeledWorkUnits;
		private final BigDecimal modeledInputRowsSum;
		private final BigDecimal modeledOutputRowsSum;
		private final BigDecimal joinInputRows;
		private final BigDecimal joinOutputRows;
		private final BigDecimal modeledSelfTimeActualSum;
		private final BigDecimal estimateActualQErrorP95;
		private final BigDecimal joinEstimateActualQErrorP95;
		private final BigDecimal filterRejectRatio;
		private final long barrierCount;
		private final long hasNextCallCountSum;
		private final long hasNextTrueCountSum;
		private final long hasNextTimeNanosSum;
		private final long nextCallCountSum;
		private final long nextTimeNanosSum;
		private final long joinRightIteratorCreateCountSum;
		private final long joinLeftBindingSetConsumedCountSum;
		private final long joinRightBindingSetConsumedCountSum;
		private final BigDecimal joinRightBindingsPerLeftRatio;
		private final long joinTelemetryNodeCount;
		private final BigDecimal joinRightBindingSetConsumedPerRightIteratorAverage;
		private final BigDecimal joinRightIteratorCreatePerJoinNodeAverage;
		private final BigDecimal joinLeftBindingSetConsumedPerJoinNodeAverage;
		private final BigDecimal joinRightBindingSetConsumedPerJoinNodeAverage;
		private final long sourceRowsScannedSum;
		private final long sourceRowsMatchedSum;
		private final long sourceRowsFilteredSum;
		private final BigDecimal sourceFilterOutRatio;
		private final Map<String, BigDecimal> modeledWorkByCategory;
		private final Map<String, BigDecimal> operatorWorkUnits;
		private final Map<String, BigDecimal> additionalTelemetryScalars;

		private PlanVector(boolean available, String unavailableReason, BigDecimal modeledWorkUnits,
				BigDecimal modeledInputRowsSum, BigDecimal modeledOutputRowsSum, BigDecimal joinInputRows,
				BigDecimal joinOutputRows, BigDecimal modeledSelfTimeActualSum, BigDecimal estimateActualQErrorP95,
				BigDecimal joinEstimateActualQErrorP95, BigDecimal filterRejectRatio, long barrierCount,
				long hasNextCallCountSum,
				long hasNextTrueCountSum, long hasNextTimeNanosSum, long nextCallCountSum, long nextTimeNanosSum,
				long joinRightIteratorCreateCountSum, long joinLeftBindingSetConsumedCountSum,
				long joinRightBindingSetConsumedCountSum, BigDecimal joinRightBindingsPerLeftRatio,
				long joinTelemetryNodeCount,
				BigDecimal joinRightBindingSetConsumedPerRightIteratorAverage,
				BigDecimal joinRightIteratorCreatePerJoinNodeAverage,
				BigDecimal joinLeftBindingSetConsumedPerJoinNodeAverage,
				BigDecimal joinRightBindingSetConsumedPerJoinNodeAverage,
				long sourceRowsScannedSum, long sourceRowsMatchedSum, long sourceRowsFilteredSum,
				BigDecimal sourceFilterOutRatio,
				Map<String, BigDecimal> modeledWorkByCategory,
				Map<String, BigDecimal> operatorWorkUnits,
				Map<String, BigDecimal> additionalTelemetryScalars) {
			this.available = available;
			this.unavailableReason = unavailableReason;
			this.modeledWorkUnits = modeledWorkUnits;
			this.modeledInputRowsSum = modeledInputRowsSum;
			this.modeledOutputRowsSum = modeledOutputRowsSum;
			this.joinInputRows = joinInputRows;
			this.joinOutputRows = joinOutputRows;
			this.modeledSelfTimeActualSum = modeledSelfTimeActualSum;
			this.estimateActualQErrorP95 = estimateActualQErrorP95;
			this.joinEstimateActualQErrorP95 = joinEstimateActualQErrorP95;
			this.filterRejectRatio = filterRejectRatio;
			this.barrierCount = barrierCount;
			this.hasNextCallCountSum = hasNextCallCountSum;
			this.hasNextTrueCountSum = hasNextTrueCountSum;
			this.hasNextTimeNanosSum = hasNextTimeNanosSum;
			this.nextCallCountSum = nextCallCountSum;
			this.nextTimeNanosSum = nextTimeNanosSum;
			this.joinRightIteratorCreateCountSum = joinRightIteratorCreateCountSum;
			this.joinLeftBindingSetConsumedCountSum = joinLeftBindingSetConsumedCountSum;
			this.joinRightBindingSetConsumedCountSum = joinRightBindingSetConsumedCountSum;
			this.joinRightBindingsPerLeftRatio = joinRightBindingsPerLeftRatio;
			this.joinTelemetryNodeCount = joinTelemetryNodeCount;
			this.joinRightBindingSetConsumedPerRightIteratorAverage = joinRightBindingSetConsumedPerRightIteratorAverage;
			this.joinRightIteratorCreatePerJoinNodeAverage = joinRightIteratorCreatePerJoinNodeAverage;
			this.joinLeftBindingSetConsumedPerJoinNodeAverage = joinLeftBindingSetConsumedPerJoinNodeAverage;
			this.joinRightBindingSetConsumedPerJoinNodeAverage = joinRightBindingSetConsumedPerJoinNodeAverage;
			this.sourceRowsScannedSum = sourceRowsScannedSum;
			this.sourceRowsMatchedSum = sourceRowsMatchedSum;
			this.sourceRowsFilteredSum = sourceRowsFilteredSum;
			this.sourceFilterOutRatio = sourceFilterOutRatio;
			this.modeledWorkByCategory = modeledWorkByCategory;
			this.operatorWorkUnits = operatorWorkUnits;
			this.additionalTelemetryScalars = additionalTelemetryScalars;
		}

		private static PlanVector unavailable(String reason) {
			return new PlanVector(false, reason, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO,
					BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, 0L, 0L, 0L, 0L,
					0L, 0L,
					0L, 0L, 0L, BigDecimal.ZERO, 0L, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO,
					0L, 0L, 0L, BigDecimal.ZERO,
					Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap());
		}

		private static PlanVector available(BigDecimal modeledWorkUnits, BigDecimal modeledInputRowsSum,
				BigDecimal modeledOutputRowsSum, BigDecimal joinInputRows, BigDecimal joinOutputRows,
				BigDecimal modeledSelfTimeActualSum, BigDecimal estimateActualQErrorP95,
				BigDecimal joinEstimateActualQErrorP95, BigDecimal filterRejectRatio, long barrierCount,
				long hasNextCallCountSum,
				long hasNextTrueCountSum, long hasNextTimeNanosSum, long nextCallCountSum, long nextTimeNanosSum,
				long joinRightIteratorCreateCountSum, long joinLeftBindingSetConsumedCountSum,
				long joinRightBindingSetConsumedCountSum, BigDecimal joinRightBindingsPerLeftRatio,
				long joinTelemetryNodeCount,
				BigDecimal joinRightBindingSetConsumedPerRightIteratorAverage,
				BigDecimal joinRightIteratorCreatePerJoinNodeAverage,
				BigDecimal joinLeftBindingSetConsumedPerJoinNodeAverage,
				BigDecimal joinRightBindingSetConsumedPerJoinNodeAverage,
				long sourceRowsScannedSum, long sourceRowsMatchedSum, long sourceRowsFilteredSum,
				BigDecimal sourceFilterOutRatio,
				Map<String, BigDecimal> modeledWorkByCategory,
				Map<String, BigDecimal> operatorWorkUnits,
				Map<String, BigDecimal> additionalTelemetryScalars) {
			return new PlanVector(true, null, modeledWorkUnits, modeledInputRowsSum, modeledOutputRowsSum,
					joinInputRows, joinOutputRows, modeledSelfTimeActualSum, estimateActualQErrorP95,
					joinEstimateActualQErrorP95, filterRejectRatio, barrierCount, hasNextCallCountSum,
					hasNextTrueCountSum, hasNextTimeNanosSum, nextCallCountSum, nextTimeNanosSum,
					joinRightIteratorCreateCountSum, joinLeftBindingSetConsumedCountSum,
					joinRightBindingSetConsumedCountSum, joinRightBindingsPerLeftRatio, joinTelemetryNodeCount,
					joinRightBindingSetConsumedPerRightIteratorAverage, joinRightIteratorCreatePerJoinNodeAverage,
					joinLeftBindingSetConsumedPerJoinNodeAverage, joinRightBindingSetConsumedPerJoinNodeAverage,
					sourceRowsScannedSum, sourceRowsMatchedSum, sourceRowsFilteredSum, sourceFilterOutRatio,
					modeledWorkByCategory,
					operatorWorkUnits,
					additionalTelemetryScalars);
		}
	}

	static final class ExecutedWorkComparison {
		private final boolean available;
		private final String unavailableReason;
		private final BigDecimal leftScore;
		private final BigDecimal rightScore;
		private final BigDecimal scoreDeltaPct;
		private final String winner;
		private final String decisionBasis;
		private final String topCategoryDeltas;
		private final String topOperatorDeltas;
		private final String topVectorDeltas;
		private final String dominantResourceLeft;
		private final String dominantResourceRight;
		private final String topResourceDeltas;

		private ExecutedWorkComparison(boolean available, String unavailableReason, BigDecimal leftScore,
				BigDecimal rightScore,
				BigDecimal scoreDeltaPct, String winner, String decisionBasis, String topCategoryDeltas,
				String topOperatorDeltas, String topVectorDeltas, String dominantResourceLeft,
				String dominantResourceRight, String topResourceDeltas) {
			this.available = available;
			this.unavailableReason = unavailableReason;
			this.leftScore = leftScore;
			this.rightScore = rightScore;
			this.scoreDeltaPct = scoreDeltaPct;
			this.winner = winner;
			this.decisionBasis = decisionBasis;
			this.topCategoryDeltas = topCategoryDeltas;
			this.topOperatorDeltas = topOperatorDeltas;
			this.topVectorDeltas = topVectorDeltas;
			this.dominantResourceLeft = dominantResourceLeft;
			this.dominantResourceRight = dominantResourceRight;
			this.topResourceDeltas = topResourceDeltas;
		}

		private static ExecutedWorkComparison unavailable(String reason) {
			return new ExecutedWorkComparison(false, reason, null, null, null, "unavailable", "unavailable", "<none>",
					"<none>", "<none>", "<none>", "<none>", "<none>");
		}

		private static ExecutedWorkComparison available(BigDecimal leftScore, BigDecimal rightScore,
				BigDecimal scoreDeltaPct,
				String winner, String decisionBasis, String topCategoryDeltas, String topOperatorDeltas,
				String topVectorDeltas, String dominantResourceLeft, String dominantResourceRight,
				String topResourceDeltas) {
			return new ExecutedWorkComparison(true, null, leftScore, rightScore, scoreDeltaPct, winner, decisionBasis,
					topCategoryDeltas, topOperatorDeltas, topVectorDeltas, dominantResourceLeft, dominantResourceRight,
					topResourceDeltas);
		}

		boolean available() {
			return available;
		}

		String unavailableReason() {
			return unavailableReason == null ? "" : unavailableReason;
		}

		String leftScore() {
			return toPlainString(leftScore);
		}

		String rightScore() {
			return toPlainString(rightScore);
		}

		String scoreDeltaPct() {
			return toPlainString(scoreDeltaPct);
		}

		String winner() {
			return winner;
		}

		String decisionBasis() {
			return decisionBasis;
		}

		String topCategoryDeltas() {
			return topCategoryDeltas;
		}

		String topOperatorDeltas() {
			return topOperatorDeltas;
		}

		String topVectorDeltas() {
			return topVectorDeltas;
		}

		String dominantResourceLeft() {
			return dominantResourceLeft;
		}

		String dominantResourceRight() {
			return dominantResourceRight;
		}

		String topResourceDeltas() {
			return topResourceDeltas;
		}
	}
}
