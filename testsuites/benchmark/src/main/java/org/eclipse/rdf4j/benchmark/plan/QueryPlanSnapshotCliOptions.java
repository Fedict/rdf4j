/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.PrintStream;
import java.nio.file.Path;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;

final class QueryPlanSnapshotCliOptions {

	static final String QUERY_END_SENTINEL = "END";
	private static final String STORE_MEMORY = "memory";
	private static final String STORE_LMDB = "lmdb";

	boolean help;
	boolean noInteractive;
	boolean listThemes;
	Theme listQueriesTheme;
	boolean compareExisting;
	boolean renameRunsByCommit;
	boolean compareLatest;
	boolean runAllThemeQueries;
	boolean persist = true;
	DiffMode diffMode = DiffMode.STRUCTURE;
	ComparisonPair compareIndices;
	RunNamePair compareRunNames;
	String comparisonFingerprint;
	int argumentCount;
	StoreType store;
	Theme theme;
	Integer queryIndex;
	String query;
	Path queryFile;
	Path outputDirectory;
	String queryId;
	String runName;
	Path emitCsv;
	Path lmdbDataDirectory;
	Integer queryTimeoutSeconds;
	Integer executionRepeatMinRuns;
	Integer executionRepeatMaxRuns;
	Long executionRepeatSoftLimitMillis;
	final LinkedHashMap<String, String> systemProperties = new LinkedHashMap<>();
	final LinkedHashMap<String, String> metadata = new LinkedHashMap<>();

	private QueryPlanSnapshotCliOptions() {
	}

	QueryPlanSnapshotCliOptions copy() {
		QueryPlanSnapshotCliOptions copy = new QueryPlanSnapshotCliOptions();
		copy.help = help;
		copy.noInteractive = noInteractive;
		copy.listThemes = listThemes;
		copy.listQueriesTheme = listQueriesTheme;
		copy.compareExisting = compareExisting;
		copy.renameRunsByCommit = renameRunsByCommit;
		copy.compareLatest = compareLatest;
		copy.runAllThemeQueries = runAllThemeQueries;
		copy.persist = persist;
		copy.diffMode = diffMode;
		copy.compareIndices = compareIndices;
		copy.compareRunNames = compareRunNames;
		copy.comparisonFingerprint = comparisonFingerprint;
		copy.argumentCount = argumentCount;
		copy.store = store;
		copy.theme = theme;
		copy.queryIndex = queryIndex;
		copy.query = query;
		copy.queryFile = queryFile;
		copy.outputDirectory = outputDirectory;
		copy.queryId = queryId;
		copy.runName = runName;
		copy.emitCsv = emitCsv;
		copy.lmdbDataDirectory = lmdbDataDirectory;
		copy.queryTimeoutSeconds = queryTimeoutSeconds;
		copy.executionRepeatMinRuns = executionRepeatMinRuns;
		copy.executionRepeatMaxRuns = executionRepeatMaxRuns;
		copy.executionRepeatSoftLimitMillis = executionRepeatSoftLimitMillis;
		copy.systemProperties.putAll(systemProperties);
		copy.metadata.putAll(metadata);
		return copy;
	}

	boolean hasQueryInput() {
		return queryIndex != null || (query != null && !query.isBlank()) || queryFile != null;
	}

	boolean hasComparisonFilter() {
		return (queryId != null && !queryId.isBlank())
				|| (comparisonFingerprint != null && !comparisonFingerprint.isBlank())
				|| (runName != null && !runName.isBlank())
				|| compareRunNames != null;
	}

	boolean isRunMode() {
		return !compareExisting && !renameRunsByCommit;
	}

	static boolean requiresInteractiveInput(QueryPlanSnapshotCliOptions options) {
		if (options.help || options.listThemes || options.listQueriesTheme != null || options.noInteractive) {
			return false;
		}
		return options.argumentCount == 0 || missingRequiredOptions(options);
	}

	static QueryPlanSnapshotCliOptions parseArgs(String[] args) {
		Objects.requireNonNull(args, "args");
		QueryPlanSnapshotCliOptions options = new QueryPlanSnapshotCliOptions();
		options.argumentCount = args.length;

		for (int i = 0; i < args.length; i++) {
			String arg = args[i];
			switch (arg) {
			case "--help":
			case "-h":
				options.help = true;
				break;
			case "--no-interactive":
				options.noInteractive = true;
				break;
			case "--list-themes":
				options.listThemes = true;
				break;
			case "--list-queries":
				options.listQueriesTheme = parseTheme(requireValue(args, ++i, arg));
				break;
			case "--compare-existing":
				options.compareExisting = true;
				break;
			case "--compare-latest":
				options.compareLatest = true;
				break;
			case "--all-theme-queries":
				options.runAllThemeQueries = true;
				break;
			case "--diff-mode":
				options.diffMode = parseDiffMode(requireValue(args, ++i, arg), arg);
				break;
			case "--compare-indices":
				options.compareIndices = parseComparisonPair(requireValue(args, ++i, arg), arg);
				break;
			case "--compare-run-names":
				options.compareRunNames = parseRunNamePair(requireValue(args, ++i, arg), arg);
				options.compareExisting = true;
				break;
			case "--fingerprint":
				options.comparisonFingerprint = requireValue(args, ++i, arg);
				break;
			case "--emit-csv":
				options.emitCsv = Path.of(requireValue(args, ++i, arg));
				break;
			case "--persist":
				options.persist = parseBoolean(requireValue(args, ++i, arg), arg);
				break;
			case "--no-persist":
				options.persist = false;
				break;
			case "--store":
				options.store = parseStore(requireValue(args, ++i, arg));
				break;
			case "--theme":
				options.theme = parseTheme(requireValue(args, ++i, arg));
				break;
			case "--theme-query":
				parseThemeQuerySelection(requireValue(args, ++i, arg), options);
				break;
			case "--query-index":
				options.queryIndex = parseQueryIndex(requireValue(args, ++i, arg));
				break;
			case "--query":
				options.query = requireValue(args, ++i, arg);
				break;
			case "--query-file":
				options.queryFile = Path.of(requireValue(args, ++i, arg));
				break;
			case "--output-dir":
				options.outputDirectory = Path.of(requireValue(args, ++i, arg));
				break;
			case "--query-id":
				options.queryId = requireValue(args, ++i, arg);
				break;
			case "--run-name":
				options.runName = requireValue(args, ++i, arg);
				break;
			case "--lmdb-data-dir":
				options.lmdbDataDirectory = Path.of(requireValue(args, ++i, arg));
				break;
			case "--query-timeout-seconds":
				options.queryTimeoutSeconds = parseNonNegativeInteger(requireValue(args, ++i, arg), arg);
				break;
			case "--execution-repeat-min-runs":
				options.executionRepeatMinRuns = parsePositiveInteger(requireValue(args, ++i, arg), arg);
				break;
			case "--execution-repeat-max-runs":
				options.executionRepeatMaxRuns = parsePositiveInteger(requireValue(args, ++i, arg), arg);
				break;
			case "--execution-repeat-soft-limit-millis":
				options.executionRepeatSoftLimitMillis = parsePositiveLong(requireValue(args, ++i, arg), arg);
				break;
			case "--property": {
				Assignment assignment = parseAssignment(requireValue(args, ++i, arg), arg);
				options.systemProperties.put(assignment.key, assignment.value);
				break;
			}
			case "--metadata": {
				Assignment assignment = parseAssignment(requireValue(args, ++i, arg), arg);
				options.metadata.put(assignment.key, assignment.value);
				break;
			}
			default:
				if (arg.startsWith("-D")) {
					Assignment assignment = parseAssignment(arg.substring(2), arg);
					options.systemProperties.put(assignment.key, assignment.value);
					break;
				}
				throw new IllegalArgumentException("Unknown argument: " + arg);
			}
		}

		validateCombinations(options);
		return options;
	}

	private static void validateCombinations(QueryPlanSnapshotCliOptions options) {
		if (options.help || options.listThemes || options.listQueriesTheme != null) {
			return;
		}

		if (options.compareExisting) {
			if (options.compareLatest) {
				throw new IllegalArgumentException("Use either --compare-existing or --compare-latest, not both.");
			}
			if (options.runAllThemeQueries) {
				throw new IllegalArgumentException("--all-theme-queries is only supported in run mode.");
			}
			if (options.compareRunNames != null) {
				if (options.runName != null && !options.runName.isBlank()) {
					throw new IllegalArgumentException("--compare-run-names cannot be combined with --run-name.");
				}
				if (options.comparisonFingerprint != null && !options.comparisonFingerprint.isBlank()) {
					throw new IllegalArgumentException("--compare-run-names cannot be combined with --fingerprint.");
				}
				if (options.compareIndices != null) {
					throw new IllegalArgumentException(
							"--compare-run-names cannot be combined with --compare-indices.");
				}
			}
			if (options.noInteractive && !options.hasComparisonFilter()) {
				throw new IllegalArgumentException(
						"--compare-existing with --no-interactive requires --query-id, --run-name, or --fingerprint.");
			}
			if (options.emitCsv != null && options.compareRunNames == null) {
				throw new IllegalArgumentException("--emit-csv requires --compare-run-names.");
			}
			return;
		}

		if (options.emitCsv != null) {
			throw new IllegalArgumentException("--emit-csv is only supported in --compare-existing mode.");
		}

		if (options.runAllThemeQueries) {
			if (options.hasQueryInput()) {
				throw new IllegalArgumentException(
						"Do not combine --all-theme-queries with --query, --query-file, --query-index or --theme-query.");
			}
			if (options.queryId != null && !options.queryId.isBlank()) {
				throw new IllegalArgumentException("Do not combine --all-theme-queries with --query-id.");
			}
			if (options.noInteractive && options.store == null) {
				throw new IllegalArgumentException("--no-interactive with --all-theme-queries requires --store.");
			}
			return;
		}

		if (options.query != null && options.queryIndex != null) {
			throw new IllegalArgumentException("Use either --query or --query-index, not both.");
		}
		if (options.queryFile != null && options.queryIndex != null) {
			throw new IllegalArgumentException("Use either --query-file or --query-index, not both.");
		}
		if (options.query != null && options.queryFile != null) {
			throw new IllegalArgumentException("Use either --query or --query-file, not both.");
		}
		if (options.noInteractive && missingRequiredRunOptions(options)) {
			throw new IllegalArgumentException(
					"--no-interactive requires --store, --theme and query input in run mode.");
		}
		if (options.executionRepeatMinRuns != null && options.executionRepeatMaxRuns != null
				&& options.executionRepeatMinRuns > options.executionRepeatMaxRuns) {
			throw new IllegalArgumentException(
					"--execution-repeat-min-runs must be <= --execution-repeat-max-runs.");
		}
	}

	private static boolean missingRequiredOptions(QueryPlanSnapshotCliOptions options) {
		if (options.compareExisting) {
			return !options.hasComparisonFilter();
		}
		return missingRequiredRunOptions(options);
	}

	private static boolean missingRequiredRunOptions(QueryPlanSnapshotCliOptions options) {
		if (options.runAllThemeQueries) {
			return options.store == null;
		}
		return options.store == null || options.theme == null || !options.hasQueryInput();
	}

	static Assignment parseAssignment(String raw, String optionName) {
		String candidate = Objects.requireNonNull(raw, "raw").trim();
		int separator = candidate.indexOf('=');
		if (separator <= 0) {
			throw new IllegalArgumentException("Invalid " + optionName + " value: '" + raw + "'. Expected key=value.");
		}
		String key = candidate.substring(0, separator).trim();
		String value = candidate.substring(separator + 1).trim();
		if (key.isEmpty()) {
			throw new IllegalArgumentException("Invalid " + optionName + " key in value: '" + raw + "'.");
		}
		return new Assignment(key, value);
	}

	private static void parseThemeQuerySelection(String value, QueryPlanSnapshotCliOptions options) {
		int separator = value.indexOf(':');
		if (separator <= 0 || separator == value.length() - 1) {
			throw new IllegalArgumentException(
					"Invalid --theme-query value '" + value + "'. Expected THEME:INDEX.");
		}

		Theme parsedTheme = parseTheme(value.substring(0, separator));
		Integer parsedIndex = parseQueryIndex(value.substring(separator + 1));

		if (options.theme != null && options.theme != parsedTheme) {
			throw new IllegalArgumentException("Conflicting theme values between --theme and --theme-query.");
		}
		if (options.queryIndex != null && !options.queryIndex.equals(parsedIndex)) {
			throw new IllegalArgumentException(
					"Conflicting query index values between --query-index and --theme-query.");
		}

		options.theme = parsedTheme;
		options.queryIndex = parsedIndex;
	}

	private static ComparisonPair parseComparisonPair(String value, String optionName) {
		int separator = value.indexOf(',');
		if (separator <= 0 || separator == value.length() - 1) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Expected i,j.");
		}
		try {
			int left = Integer.parseInt(value.substring(0, separator).trim());
			int right = Integer.parseInt(value.substring(separator + 1).trim());
			return new ComparisonPair(left, right);
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Expected i,j.", e);
		}
	}

	private static RunNamePair parseRunNamePair(String value, String optionName) {
		int separator = value.indexOf(',');
		if (separator <= 0 || separator == value.length() - 1) {
			throw new IllegalArgumentException(
					"Invalid " + optionName + " value '" + value + "'. Expected leftRunName,rightRunName.");
		}
		String left = value.substring(0, separator).trim();
		String right = value.substring(separator + 1).trim();
		if (left.isEmpty() || right.isEmpty()) {
			throw new IllegalArgumentException(
					"Invalid " + optionName + " value '" + value + "'. Run names must be non-empty.");
		}
		return new RunNamePair(left, right);
	}

	private static int parseQueryIndex(String value) {
		int parsed;
		try {
			parsed = Integer.parseInt(value.trim());
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("Invalid query index '" + value + "'.", e);
		}
		if (parsed < 0 || parsed >= ThemeQueryCatalog.QUERY_COUNT) {
			throw new IllegalArgumentException(
					"Query index out of range: " + parsed + ". Allowed 0-" + (ThemeQueryCatalog.QUERY_COUNT - 1));
		}
		return parsed;
	}

	private static boolean parseBoolean(String value, String optionName) {
		String normalized = value.trim().toLowerCase(Locale.ROOT);
		if ("true".equals(normalized)) {
			return true;
		}
		if ("false".equals(normalized)) {
			return false;
		}
		throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Use true or false.");
	}

	static int parseNonNegativeInteger(String value, String optionName) {
		int parsed;
		try {
			parsed = Integer.parseInt(value.trim());
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Use a whole number.",
					e);
		}
		if (parsed < 0) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Must be >= 0.");
		}
		return parsed;
	}

	private static int parsePositiveInteger(String value, String optionName) {
		int parsed = parseNonNegativeInteger(value, optionName);
		if (parsed < 1) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Must be >= 1.");
		}
		return parsed;
	}

	private static long parsePositiveLong(String value, String optionName) {
		long parsed;
		try {
			parsed = Long.parseLong(value.trim());
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Use a whole number.",
					e);
		}
		if (parsed < 1L) {
			throw new IllegalArgumentException("Invalid " + optionName + " value '" + value + "'. Must be >= 1.");
		}
		return parsed;
	}

	private static DiffMode parseDiffMode(String value, String optionName) {
		String normalized = value.trim().toLowerCase(Locale.ROOT);
		for (DiffMode mode : DiffMode.values()) {
			if (mode.id.equals(normalized)) {
				return mode;
			}
		}
		throw new IllegalArgumentException("Invalid " + optionName + " value '" + value
				+ "'. Use structure or structure+estimates.");
	}

	private static StoreType parseStore(String value) {
		String normalized = value.trim().toLowerCase(Locale.ROOT);
		if (STORE_MEMORY.equals(normalized)) {
			return StoreType.MEMORY;
		}
		if (STORE_LMDB.equals(normalized)) {
			return StoreType.LMDB;
		}
		throw new IllegalArgumentException("Unsupported store '" + value + "'. Use memory or lmdb.");
	}

	private static Theme parseTheme(String value) {
		try {
			return Theme.valueOf(value.trim().toUpperCase(Locale.ROOT));
		} catch (IllegalArgumentException e) {
			throw new IllegalArgumentException(
					"Unknown theme '" + value + "'. Valid: " + String.join(", ", themeNames()),
					e);
		}
	}

	private static String requireValue(String[] args, int index, String optionName) {
		if (index >= args.length) {
			throw new IllegalArgumentException("Missing value for " + optionName);
		}
		return args[index];
	}

	static String[] themeNames() {
		Theme[] values = Theme.values();
		String[] names = new String[values.length];
		for (int i = 0; i < values.length; i++) {
			names[i] = values[i].name();
		}
		return names;
	}

	static StoreType parseStoreValue(String value) {
		return parseStore(value);
	}

	static Theme parseThemeValue(String value) {
		return parseTheme(value);
	}

	static int parseQueryIndexValue(String value) {
		return parseQueryIndex(value);
	}

	static ComparisonPair parseComparisonPairValue(String value) {
		return parseComparisonPair(value, "comparison pair");
	}

	static DiffMode parseDiffModeValue(String value) {
		return parseDiffMode(value, "diff mode");
	}

	static void printUsage(PrintStream output) {
		output.println("Query plan snapshot CLI");
		output.println();
		output.println("Maven:");
		output.println("  mvn -pl testsuites/benchmark -DskipTests exec:java@query-plan-snapshot");
		output.println("  mvn -pl testsuites/benchmark -DskipTests exec:java@query-plan-snapshot \\");
		output.println(
				"      -Dexec.args=\"--store memory --theme MEDICAL_RECORDS --query-index 0 --compare-latest\"");
		output.println();
		output.println("Run options:");
		output.println("  --store <memory|lmdb>");
		output.println("  --theme <THEME>");
		output.println("  --query-index <0-10>                 themed query selection");
		output.println("  --theme-query <THEME:INDEX>          shortcut for themed query");
		output.println(
				"  --all-theme-queries                  run all queries (all themes, or only --theme if supplied)");
		output.println("  --query <SPARQL>                     direct query text");
		output.println("  --query-file <path>                  load query text from file");
		output.println("  --query-timeout-seconds <int>=0      per-query max execution time (0 disables timeout)");
		output.println("  --execution-repeat-min-runs <int>=1  minimum repeated verification runs");
		output.println("  --execution-repeat-max-runs <int>=1  maximum repeated verification runs");
		output.println("  --execution-repeat-soft-limit-millis <long>=1");
		output.println("                                       soft time budget before verification stops");
		output.println("  --persist <true|false> | --no-persist");
		output.println("  --compare-latest                     compare current run with latest prior run");
		output.println();
		output.println("Compare-existing mode:");
		output.println("  --compare-existing");
		output.println("  --query-id <id> or --run-name <name> or --fingerprint <hash>");
		output.println("  --compare-indices <i,j>              optional, else interactive/latest-two");
		output.println("  --compare-run-names <left,right>     batch compare run names by query id");
		output.println("  --emit-csv <path>                    write batch comparison CSV (run-name mode)");
		output.println("  --diff-mode <structure|structure+estimates>");
		output.println("  interactive UI supports run browsing/view and comparison");
		output.println();
		output.println("Shared options:");
		output.println("  --property <key=value> or -Dk=v      set JVM system property for this run");
		output.println("  --metadata <key=value>               metadata key/value stored in snapshot");
		output.println(
				"  --output-dir <path>                  default: testsuites/benchmark/src/main/resources/plan[/cli/<store>]");
		output.println("  --query-id <id>                      custom query id in run mode / compare filter");
		output.println("  --run-name <name>                    label a run / compare filter by run label");
		output.println("  --lmdb-data-dir <path>               optional persistent LMDB directory");
		output.println("  --list-themes                        list available themes");
		output.println("  --list-queries <THEME>               list query index/name for a theme");
		output.println("  --no-interactive                     fail if required args are missing");
		output.println("  --help, -h                           show this help");
		output.println();
		output.println("Interactive mode starts when no args or required args are missing.");
		output.println("Manual query paste ends with line '" + QUERY_END_SENTINEL + "'.");
	}

	enum StoreType {
		MEMORY(STORE_MEMORY),
		LMDB(STORE_LMDB);

		final String id;

		StoreType(String id) {
			this.id = id;
		}
	}

	enum DiffMode {
		STRUCTURE("structure", false),
		STRUCTURE_WITH_ESTIMATES("structure+estimates", true);

		final String id;
		final boolean includeEstimates;

		DiffMode(String id, boolean includeEstimates) {
			this.id = id;
			this.includeEstimates = includeEstimates;
		}
	}

	static final class Assignment {
		private final String key;
		private final String value;

		Assignment(String key, String value) {
			this.key = Objects.requireNonNull(key, "key");
			this.value = Objects.requireNonNull(value, "value");
		}

		String getKey() {
			return key;
		}

		String getValue() {
			return value;
		}
	}

	static final class ComparisonPair {
		final int leftIndex;
		final int rightIndex;

		ComparisonPair(int leftIndex, int rightIndex) {
			this.leftIndex = leftIndex;
			this.rightIndex = rightIndex;
		}
	}

	static final class RunNamePair {
		final String leftRunName;
		final String rightRunName;

		RunNamePair(String leftRunName, String rightRunName) {
			this.leftRunName = leftRunName;
			this.rightRunName = rightRunName;
		}
	}

	QueryPlanSnapshotCliOptions.StoreType getStore() {
		return store;
	}

	Theme getTheme() {
		return theme;
	}

	Integer getQueryIndex() {
		return queryIndex;
	}

	String getQuery() {
		return query;
	}

	Map<String, String> getSystemProperties() {
		return systemProperties;
	}

	Map<String, String> getMetadata() {
		return metadata;
	}
}
