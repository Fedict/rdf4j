/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import org.eclipse.rdf4j.benchmark.common.BenchmarkQuery;
import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.common.plan.FeatureFlagCollector;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCapture;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCaptureContext;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.annotation.Experimental;
import org.eclipse.rdf4j.query.QueryInterruptedException;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;

/**
 * Maven-runnable CLI for query-plan snapshot generation and comparison.
 */
@Experimental
public final class QueryPlanSnapshotCli {

	private static final char ESCAPE = 0x1B;
	private static final List<String> YES_NO_CHOICES = List.of("yes", "no");
	private static final List<String> INTERACTIVE_ACTIONS = List.of(
			"run query",
			"compare existing runs",
			"list themes",
			"list queries",
			"help");
	private static final java.util.List<String> EXPLANATION_LEVEL_ORDER = java.util.List.of(
			"unoptimized",
			"optimized",
			"executed");
	private static final String MANUAL_QUERY_ID_ENTRY = "<manual entry>";
	private static final long EXECUTION_REPEAT_SOFT_LIMIT_NANOS = TimeUnit.SECONDS.toNanos(60);
	private static final int EXECUTION_REPEAT_MIN_RUNS = 2;
	private static final int EXECUTION_REPEAT_MAX_RUNS = 128;

	public static void main(String[] args) throws Exception {
		QueryPlanSnapshotCliOptions options = parseArgs(args);
		try (BufferedReader input = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8))) {
			new QueryPlanSnapshotCli(input, System.out, true).run(options);
		}
	}

	private final BufferedReader input;
	private final PrintStream output;
	private final JLineChoiceMenu jLineChoiceMenu;

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output) {
		this(input, output, false);
	}

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output, boolean useTerminalChoiceMenu) {
		this.input = Objects.requireNonNull(input, "input");
		this.output = Objects.requireNonNull(output, "output");
		this.jLineChoiceMenu = useTerminalChoiceMenu ? JLineChoiceMenu.tryCreate(output) : null;
	}

	void run(QueryPlanSnapshotCliOptions options) throws Exception {
		Objects.requireNonNull(options, "options");
		QueryPlanSnapshotCliOptions resolved = resolveInteractiveTopLevelAction(options);
		if (resolved.help) {
			QueryPlanSnapshotCliOptions.printUsage(output);
			return;
		}
		if (resolved.listThemes) {
			printThemes();
			return;
		}
		if (resolved.listQueriesTheme != null) {
			printThemeQueries(resolved.listQueriesTheme);
			return;
		}
		if (resolved.compareExisting) {
			runCompareExisting(resolved);
			return;
		}
		runCaptureMode(resolved);
	}

	private QueryPlanSnapshotCliOptions resolveInteractiveTopLevelAction(QueryPlanSnapshotCliOptions options)
			throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (resolved.argumentCount != 0 || resolved.noInteractive || resolved.help || resolved.listThemes
				|| resolved.listQueriesTheme != null || resolved.compareExisting) {
			return resolved;
		}

		String action = promptChoice("Action", INTERACTIVE_ACTIONS);
		if ("run query".equals(action)) {
			return resolved;
		}
		if ("compare existing runs".equals(action)) {
			resolved.compareExisting = true;
			return resolved;
		}
		if ("list themes".equals(action)) {
			resolved.listThemes = true;
			return resolved;
		}
		if ("list queries".equals(action)) {
			resolved.listQueriesTheme = promptTheme();
			return resolved;
		}

		resolved.help = true;
		return resolved;
	}

	private void runCaptureMode(QueryPlanSnapshotCliOptions options) throws Exception {
		QueryPlanSnapshotCliOptions resolved = resolveRunOptions(options);
		applySystemProperties(resolved.systemProperties);

		QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime = QueryPlanSnapshotStoreSupport
				.createStoreRuntime(resolved);
		try {
			if (resolved.runAllThemeQueries) {
				runAllThemeQueriesCapture(resolved, storeRuntime);
			} else {
				runSingleQueryCapture(resolved, storeRuntime);
			}
		} finally {
			storeRuntime.close();
		}
	}

	private void runSingleQueryCapture(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime) throws Exception {
		QueryPlanSnapshotStoreSupport.loadThemeData(storeRuntime.repository, options.theme);
		BenchmarkQuery benchmarkQuery = resolveBenchmarkQuery(options);
		String queryText = resolveQueryText(options, benchmarkQuery);
		String querySource = benchmarkQuery == null ? "direct" : "theme-index";
		String queryId = options.queryId != null ? options.queryId : defaultQueryId(options, benchmarkQuery);
		Path outputDirectory = options.outputDirectory != null
				? options.outputDirectory
				: defaultOutputDirectory(options.store);

		FeatureFlagCollector featureFlags = createFeatureFlagCollector(options, storeRuntime, querySource);
		QueryPlanCaptureContext context = createContext(options, benchmarkQuery, queryText, querySource, queryId,
				outputDirectory, featureFlags);
		QueryPlanCapture capture = new QueryPlanCapture();

		QueryPlanSnapshot currentSnapshot;
		Path snapshotPath = null;
		QueryExecutionVerification executionVerification;
		try (SailRepositoryConnection connection = storeRuntime.repository.getConnection()) {
			if (options.persist) {
				snapshotPath = capture.captureAndWrite(context,
						() -> prepareTupleQuery(connection, queryText, options.queryTimeoutSeconds));
				currentSnapshot = capture.readSnapshot(snapshotPath);
				output.println("Snapshot written: " + snapshotPath.toAbsolutePath());
			} else {
				currentSnapshot = capture.capture(context,
						() -> prepareTupleQuery(connection, queryText, options.queryTimeoutSeconds));
				output.println("Snapshot captured in-memory only (--persist=false).");
			}
			executionVerification = verifyRepeatedExecution(connection, queryText, options.queryTimeoutSeconds);
		}

		printResultsSection(options, queryId, queryText);
		printPrettyExplanations(currentSnapshot);
		printExecutionVerification(executionVerification);

		if (options.compareLatest) {
			compareWithLatest(outputDirectory, queryId, currentSnapshot, snapshotPath, capture, options.diffMode);
		}
	}

	private void runAllThemeQueriesCapture(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime) throws Exception {
		Path outputDirectory = options.outputDirectory != null
				? options.outputDirectory
				: defaultOutputDirectory(options.store);
		QueryPlanCapture capture = new QueryPlanCapture();
		Theme[] allThemes = Theme.values();
		int total = allThemes.length * ThemeQueryCatalog.QUERY_COUNT;
		int current = 0;

		for (Theme theme : allThemes) {
			QueryPlanSnapshotStoreSupport.loadThemeData(storeRuntime.repository, theme);
			for (int queryIndex = 0; queryIndex < ThemeQueryCatalog.QUERY_COUNT; queryIndex++) {
				current++;
				BenchmarkQuery benchmarkQuery = ThemeQueryCatalog.benchmarkQueryFor(theme, queryIndex);
				String queryText = benchmarkQuery.getQuery();
				QueryPlanSnapshotCliOptions perQueryOptions = options.copy();
				perQueryOptions.theme = theme;
				perQueryOptions.queryIndex = queryIndex;
				String querySource = "theme-index";
				String queryId = defaultQueryId(perQueryOptions, benchmarkQuery);

				FeatureFlagCollector featureFlags = createFeatureFlagCollector(perQueryOptions, storeRuntime,
						querySource);
				QueryPlanCaptureContext context = createContext(perQueryOptions, benchmarkQuery, queryText, querySource,
						queryId, outputDirectory, featureFlags);

				QueryPlanSnapshot currentSnapshot;
				Path snapshotPath = null;
				QueryExecutionVerification executionVerification;
				try (SailRepositoryConnection connection = storeRuntime.repository.getConnection()) {
					if (options.persist) {
						snapshotPath = capture.captureAndWrite(context,
								() -> prepareTupleQuery(connection, queryText, perQueryOptions.queryTimeoutSeconds));
						currentSnapshot = capture.readSnapshot(snapshotPath);
						output.println("Snapshot written: " + snapshotPath.toAbsolutePath());
					} else {
						currentSnapshot = capture.capture(context,
								() -> prepareTupleQuery(connection, queryText, perQueryOptions.queryTimeoutSeconds));
						output.println("Snapshot captured in-memory only (--persist=false).");
					}
					executionVerification = verifyRepeatedExecution(connection, queryText,
							perQueryOptions.queryTimeoutSeconds);
				}

				output.println();
				output.println("=== Batch Query " + current + "/" + total + " ===");
				output.println(
						"Theme=" + theme + ", QueryIndex=" + queryIndex + ", QueryName=" + benchmarkQuery.getName());
				printResultsSection(perQueryOptions, queryId, queryText);
				printPrettyExplanations(currentSnapshot);
				printExecutionVerification(executionVerification);

				if (options.compareLatest) {
					compareWithLatest(outputDirectory, queryId, currentSnapshot, snapshotPath, capture,
							options.diffMode);
				}
			}
		}

		output.println();
		output.println("Completed run-all mode: " + total + " queries across " + allThemes.length + " themes.");
	}

	private void runCompareExisting(QueryPlanSnapshotCliOptions options) throws Exception {
		QueryPlanSnapshotCliOptions resolved = resolveCompareOptions(options);
		Path outputDirectory = resolved.outputDirectory != null
				? resolved.outputDirectory
				: QueryPlanCapture.resolveOutputDirectory();
		QueryPlanCapture capture = new QueryPlanCapture();

		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator
				.loadRuns(outputDirectory, capture);
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> matchingRuns = QueryPlanSnapshotComparator
				.filterRuns(allRuns, normalizedOrNull(resolved.queryId),
						normalizedOrNull(resolved.comparisonFingerprint));

		if (matchingRuns.isEmpty()) {
			output.println("No matching runs found in " + outputDirectory.toAbsolutePath());
			return;
		}

		QueryPlanSnapshotComparator.printRunList(output, matchingRuns);
		if (resolved.compareIndices != null || resolved.noInteractive) {
			if (matchingRuns.size() < 2) {
				output.println("Need at least two runs to compare.");
				return;
			}
			QueryPlanSnapshotCliOptions.ComparisonPair pair = resolveComparisonPair(resolved, matchingRuns.size());
			QueryPlanSnapshotComparator.SnapshotRun left = QueryPlanSnapshotComparator.runAtIndex(matchingRuns,
					pair.leftIndex);
			QueryPlanSnapshotComparator.SnapshotRun right = QueryPlanSnapshotComparator.runAtIndex(matchingRuns,
					pair.rightIndex);
			QueryPlanSnapshotComparator.printComparison(output, left, right, resolved.diffMode);
			return;
		}

		runInteractiveRunBrowser(matchingRuns, resolved.diffMode);
	}

	private void runInteractiveRunBrowser(List<QueryPlanSnapshotComparator.SnapshotRun> runs,
			QueryPlanSnapshotCliOptions.DiffMode diffMode) throws IOException {
		while (true) {
			String action = promptChoice("Browse runs", List.of("view run", "compare runs", "quit"));
			if ("view run".equals(action)) {
				int selectedIndex = promptRunSelection("Select run to view", runs);
				QueryPlanSnapshotComparator.SnapshotRun selectedRun = runs.get(selectedIndex);
				QueryPlanSnapshotComparator.printRunDetails(output, selectedRun);
				continue;
			}
			if ("compare runs".equals(action)) {
				if (runs.size() < 2) {
					output.println("Need at least two runs to compare.");
					continue;
				}

				int leftIndex = promptRunSelection("Select left run", runs);
				int rightIndex = promptRunSelection("Select right run", runs);
				if (leftIndex == rightIndex) {
					String compareSame = promptChoice("Same run selected for both sides. Continue anyway?",
							YES_NO_CHOICES);
					if ("no".equals(compareSame)) {
						continue;
					}
				}

				QueryPlanSnapshotComparator.printComparison(output, runs.get(leftIndex), runs.get(rightIndex),
						diffMode);
				return;
			}
			output.println("Browse ended.");
			return;
		}
	}

	private void compareWithLatest(Path outputDirectory, String queryId, QueryPlanSnapshot currentSnapshot,
			Path currentSnapshotPath, QueryPlanCapture capture, QueryPlanSnapshotCliOptions.DiffMode diffMode)
			throws IOException {
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator
				.loadRuns(outputDirectory, capture);
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> matchingRuns = QueryPlanSnapshotComparator
				.filterRuns(allRuns, null, currentSnapshot.getUnoptimizedFingerprint());
		if (matchingRuns.isEmpty()) {
			matchingRuns = QueryPlanSnapshotComparator.filterRuns(allRuns, normalizedOrNull(queryId), null);
		}
		QueryPlanSnapshotComparator.SnapshotRun previousRun = QueryPlanSnapshotComparator
				.latestExcludingPath(matchingRuns, currentSnapshotPath);
		if (previousRun == null) {
			output.println("No previous run found for compare-latest.");
			return;
		}

		output.println("Comparing current run against latest previous run:");
		QueryPlanSnapshotComparator.printComparison(output, previousRun,
				QueryPlanSnapshotComparator.inMemoryRun(currentSnapshot), diffMode);
	}

	private QueryPlanSnapshotCliOptions resolveRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (requiresInteractiveInput(resolved)) {
			output.println("Entering interactive mode.");
			fillMissingRunOptions(resolved);
			if (resolved.argumentCount == 0) {
				promptAllRunOptions(resolved);
			}
			promptForAssignments("System properties key=value (blank line ends section):",
					resolved.systemProperties);
			promptForAssignments("Metadata key=value (blank line ends section):", resolved.metadata);
		}
		validateRunOptions(resolved);
		return resolved;
	}

	private QueryPlanSnapshotCliOptions resolveCompareOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (requiresInteractiveInput(resolved)) {
			output.println("Entering interactive compare mode.");
			fillMissingCompareOptions(resolved);
		}
		if (!resolved.hasComparisonFilter()) {
			throw new IllegalArgumentException(
					"Compare mode requires --query-id or --fingerprint (or interactive input).");
		}
		return resolved;
	}

	private static void validateRunOptions(QueryPlanSnapshotCliOptions options) {
		if (options.store == null) {
			throw new IllegalArgumentException(
					"Missing required run options. Required: --store and query selection.");
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (options.theme == null || !options.hasQueryInput()) {
			throw new IllegalArgumentException(
					"Missing required run options. Required: --store, --theme, and query input.");
		}
	}

	private void fillMissingRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		if (options.store == null) {
			options.store = promptStore();
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (!options.hasQueryInput()) {
			promptForQueryInput(options);
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (options.theme == null) {
			options.theme = promptTheme();
		}
	}

	private void fillMissingCompareOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		boolean outputDirectoryPrompted = false;
		if (!options.hasComparisonFilter()) {
			String mode = promptChoice("Compare filter", List.of("query-id", "fingerprint"));
			if ("query-id".equals(mode)) {
				if (options.outputDirectory == null) {
					options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
					outputDirectoryPrompted = true;
				}
				Path outputDirectory = options.outputDirectory != null
						? options.outputDirectory
						: QueryPlanCapture.resolveOutputDirectory();
				List<String> availableQueryIds = loadAvailableQueryIds(outputDirectory);
				if (availableQueryIds.isEmpty()) {
					options.queryId = prompt("query-id");
				} else {
					List<String> choices = new ArrayList<>(availableQueryIds);
					choices.add(MANUAL_QUERY_ID_ENTRY);
					String selected = promptChoice("Query id", choices);
					options.queryId = MANUAL_QUERY_ID_ENTRY.equals(selected) ? prompt("query-id") : selected;
				}
			} else {
				options.comparisonFingerprint = prompt("fingerprint");
			}
		}
		if (options.outputDirectory == null && !outputDirectoryPrompted) {
			options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
		}
		options.diffMode = promptDiffMode(options.diffMode);
		if (options.compareIndices == null) {
			String mode = promptChoice("Compare selection mode", List.of("browse runs", "enter indices"));
			if ("enter indices".equals(mode)) {
				options.compareIndices = promptComparisonPair();
			}
		}
	}

	private List<String> loadAvailableQueryIds(Path outputDirectory) throws IOException {
		QueryPlanCapture capture = new QueryPlanCapture();
		List<QueryPlanSnapshotComparator.SnapshotRun> runs = QueryPlanSnapshotComparator.loadRuns(outputDirectory,
				capture);
		Map<String, Integer> queryRunCounts = new java.util.LinkedHashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : runs) {
			String queryId = normalizedOrNull(run.snapshot().getQueryId());
			if (queryId == null) {
				continue;
			}
			queryRunCounts.merge(queryId, 1, Integer::sum);
		}
		if (queryRunCounts.isEmpty()) {
			return List.of();
		}

		output.println("Available queries:");
		queryRunCounts.forEach((queryId, count) -> output
				.println("  - " + queryId + " (" + count + " run" + (count == 1 ? "" : "s") + ")"));
		return new ArrayList<>(queryRunCounts.keySet());
	}

	private QueryPlanSnapshotCliOptions.ComparisonPair resolveComparisonPair(QueryPlanSnapshotCliOptions options,
			int runCount) throws IOException {
		if (options.compareIndices != null) {
			return options.compareIndices;
		}
		if (options.noInteractive) {
			return new QueryPlanSnapshotCliOptions.ComparisonPair(0, 1);
		}

		while (true) {
			String raw = prompt("Compare indices i,j [default 0,1]");
			if (raw.isBlank()) {
				return new QueryPlanSnapshotCliOptions.ComparisonPair(0, 1);
			}
			try {
				QueryPlanSnapshotCliOptions.ComparisonPair parsed = QueryPlanSnapshotCliOptions
						.parseComparisonPairValue(raw);
				if (parsed.leftIndex >= runCount || parsed.rightIndex >= runCount) {
					throw new IllegalArgumentException("Index out of range. Available 0-" + (runCount - 1));
				}
				return parsed;
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private void promptForQueryInput(QueryPlanSnapshotCliOptions options) throws IOException {
		String mode = promptChoice("Query source [themed|manual|file|all-themed]",
				List.of("themed", "manual", "file", "all-themed"));
		if ("all-themed".equals(mode)) {
			options.runAllThemeQueries = true;
			options.theme = null;
			options.queryIndex = null;
			options.query = null;
			options.queryFile = null;
			return;
		}
		options.runAllThemeQueries = false;
		if (options.theme == null) {
			options.theme = promptTheme();
		}
		if ("themed".equals(mode)) {
			printThemeQueries(options.theme);
			options.queryIndex = promptQueryIndex();
			options.query = null;
			options.queryFile = null;
			return;
		}
		if ("file".equals(mode)) {
			options.queryFile = promptQueryFile();
			options.query = null;
			options.queryIndex = null;
			return;
		}
		options.query = promptQueryText();
		options.queryFile = null;
		options.queryIndex = null;
	}

	private QueryPlanSnapshotCliOptions.StoreType promptStore() throws IOException {
		String value = promptChoice("Store [memory|lmdb]", List.of("memory", "lmdb"));
		return QueryPlanSnapshotCliOptions.parseStoreValue(value);
	}

	private Theme promptTheme() throws IOException {
		List<String> themes = java.util.Arrays.asList(QueryPlanSnapshotCliOptions.themeNames());
		String selectedTheme = promptChoice("Theme", themes);
		return QueryPlanSnapshotCliOptions.parseThemeValue(selectedTheme);
	}

	private int promptQueryIndex() throws IOException {
		while (true) {
			String raw = prompt("Theme query index [0-" + (ThemeQueryCatalog.QUERY_COUNT - 1) + "]");
			try {
				return QueryPlanSnapshotCliOptions.parseQueryIndexValue(raw);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private Path promptQueryFile() throws IOException {
		while (true) {
			String rawPath = prompt("Query file path");
			if (rawPath.isBlank()) {
				output.println("Query file path cannot be blank.");
				continue;
			}
			Path path = Path.of(rawPath.trim());
			if (!Files.exists(path)) {
				output.println("Query file not found: " + path.toAbsolutePath());
				continue;
			}
			return path;
		}
	}

	private String promptQueryText() throws IOException {
		output.println("Paste SPARQL query. End with line '" + QueryPlanSnapshotCliOptions.QUERY_END_SENTINEL + "'.");
		StringBuilder builder = new StringBuilder();
		while (true) {
			String line = readLine();
			if (line == null) {
				break;
			}
			if (QueryPlanSnapshotCliOptions.QUERY_END_SENTINEL.equals(line.trim())) {
				break;
			}
			builder.append(line).append('\n');
		}
		String query = builder.toString().trim();
		if (query.isBlank()) {
			throw new IllegalArgumentException("Query input was empty.");
		}
		return query;
	}

	private void promptAllRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		options.persist = promptBoolean("Persist snapshot", options.persist);
		options.compareLatest = promptBoolean("Compare with latest previous run", options.compareLatest);
		if (options.compareLatest) {
			options.diffMode = promptDiffMode(options.diffMode);
		}
		options.queryId = promptOptionalValue("Query id (blank keeps default/auto)", options.queryId);
		options.queryTimeoutSeconds = promptOptionalNonNegativeInteger(
				"Query timeout seconds (blank keeps current, 0 disables timeout)",
				options.queryTimeoutSeconds);
		if (options.outputDirectory == null) {
			options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
		}
		if (options.store == QueryPlanSnapshotCliOptions.StoreType.LMDB && options.lmdbDataDirectory == null) {
			options.lmdbDataDirectory = promptOptionalPath("LMDB data directory (blank uses temp)");
		}
	}

	private boolean promptBoolean(String message, boolean currentValue) throws IOException {
		List<String> choices = currentValue ? YES_NO_CHOICES : List.of("no", "yes");
		return "yes".equals(promptChoice(message, choices));
	}

	private QueryPlanSnapshotCliOptions.DiffMode promptDiffMode(QueryPlanSnapshotCliOptions.DiffMode currentValue)
			throws IOException {
		List<String> choices = currentValue == QueryPlanSnapshotCliOptions.DiffMode.STRUCTURE
				? List.of("structure", "structure+estimates")
				: List.of("structure+estimates", "structure");
		String selected = promptChoice("Diff mode", choices);
		return QueryPlanSnapshotCliOptions.parseDiffModeValue(selected);
	}

	private QueryPlanSnapshotCliOptions.ComparisonPair promptComparisonPair() throws IOException {
		while (true) {
			String raw = prompt("Compare indices i,j");
			try {
				return QueryPlanSnapshotCliOptions.parseComparisonPairValue(raw);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private String promptOptionalValue(String message, String currentValue) throws IOException {
		String suffix = currentValue == null || currentValue.isBlank()
				? ""
				: " [current=" + currentValue + "]";
		String raw = prompt(message + suffix);
		if (raw.isBlank()) {
			return currentValue;
		}
		return raw;
	}

	private Path promptOptionalPath(String message) throws IOException {
		String raw = prompt(message);
		if (raw.isBlank()) {
			return null;
		}
		return Path.of(raw.trim());
	}

	private Integer promptOptionalNonNegativeInteger(String message, Integer currentValue) throws IOException {
		while (true) {
			String raw = prompt(message);
			if (raw.isBlank()) {
				return currentValue;
			}
			try {
				return QueryPlanSnapshotCliOptions.parseNonNegativeInteger(raw, message);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private void promptForAssignments(String heading, Map<String, String> target) throws IOException {
		output.println(heading);
		while (true) {
			String line = prompt("  key=value");
			if (line.isBlank()) {
				return;
			}
			try {
				QueryPlanSnapshotCliOptions.Assignment assignment = QueryPlanSnapshotCliOptions.parseAssignment(line,
						heading);
				target.put(assignment.getKey(), assignment.getValue());
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private String prompt(String message) throws IOException {
		return promptRaw(message).trim();
	}

	private String promptRaw(String message) throws IOException {
		output.print(message + ": ");
		output.flush();
		String line = readLine();
		if (line == null) {
			throw new IllegalStateException(
					"No interactive input available. Pass --no-interactive or complete args.");
		}
		return line;
	}

	private String readLine() throws IOException {
		return input.readLine();
	}

	private String promptChoice(String message, List<String> options) throws IOException {
		int selectedIndex = promptChoiceIndex(message, options);
		return options.get(selectedIndex);
	}

	private int promptChoiceIndex(String message, List<String> options) throws IOException {
		Objects.requireNonNull(options, "options");
		if (options.isEmpty()) {
			throw new IllegalArgumentException("No choices available for " + message);
		}
		if (jLineChoiceMenu != null) {
			Integer selected = jLineChoiceMenu.promptChoiceIndex(message, options);
			if (selected != null) {
				output.println(message + ": " + options.get(selected));
				return selected;
			}
		}
		return promptChoiceIndexFallback(message, options);
	}

	private int promptChoiceIndexFallback(String message, List<String> options) throws IOException {

		output.println(message + ":");
		for (int i = 0; i < options.size(); i++) {
			output.println("  [" + (i + 1) + "] " + options.get(i));
		}
		output.println("Type number/value. Enter chooses [1]. (Arrow keys unavailable in fallback mode.)");

		while (true) {
			String rawValue = promptRaw("Select");
			if (rawValue.isBlank()) {
				return 0;
			}

			int arrowSelected = resolveArrowSelection(rawValue, options.size());
			if (arrowSelected >= 0) {
				return arrowSelected;
			}

			String candidate = rawValue.trim();
			try {
				int numeric = Integer.parseInt(candidate);
				if (numeric >= 1 && numeric <= options.size()) {
					return numeric - 1;
				}
			} catch (NumberFormatException ignored) {
				// fall through to textual matching
			}

			for (int i = 0; i < options.size(); i++) {
				if (options.get(i).equalsIgnoreCase(candidate)) {
					return i;
				}
			}

			output.println("Invalid selection '" + candidate + "'. Choose one of the listed options.");
		}
	}

	private static int resolveArrowSelection(String rawValue, int optionCount) {
		int currentIndex = 0;
		boolean moved = false;
		for (int i = 0; i < rawValue.length(); i++) {
			char c = rawValue.charAt(i);
			if (c != ESCAPE || i + 2 >= rawValue.length() || rawValue.charAt(i + 1) != '[') {
				continue;
			}

			char code = rawValue.charAt(i + 2);
			if (code == 'A' || code == 'D') {
				currentIndex = (currentIndex - 1 + optionCount) % optionCount;
				moved = true;
				i += 2;
				continue;
			}
			if (code == 'B' || code == 'C') {
				currentIndex = (currentIndex + 1) % optionCount;
				moved = true;
				i += 2;
			}
		}

		return moved ? currentIndex : -1;
	}

	private int promptRunSelection(String message, List<QueryPlanSnapshotComparator.SnapshotRun> runs)
			throws IOException {
		List<String> choices = new ArrayList<>(runs.size());
		for (int i = 0; i < runs.size(); i++) {
			QueryPlanSnapshotComparator.SnapshotRun run = runs.get(i);
			QueryPlanSnapshot snapshot = run.snapshot();
			String capturedAt = snapshot.getCapturedAt();
			String queryId = snapshot.getQueryId();
			String fingerprint = snapshot.getUnoptimizedFingerprint();
			choices.add(capturedAt + " queryId=" + queryId + " fingerprint=" + fingerprint);
		}
		return promptChoiceIndex(message, choices);
	}

	private void printThemes() {
		output.println("Themes:");
		for (String themeName : QueryPlanSnapshotCliOptions.themeNames()) {
			output.println("  - " + themeName);
		}
	}

	private void printThemeQueries(Theme theme) {
		output.println("Theme queries for " + theme + ":");
		for (int i = 0; i < ThemeQueryCatalog.QUERY_COUNT; i++) {
			BenchmarkQuery query = ThemeQueryCatalog.benchmarkQueryFor(theme, i);
			output.println("  " + i + ": " + query.getName());
		}
	}

	private static QueryPlanCaptureContext createContext(QueryPlanSnapshotCliOptions options,
			BenchmarkQuery benchmarkQuery,
			String queryText, String querySource, String queryId, Path outputDirectory,
			FeatureFlagCollector featureFlags) {
		QueryPlanCaptureContext.Builder contextBuilder = QueryPlanCaptureContext.builder()
				.outputDirectory(outputDirectory)
				.queryId(queryId)
				.queryString(queryText)
				.benchmark("QueryPlanSnapshotCli")
				.addMetadata("store", options.store.id)
				.addMetadata("theme", options.theme.name())
				.addMetadata("querySource", querySource)
				.addMetadata(options.metadata)
				.addMetadata(QueryPlanCapture.metadataFromSystemProperties())
				.featureFlagCollector(featureFlags)
				.tupleExprRenderer(QueryPlanSnapshotCli::renderTupleExprWithIr);
		if (options.queryTimeoutSeconds != null) {
			contextBuilder.addMetadata("queryTimeoutSeconds", options.queryTimeoutSeconds.toString());
		}

		if (options.queryIndex != null && benchmarkQuery != null) {
			contextBuilder.addMetadata("queryIndex", Integer.toString(options.queryIndex))
					.addMetadata("queryName", benchmarkQuery.getName())
					.addMetadata("expectedCount", Long.toString(benchmarkQuery.getExpectedCount()));
		}

		return contextBuilder.build();
	}

	private static FeatureFlagCollector createFeatureFlagCollector(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime, String querySource) {
		FeatureFlagCollector featureFlags = new FeatureFlagCollector()
				.addValue("cli.store", options.store.id)
				.addValue("cli.theme", options.theme.name())
				.addValue("cli.querySource", querySource)
				.addValue("cli.persist", Boolean.toString(options.persist))
				.addValue("cli.queryTimeoutSeconds", formatQueryTimeoutSeconds(options.queryTimeoutSeconds));
		if (options.queryIndex != null) {
			featureFlags.addValue("cli.queryIndex", options.queryIndex.toString());
		}
		options.systemProperties.forEach((name, value) -> featureFlags.addValue("systemProperty." + name, value));

		if (storeRuntime.memoryStore != null) {
			featureFlags.addReflectiveGetter("memoryStore.persist", storeRuntime.memoryStore, "getPersist")
					.addReflectiveGetter("memoryStore.syncDelay", storeRuntime.memoryStore, "getSyncDelay")
					.addReflectiveGetter("memoryStore.iterationCacheSyncThreshold", storeRuntime.memoryStore,
							"getIterationCacheSyncThreshold");
		}

		if (storeRuntime.lmdbStore != null) {
			featureFlags.addReflectiveGetter("lmdbStore.writable", storeRuntime.lmdbStore, "isWritable")
					.addReflectiveGetter("lmdbConfig.tripleIndexes", storeRuntime.lmdbStoreConfig, "getTripleIndexes")
					.addReflectiveGetter("lmdbConfig.forceSync", storeRuntime.lmdbStoreConfig, "getForceSync")
					.addReflectiveField("lmdbConfig.autoGrow", storeRuntime.lmdbStoreConfig, "autoGrow")
					.addReflectiveGetter("lmdbConfig.valueDbSize", storeRuntime.lmdbStoreConfig, "getValueDBSize")
					.addReflectiveGetter("lmdbConfig.tripleDbSize", storeRuntime.lmdbStoreConfig, "getTripleDBSize");
		}

		QueryPlanCapture.registerConfiguredFeatureFlags(featureFlags);
		return featureFlags;
	}

	private static String defaultQueryId(QueryPlanSnapshotCliOptions options, BenchmarkQuery benchmarkQuery) {
		if (options.queryIndex != null && benchmarkQuery != null) {
			return options.store.id + "-" + options.theme.name().toLowerCase(java.util.Locale.ROOT) + "-q"
					+ options.queryIndex;
		}
		return options.store.id + "-" + options.theme.name().toLowerCase(java.util.Locale.ROOT) + "-manual";
	}

	private static Path defaultOutputDirectory(QueryPlanSnapshotCliOptions.StoreType storeType) {
		return QueryPlanCapture.resolveOutputDirectory().resolve("cli").resolve(storeType.id);
	}

	private static BenchmarkQuery resolveBenchmarkQuery(QueryPlanSnapshotCliOptions options) {
		if (options.queryIndex == null) {
			return null;
		}
		return ThemeQueryCatalog.benchmarkQueryFor(options.theme, options.queryIndex);
	}

	private static String resolveQueryText(QueryPlanSnapshotCliOptions options, BenchmarkQuery benchmarkQuery)
			throws IOException {
		if (benchmarkQuery != null) {
			return benchmarkQuery.getQuery();
		}
		if (options.query != null && !options.query.isBlank()) {
			return options.query;
		}
		if (options.queryFile != null) {
			String loaded = Files.readString(options.queryFile, StandardCharsets.UTF_8).trim();
			if (!loaded.isBlank()) {
				return loaded;
			}
		}
		throw new IllegalArgumentException("No query text resolved. Provide --query, --query-file, or --query-index.");
	}

	private static void applySystemProperties(Map<String, String> systemProperties) {
		systemProperties.forEach(System::setProperty);
	}

	private static String renderTupleExprWithIr(org.eclipse.rdf4j.query.algebra.TupleExpr tupleExpr) {
		TupleExprIRRenderer.Config config = new TupleExprIRRenderer.Config();
		config.verifyRoundTrip = false;
		return new TupleExprIRRenderer(config).render(tupleExpr);
	}

	private static String normalizedOrNull(String value) {
		if (value == null) {
			return null;
		}
		String normalized = value.trim();
		return normalized.isEmpty() ? null : normalized;
	}

	private static String formatQueryTimeoutSeconds(Integer queryTimeoutSeconds) {
		if (queryTimeoutSeconds == null || queryTimeoutSeconds == 0) {
			return "<none>";
		}
		return queryTimeoutSeconds.toString();
	}

	private static TupleQuery prepareTupleQuery(SailRepositoryConnection connection, String queryText,
			Integer queryTimeoutSeconds) {
		TupleQuery tupleQuery = connection.prepareTupleQuery(queryText);
		if (queryTimeoutSeconds != null && queryTimeoutSeconds > 0) {
			tupleQuery.setMaxExecutionTime(queryTimeoutSeconds);
		}
		return tupleQuery;
	}

	private void printPrettyExplanations(QueryPlanSnapshot snapshot) {
		Map<String, QueryPlanExplanation> explanations = snapshot.getExplanations();
		if (explanations == null || explanations.isEmpty()) {
			output.println("No query explanations captured.");
			return;
		}

		LinkedHashSet<String> orderedLevels = new LinkedHashSet<>(EXPLANATION_LEVEL_ORDER);
		orderedLevels.addAll(explanations.keySet());
		for (String levelKey : orderedLevels) {
			QueryPlanExplanation explanation = explanations.get(levelKey);
			if (explanation == null) {
				continue;
			}
			printExplanation(levelKey, explanation);
		}
	}

	private void printResultsSection(QueryPlanSnapshotCliOptions options, String queryId, String queryText) {
		output.println("=== Results ===");
		output.println("Original query:");
		output.println(queryText.trim());
		output.println("Store=" + options.store.id + ", Theme=" + options.theme + ", QueryId=" + queryId
				+ ", QueryTimeoutSeconds=" + formatQueryTimeoutSeconds(options.queryTimeoutSeconds));
	}

	private void printExplanation(String levelKey, QueryPlanExplanation explanation) {
		String levelName = explanation.getLevel();
		if (levelName == null || levelName.isBlank()) {
			levelName = levelKey;
		}
		String label = levelName.substring(0, 1).toUpperCase(Locale.ROOT)
				+ levelName.substring(1).toLowerCase(Locale.ROOT);

		output.println();
		output.println("=== " + label + " Explanation ===");
		String explanationText = explanation.getExplanationText();
		if (explanationText == null || explanationText.isBlank()) {
			output.println("(no explanation text)");
		} else {
			output.println(explanationText.trim());
		}

		String renderedQuery = explanation.getIrRenderedQuery();
		if (renderedQuery != null && !renderedQuery.isBlank()) {
			output.println("--- IR Rendered Query ---");
			output.println(renderedQuery.trim());
		}
	}

	private QueryExecutionVerification verifyRepeatedExecution(SailRepositoryConnection connection, String queryText,
			Integer queryTimeoutSeconds) {
		long elapsedNanos = 0;
		long stableResultCount = Long.MIN_VALUE;
		int runs = 0;
		boolean softLimitReached = false;

		while (runs < EXECUTION_REPEAT_MAX_RUNS) {
			if (runs >= EXECUTION_REPEAT_MIN_RUNS) {
				long averageNanos = Math.max(1L, elapsedNanos / runs);
				if (elapsedNanos + averageNanos > EXECUTION_REPEAT_SOFT_LIMIT_NANOS) {
					softLimitReached = true;
					break;
				}
			} else if (elapsedNanos >= EXECUTION_REPEAT_SOFT_LIMIT_NANOS) {
				softLimitReached = true;
				break;
			}

			long startedAt = System.nanoTime();
			long currentResultCount;
			try {
				currentResultCount = prepareTupleQuery(connection, queryText, queryTimeoutSeconds)
						.evaluate()
						.stream()
						.count();
			}catch (QueryInterruptedException interrupted) {
				softLimitReached = true;
				break;
			}

			long runNanos = Math.max(1L, System.nanoTime() - startedAt);
			elapsedNanos += runNanos;
			runs++;

			if (stableResultCount == Long.MIN_VALUE) {
				stableResultCount = currentResultCount;
			} else if (stableResultCount != currentResultCount) {
				throw new IllegalStateException("Result count changed between repeated runs: expected "
						+ stableResultCount + " but got " + currentResultCount + " on run " + runs);
			}
		}

		boolean maxRunsReached = runs >= EXECUTION_REPEAT_MAX_RUNS;
		if (runs == 0) {
			return new QueryExecutionVerification(0, 0, 0, softLimitReached, maxRunsReached);
		}

		return new QueryExecutionVerification(runs, elapsedNanos, stableResultCount, softLimitReached,
				maxRunsReached);
	}

	private void printExecutionVerification(QueryExecutionVerification executionVerification) {
		output.println();
		output.println("=== Execution Verification ===");
		if (executionVerification.runs == 0) {
			output.println("No repeated runs executed.");
			return;
		}

		long totalMillis = TimeUnit.NANOSECONDS.toMillis(executionVerification.elapsedNanos);
		long averageMillis = TimeUnit.NANOSECONDS.toMillis(
				executionVerification.elapsedNanos / executionVerification.runs);
		output.println("runs=" + executionVerification.runs
				+ ", totalMillis=" + totalMillis
				+ ", averageMillis=" + averageMillis
				+ ", resultCount=" + executionVerification.resultCount
				+ ", softLimitMillis=" + TimeUnit.NANOSECONDS.toMillis(EXECUTION_REPEAT_SOFT_LIMIT_NANOS)
				+ ", softLimitReached=" + executionVerification.softLimitReached
				+ ", maxRunsReached=" + executionVerification.maxRunsReached);
	}

	private static final class QueryExecutionVerification {
		private final int runs;
		private final long elapsedNanos;
		private final long resultCount;
		private final boolean softLimitReached;
		private final boolean maxRunsReached;

		private QueryExecutionVerification(int runs, long elapsedNanos, long resultCount, boolean softLimitReached,
				boolean maxRunsReached) {
			this.runs = runs;
			this.elapsedNanos = elapsedNanos;
			this.resultCount = resultCount;
			this.softLimitReached = softLimitReached;
			this.maxRunsReached = maxRunsReached;
		}
	}

	static QueryPlanSnapshotCliOptions parseArgs(String[] args) {
		return QueryPlanSnapshotCliOptions.parseArgs(args);
	}

	static boolean requiresInteractiveInput(QueryPlanSnapshotCliOptions options) {
		return QueryPlanSnapshotCliOptions.requiresInteractiveInput(options);
	}
}
