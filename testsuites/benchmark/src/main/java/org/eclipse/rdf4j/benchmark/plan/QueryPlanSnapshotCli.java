/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.eclipse.rdf4j.benchmark.common.BenchmarkQuery;
import org.eclipse.rdf4j.benchmark.common.ThemeQueryCatalog;
import org.eclipse.rdf4j.benchmark.common.plan.FeatureFlagCollector;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCapture;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCaptureContext;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;
import org.eclipse.rdf4j.benchmark.rio.util.ThemeDataSetGenerator.Theme;
import org.eclipse.rdf4j.common.annotation.Experimental;
import org.eclipse.rdf4j.query.QueryInterruptedException;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.query.explanation.Explanation;
import org.eclipse.rdf4j.queryrender.sparql.TupleExprIRRenderer;
import org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;

/**
 * Maven-runnable CLI for query-plan snapshot generation and comparison.
 */
@Experimental
public final class QueryPlanSnapshotCli {

	private static final char ESCAPE = 0x1B;
	private static final List<String> YES_NO_CHOICES = List.of("yes", "no");
	private static final List<String> INTERACTIVE_ACTIONS = List.of(
			"run query",
			"compare existing runs",
			"rename runs by commit",
			"list themes",
			"list queries",
			"help");
	private static final String EXPLANATION_LEVEL_TELEMETRY = "telemetry";
	private static final java.util.List<String> EXPLANATION_LEVEL_ORDER = java.util.List.of(
			"unoptimized",
			"optimized",
			EXPLANATION_LEVEL_TELEMETRY);
	private static final String MANUAL_QUERY_ID_ENTRY = "<manual entry>";
	private static final String MANUAL_RUN_NAME_ENTRY = "<manual entry>";
	private static final String UNKNOWN_VALUE = "<unknown>";
	private static final ZoneId LOCAL_ZONE = ZoneId.systemDefault();
	private static final DateTimeFormatter LOCAL_TIME_FORMATTER = DateTimeFormatter
			.ofPattern("yyyy-MM-dd HH:mm:ss z");
	private static final long DEFAULT_EXECUTION_REPEAT_SOFT_LIMIT_NANOS = TimeUnit.SECONDS.toNanos(30);
	private static final int DEFAULT_EXECUTION_REPEAT_MIN_RUNS = 2;
	private static final int DEFAULT_EXECUTION_REPEAT_MAX_RUNS = 128;
	private static final long DEFAULT_BATCH_ETA_UPDATE_INTERVAL_NANOS = TimeUnit.SECONDS.toNanos(10);
	private static final List<String> PLAN_INPUT_FEATURE_FLAG_PREFIXES = List.of(
			"cli.",
			"systemProperty.",
			"memoryStore.",
			"lmdbStore.",
			"lmdbConfig.",
			"lmdbData.");

	public static void main(String[] args) throws Exception {
		QueryPlanSnapshotCliOptions options = parseArgs(args);
		try (BufferedReader input = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8))) {
			createCli(input, System.out, true, options).run(options);
		}
	}

	private static QueryPlanSnapshotCli createCli(BufferedReader input, PrintStream output,
			boolean useTerminalChoiceMenu,
			QueryPlanSnapshotCliOptions options) {
		Objects.requireNonNull(options, "options");
		return new QueryPlanSnapshotCli(input, output, useTerminalChoiceMenu,
				resolveExecutionRepeatMinRuns(options),
				resolveExecutionRepeatMaxRuns(options),
				resolveExecutionRepeatSoftLimitNanos(options),
				DEFAULT_BATCH_ETA_UPDATE_INTERVAL_NANOS);
	}

	private final BufferedReader input;
	private final PrintStream output;
	private final JLineChoiceMenu jLineChoiceMenu;
	private final int executionRepeatMinRuns;
	private final int executionRepeatMaxRuns;
	private final long executionRepeatSoftLimitNanos;
	private final long batchEtaUpdateIntervalNanos;

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output) {
		this(input, output, false);
	}

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output, boolean useTerminalChoiceMenu) {
		this(input, output, useTerminalChoiceMenu, DEFAULT_EXECUTION_REPEAT_MIN_RUNS,
				DEFAULT_EXECUTION_REPEAT_MAX_RUNS, DEFAULT_EXECUTION_REPEAT_SOFT_LIMIT_NANOS,
				DEFAULT_BATCH_ETA_UPDATE_INTERVAL_NANOS);
	}

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output, boolean useTerminalChoiceMenu,
			int executionRepeatMinRuns, int executionRepeatMaxRuns, long executionRepeatSoftLimitNanos) {
		this(input, output, useTerminalChoiceMenu, executionRepeatMinRuns, executionRepeatMaxRuns,
				executionRepeatSoftLimitNanos, DEFAULT_BATCH_ETA_UPDATE_INTERVAL_NANOS);
	}

	QueryPlanSnapshotCli(BufferedReader input, PrintStream output, boolean useTerminalChoiceMenu,
			int executionRepeatMinRuns, int executionRepeatMaxRuns, long executionRepeatSoftLimitNanos,
			long batchEtaUpdateIntervalNanos) {
		this.input = Objects.requireNonNull(input, "input");
		this.output = Objects.requireNonNull(output, "output");
		this.jLineChoiceMenu = useTerminalChoiceMenu ? JLineChoiceMenu.tryCreate(output) : null;
		this.executionRepeatMinRuns = validateExecutionRepeatMinRuns(executionRepeatMinRuns);
		this.executionRepeatMaxRuns = validateExecutionRepeatMaxRuns(executionRepeatMaxRuns);
		if (this.executionRepeatMinRuns > this.executionRepeatMaxRuns) {
			throw new IllegalArgumentException("executionRepeatMinRuns must be <= executionRepeatMaxRuns.");
		}
		this.executionRepeatSoftLimitNanos = validateExecutionRepeatSoftLimitNanos(executionRepeatSoftLimitNanos);
		this.batchEtaUpdateIntervalNanos = validateBatchEtaUpdateIntervalNanos(batchEtaUpdateIntervalNanos);
	}

	void run(QueryPlanSnapshotCliOptions options) throws Exception {
		try {
			Objects.requireNonNull(options, "options");
			QueryPlanSnapshotCliOptions resolved = resolveInteractiveTopLevelAction(options);
			if (resolved.help) {
				QueryPlanSnapshotCliOptions.printUsage(output);
				return;
			}
			if (resolved.listThemes) {
				printThemes();
				return;
			}
			if (resolved.listQueriesTheme != null) {
				printThemeQueries(resolved.listQueriesTheme);
				return;
			}
			if (resolved.renameRunsByCommit) {
				runRenameRunsByCommit(resolved);
				return;
			}
			if (resolved.compareExisting) {
				runCompareExisting(resolved);
				return;
			}
			runCaptureMode(resolved);
		} finally {
			closeChoiceMenu();
		}
	}

	private void closeChoiceMenu() {
		if (jLineChoiceMenu == null) {
			return;
		}
		try {
			jLineChoiceMenu.close();
		} catch (IOException ignored) {
			// No recovery required during CLI shutdown.
		}
	}

	private QueryPlanSnapshotCliOptions resolveInteractiveTopLevelAction(QueryPlanSnapshotCliOptions options)
			throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (resolved.argumentCount != 0 || resolved.noInteractive || resolved.help || resolved.listThemes
				|| resolved.listQueriesTheme != null || resolved.compareExisting || resolved.renameRunsByCommit) {
			return resolved;
		}

		String action = promptChoice("Action", INTERACTIVE_ACTIONS);
		if ("run query".equals(action)) {
			return resolved;
		}
		if ("compare existing runs".equals(action)) {
			resolved.compareExisting = true;
			return resolved;
		}
		if ("rename runs by commit".equals(action)) {
			resolved.renameRunsByCommit = true;
			return resolved;
		}
		if ("list themes".equals(action)) {
			resolved.listThemes = true;
			return resolved;
		}
		if ("list queries".equals(action)) {
			resolved.listQueriesTheme = promptTheme();
			return resolved;
		}

		resolved.help = true;
		return resolved;
	}

	private void runCaptureMode(QueryPlanSnapshotCliOptions options) throws Exception {
		QueryPlanSnapshotCliOptions resolved = resolveRunOptions(options);
		applySystemProperties(resolved.systemProperties);

		QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime = QueryPlanSnapshotStoreSupport
				.createStoreRuntime(resolved);
		try {
			if (resolved.runAllThemeQueries) {
				runAllThemeQueriesCapture(resolved, storeRuntime);
			} else {
				runSingleQueryCapture(resolved, storeRuntime);
			}
		} finally {
			storeRuntime.close();
		}
	}

	private void runSingleQueryCapture(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime) throws Exception {
		QueryPlanSnapshotStoreSupport.ThemeDataLoadStatus themeDataLoadStatus = QueryPlanSnapshotStoreSupport
				.ensureThemeDataLoaded(storeRuntime);
		printThemeDataLoadStatus(themeDataLoadStatus);
		BenchmarkQuery benchmarkQuery = resolveBenchmarkQuery(options);
		String queryText = resolveQueryText(options, benchmarkQuery);
		String querySource = benchmarkQuery == null ? "direct" : "theme-index";
		String queryId = options.queryId != null ? options.queryId : defaultQueryId(options, benchmarkQuery);
		Path outputDirectory = options.outputDirectory != null
				? options.outputDirectory
				: defaultOutputDirectory(options.store);

		FeatureFlagCollector featureFlags = createFeatureFlagCollector(options, storeRuntime, querySource,
				themeDataLoadStatus);
		QueryPlanCaptureContext context = createContext(options, benchmarkQuery, queryText, querySource, queryId,
				outputDirectory, featureFlags);
		QueryPlanCapture capture = new QueryPlanCapture();

		QueryPlanSnapshot currentSnapshot;
		Path snapshotPath = null;
		QueryExecutionVerification executionVerification;
		try (SailRepositoryConnection connection = storeRuntime.repository.getConnection()) {
			if (options.persist) {
				snapshotPath = capture.captureAndWrite(context,
						() -> prepareTupleQuery(connection, queryText, options.queryTimeoutSeconds));
				currentSnapshot = capture.readSnapshot(snapshotPath);
				output.println("Snapshot written: " + snapshotPath.toAbsolutePath());
			} else {
				currentSnapshot = capture.capture(context,
						() -> prepareTupleQuery(connection, queryText, options.queryTimeoutSeconds));
				output.println("Snapshot captured in-memory only (--persist=false).");
			}
			applySnapshotPlanDebugMetadata(currentSnapshot);
			executionVerification = verifyRepeatedExecution(connection, queryText, options.queryTimeoutSeconds);
		}
		applyExecutionVerificationMetadata(currentSnapshot, executionVerification);
		if (options.persist && snapshotPath != null) {
			capture.writeSnapshot(snapshotPath, currentSnapshot);
		}

		printResultsSection(options, queryId, queryText);
		printPrettyExplanations(currentSnapshot);
		printExecutionVerification(executionVerification);

		if (options.compareLatest) {
			compareWithLatest(outputDirectory, queryId, currentSnapshot, snapshotPath, capture, options.diffMode);
		}
	}

	private void runAllThemeQueriesCapture(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime) throws Exception {
		Path outputDirectory = options.outputDirectory != null
				? options.outputDirectory
				: defaultOutputDirectory(options.store);
		QueryPlanSnapshotStoreSupport.ThemeDataLoadStatus themeDataLoadStatus = QueryPlanSnapshotStoreSupport
				.ensureThemeDataLoaded(storeRuntime);
		printThemeDataLoadStatus(themeDataLoadStatus);
		QueryPlanCapture capture = new QueryPlanCapture();
		Theme[] selectedThemes = selectedBatchThemes(options);
		List<BatchQueryTarget> batchTargets = buildBatchQueryTargets(options, selectedThemes);
		int total = batchTargets.size();
		BatchRunEtaReporter etaReporter = createBatchRunEtaReporter(outputDirectory, batchTargets);
		int current = 0;
		etaReporter.start();
		try {
			for (BatchQueryTarget target : batchTargets) {
				current++;
				long startedNanos = System.nanoTime();
				QueryPlanSnapshotCliOptions perQueryOptions = options.copy();
				perQueryOptions.theme = target.theme;
				perQueryOptions.queryIndex = target.queryIndex;
				String querySource = "theme-index";
				String queryId = target.queryId;
				String queryText = target.queryText;
				BenchmarkQuery benchmarkQuery = target.benchmarkQuery;

				FeatureFlagCollector featureFlags = createFeatureFlagCollector(perQueryOptions, storeRuntime,
						querySource, themeDataLoadStatus);
				QueryPlanCaptureContext context = createContext(perQueryOptions, benchmarkQuery, queryText, querySource,
						queryId, outputDirectory, featureFlags);

				QueryPlanSnapshot currentSnapshot;
				Path snapshotPath = null;
				QueryExecutionVerification executionVerification;
				try (SailRepositoryConnection connection = storeRuntime.repository.getConnection()) {
					if (options.persist) {
						snapshotPath = capture.captureAndWrite(context,
								() -> prepareTupleQuery(connection, queryText, perQueryOptions.queryTimeoutSeconds));
						currentSnapshot = capture.readSnapshot(snapshotPath);
						output.println("Snapshot written: " + snapshotPath.toAbsolutePath());
					} else {
						currentSnapshot = capture.capture(context,
								() -> prepareTupleQuery(connection, queryText, perQueryOptions.queryTimeoutSeconds));
						output.println("Snapshot captured in-memory only (--persist=false).");
					}
					applySnapshotPlanDebugMetadata(currentSnapshot);
					executionVerification = verifyRepeatedExecution(connection, queryText,
							perQueryOptions.queryTimeoutSeconds);
				}
				applyExecutionVerificationMetadata(currentSnapshot, executionVerification);
				if (options.persist && snapshotPath != null) {
					capture.writeSnapshot(snapshotPath, currentSnapshot);
				}
				long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(Math.max(1L, System.nanoTime() - startedNanos));
				etaReporter.markCompleted(queryId, elapsedMillis);

				output.println();
				output.println("=== Batch Query " + current + "/" + total + " ===");
				output.println("Theme=" + target.theme + ", QueryIndex=" + target.queryIndex + ", QueryName="
						+ benchmarkQuery.getName());
				printResultsSection(perQueryOptions, queryId, queryText);
				printPrettyExplanations(currentSnapshot);
				printExecutionVerification(executionVerification);

				if (options.compareLatest) {
					compareWithLatest(outputDirectory, queryId, currentSnapshot, snapshotPath, capture,
							options.diffMode);
				}
			}
		} finally {
			etaReporter.stop();
		}

		output.println();
		output.println("Completed run-all mode: " + total + " queries across " + selectedThemes.length + " theme"
				+ (selectedThemes.length == 1 ? "" : "s") + ".");
	}

	private Theme[] selectedBatchThemes(QueryPlanSnapshotCliOptions options) {
		if (options.theme != null) {
			return new Theme[] { options.theme };
		}
		return Theme.values();
	}

	private List<BatchQueryTarget> buildBatchQueryTargets(QueryPlanSnapshotCliOptions options, Theme[] selectedThemes) {
		List<BatchQueryTarget> targets = new ArrayList<>(selectedThemes.length * ThemeQueryCatalog.QUERY_COUNT);
		for (Theme theme : selectedThemes) {
			for (int queryIndex = 0; queryIndex < ThemeQueryCatalog.QUERY_COUNT; queryIndex++) {
				QueryPlanSnapshotCliOptions perQueryOptions = options.copy();
				perQueryOptions.theme = theme;
				perQueryOptions.queryIndex = queryIndex;
				BenchmarkQuery benchmarkQuery = ThemeQueryCatalog.benchmarkQueryFor(theme, queryIndex);
				String queryId = defaultQueryId(perQueryOptions, benchmarkQuery);
				targets.add(
						new BatchQueryTarget(theme, queryIndex, benchmarkQuery, queryId, benchmarkQuery.getQuery()));
			}
		}
		return targets;
	}

	private BatchRunEtaReporter createBatchRunEtaReporter(Path outputDirectory, List<BatchQueryTarget> batchTargets)
			throws IOException {
		Map<String, Long> historicalByQueryId = loadLatestExecutionMillisByQueryId(outputDirectory);
		long historicalAverageMillis = averagePositiveMillis(historicalByQueryId);
		List<String> queryIds = new ArrayList<>(batchTargets.size());
		for (BatchQueryTarget target : batchTargets) {
			queryIds.add(target.queryId);
		}
		return new BatchRunEtaReporter(output, queryIds, historicalByQueryId, historicalAverageMillis,
				batchEtaUpdateIntervalNanos);
	}

	private static Map<String, Long> loadLatestExecutionMillisByQueryId(Path outputDirectory) throws IOException {
		QueryPlanCapture capture = new QueryPlanCapture();
		List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator.loadRuns(outputDirectory,
				capture);
		Map<String, HistoricalQueryTiming> latestByQueryId = new HashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : allRuns) {
			QueryPlanSnapshot snapshot = run.snapshot();
			String queryId = normalizedOrNull(snapshot.getQueryId());
			if (queryId == null) {
				continue;
			}

			long executionMillis = parseExecutionMillis(snapshot);
			if (executionMillis <= 0) {
				continue;
			}

			long capturedAtEpochMillis = toEpochMillis(snapshot.getCapturedAt());
			HistoricalQueryTiming existing = latestByQueryId.get(queryId);
			if (existing == null || capturedAtEpochMillis >= existing.capturedAtEpochMillis) {
				latestByQueryId.put(queryId, new HistoricalQueryTiming(executionMillis, capturedAtEpochMillis));
			}
		}

		Map<String, Long> executionMillisByQueryId = new HashMap<>();
		latestByQueryId.forEach((queryId, timing) -> executionMillisByQueryId.put(queryId, timing.executionMillis));
		return executionMillisByQueryId;
	}

	private static long parseExecutionMillis(QueryPlanSnapshot snapshot) {
		if (snapshot == null || snapshot.getMetadata() == null) {
			return 0L;
		}
		Map<String, String> metadata = snapshot.getMetadata();
		long totalMillis = parsePositiveLong(metadata.get("execution.totalMillis"));
		if (totalMillis > 0L) {
			return totalMillis;
		}

		long averageMillis = parsePositiveLong(metadata.get("execution.averageMillis"));
		long runs = parsePositiveLong(metadata.get("execution.runs"));
		if (averageMillis <= 0L || runs <= 0L) {
			return 0L;
		}
		try {
			return Math.multiplyExact(averageMillis, runs);
		} catch (ArithmeticException overflow) {
			return Long.MAX_VALUE;
		}
	}

	private static long parsePositiveLong(String raw) {
		if (raw == null || raw.isBlank()) {
			return 0L;
		}
		try {
			long parsed = Long.parseLong(raw.trim());
			return parsed > 0L ? parsed : 0L;
		} catch (NumberFormatException ignored) {
			try {
				double parsed = Double.parseDouble(raw.trim());
				return parsed > 0.0d ? Math.max(1L, Math.round(parsed)) : 0L;
			} catch (NumberFormatException ignoredAgain) {
				return 0L;
			}
		}
	}

	private static long averagePositiveMillis(Map<String, Long> values) {
		long total = 0L;
		int count = 0;
		for (Long value : values.values()) {
			if (value == null || value <= 0L) {
				continue;
			}
			total += value;
			count++;
		}
		if (count == 0) {
			return 0L;
		}
		return Math.max(1L, total / count);
	}

	private void runCompareExisting(QueryPlanSnapshotCliOptions options) throws Exception {
		QueryPlanSnapshotCliOptions resolved = resolveCompareOptions(options);
		Path outputDirectory = resolved.outputDirectory != null
				? resolved.outputDirectory
				: QueryPlanCapture.resolveOutputDirectory();
		QueryPlanCapture capture = new QueryPlanCapture();

		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator
				.loadRuns(outputDirectory, capture);
		if (resolved.compareRunNames != null) {
			runCompareRunNamePairBatch(resolved, allRuns);
			return;
		}
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> matchingRuns = QueryPlanSnapshotComparator
				.filterRuns(allRuns, normalizedOrNull(resolved.queryId),
						normalizedOrNull(resolved.comparisonFingerprint), normalizedOrNull(resolved.runName));

		if (matchingRuns.isEmpty()) {
			output.println("No matching runs found in " + outputDirectory.toAbsolutePath());
			return;
		}

		QueryPlanSnapshotComparator.printRunList(output, matchingRuns);
		if (resolved.compareIndices != null || resolved.noInteractive) {
			if (matchingRuns.size() < 2) {
				output.println("Need at least two runs to compare.");
				return;
			}
			QueryPlanSnapshotCliOptions.ComparisonPair pair = resolveComparisonPair(resolved, matchingRuns.size());
			QueryPlanSnapshotComparator.SnapshotRun left = QueryPlanSnapshotComparator.runAtIndex(matchingRuns,
					pair.leftIndex);
			QueryPlanSnapshotComparator.SnapshotRun right = QueryPlanSnapshotComparator.runAtIndex(matchingRuns,
					pair.rightIndex);
			QueryPlanSnapshotComparator.printComparison(output, left, right, resolved.diffMode);
			return;
		}

		runInteractiveRunBrowser(matchingRuns, resolved.diffMode);
	}

	private void runCompareRunNamePairBatch(QueryPlanSnapshotCliOptions options,
			List<QueryPlanSnapshotComparator.SnapshotRun> allRuns) throws IOException {
		QueryPlanSnapshotCliOptions.RunNamePair runNames = options.compareRunNames;
		String leftRunName = normalizedOrNull(runNames.leftRunName);
		String rightRunName = normalizedOrNull(runNames.rightRunName);
		String queryIdFilter = normalizedOrNull(options.queryId);

		if (Objects.equals(leftRunName, rightRunName)) {
			throw new IllegalArgumentException("--compare-run-names requires two distinct run names.");
		}

		LinkedHashMap<String, QueryPlanSnapshotComparator.SnapshotRun> leftRuns = latestRunsByQueryId(allRuns,
				leftRunName, queryIdFilter);
		LinkedHashMap<String, QueryPlanSnapshotComparator.SnapshotRun> rightRuns = latestRunsByQueryId(allRuns,
				rightRunName, queryIdFilter);

		List<String> sharedQueryIds = new ArrayList<>();
		for (String queryId : leftRuns.keySet()) {
			if (rightRuns.containsKey(queryId)) {
				sharedQueryIds.add(queryId);
			}
		}
		sharedQueryIds.sort(String::compareTo);

		if (sharedQueryIds.isEmpty()) {
			output.println("No shared query ids found for run names '" + leftRunName + "' and '" + rightRunName + "'.");
			return;
		}

		output.println("Run-name batch comparison:");
		output.println("  left run name : " + leftRunName + " (" + leftRuns.size() + " query ids)");
		output.println("  right run name: " + rightRunName + " (" + rightRuns.size() + " query ids)");
		output.println("  shared query ids: " + sharedQueryIds.size());

		if (options.emitCsv == null) {
			return;
		}

		Path csvPath = options.emitCsv;
		Path parent = csvPath.getParent();
		if (parent != null) {
			Files.createDirectories(parent);
		}
		try (BufferedWriter writer = Files.newBufferedWriter(csvPath, StandardCharsets.UTF_8)) {
			writer.write(String.join(",",
					"queryId",
					"leftRunName",
					"rightRunName",
					"leftCapturedAt",
					"rightCapturedAt",
					"leftAverageMillis",
					"rightAverageMillis",
					"deltaPct",
					"unoptimizedFingerprint",
					"queryString",
					"optimizedStructure",
					"optimizedJoinAlgorithms",
					"optimizedActualResultSizes",
					"optimizedEstimates",
					"executedStructure",
					"executedJoinAlgorithms",
					"executedActualResultSizes",
					"executedEstimates",
					"optimizedPlanNodeCountLeft",
					"optimizedPlanNodeCountRight",
					"optimizedJoinNodeCountLeft",
					"optimizedJoinNodeCountRight",
					"optimizedAnonymousTypeTokenCountLeft",
					"optimizedAnonymousTypeTokenCountRight",
					"optimizedStructureSignatureRawLeft",
					"optimizedStructureSignatureRawRight",
					"optimizedStructureSignatureNormalizedLeft",
					"optimizedStructureSignatureNormalizedRight",
					"optimizedEstimatesMultisetSignatureLeft",
					"optimizedEstimatesMultisetSignatureRight",
					"optimizedStatementPatternEstimatesMultisetSignatureLeft",
					"optimizedStatementPatternEstimatesMultisetSignatureRight",
					"queryStringSha256Left",
					"queryStringSha256Right",
					"queryStringNormalizedWhitespaceSha256Left",
					"queryStringNormalizedWhitespaceSha256Right",
					"optimizerInputUnoptimizedStructureNormalizedLeft",
					"optimizerInputUnoptimizedStructureNormalizedRight",
					"executionStdDevMillisLeft",
					"executionStdDevMillisRight",
					"executionCoefficientOfVariationPctLeft",
					"executionCoefficientOfVariationPctRight",
					"executionOptimizedPlanHashCountLeft",
					"executionOptimizedPlanHashCountRight",
					"executionOptimizedPlanHashStableLeft",
					"executionOptimizedPlanHashStableRight",
					"executionVerificationStatusLeft",
					"executionVerificationStatusRight",
					"executionFailureClassLeft",
					"executionFailureClassRight",
					"executionFailureMessageLeft",
					"executionFailureMessageRight",
					"executionFailureCauseClassLeft",
					"executionFailureCauseClassRight",
					"executionFailureCauseMessageLeft",
					"executionFailureCauseMessageRight",
					"executionFailureRunLeft",
					"executionFailureRunRight",
					"executionFailurePlanHashLeft",
					"executionFailurePlanHashRight",
					"executionOptimizedPlanHashTransitionCountLeft",
					"executionOptimizedPlanHashTransitionCountRight",
					"executionOptimizedPlanHashSequenceLeft",
					"executionOptimizedPlanHashSequenceRight",
					"planDeterminismInputFingerprintSha256Left",
					"planDeterminismInputFingerprintSha256Right",
					"planDeterminismEnvironmentFingerprintSha256Left",
					"planDeterminismEnvironmentFingerprintSha256Right",
					"featureFlagsSha256Left",
					"featureFlagsSha256Right",
					"planDeterminismInputFingerprintMatches",
					"planDeterminismEnvironmentFingerprintMatches",
					"featureFlagsFingerprintMatches",
					"optimizerInputStructureFingerprintMatches",
					"optimizerOutputStructureFingerprintMatches",
					"executionPlanStructureFingerprintMatches",
					"planDifferenceLikelyCause",
					"planDifferenceEvidence",
					"optimizerInputUnoptimizedRootTypeNormalizedLeft",
					"optimizerInputUnoptimizedRootTypeNormalizedRight",
					"optimizerInputUnoptimizedPlanNodeCountLeft",
					"optimizerInputUnoptimizedPlanNodeCountRight",
					"optimizerOutputOptimizedRootTypeNormalizedLeft",
					"optimizerOutputOptimizedRootTypeNormalizedRight",
					"optimizerOutputOptimizedJoinAlgorithmCountsLeft",
					"optimizerOutputOptimizedJoinAlgorithmCountsRight",
					"optimizerOutputOptimizedPlanNodeCountLeft",
					"optimizerOutputOptimizedPlanNodeCountRight",
					"executionPlanExecutedRootTypeNormalizedLeft",
					"executionPlanExecutedRootTypeNormalizedRight",
					"executionPlanExecutedPlanNodeCountLeft",
					"executionPlanExecutedPlanNodeCountRight",
					"executedModeledWorkUnitsLeft",
					"executedModeledWorkUnitsRight",
					"executedModeledWorkDeltaPct",
					"executedModeledScoreLeft",
					"executedModeledScoreRight",
					"executedModeledScoreDeltaPct",
					"executedModeledWinner",
					"executedModeledDecisionBasis",
					"executedModeledInputRowsSumLeft",
					"executedModeledInputRowsSumRight",
					"executedModeledOutputRowsSumLeft",
					"executedModeledOutputRowsSumRight",
					"executedModeledSelfTimeActualSumLeft",
					"executedModeledSelfTimeActualSumRight",
					"executedModeledTotalTimeActualSumLeft",
					"executedModeledTotalTimeActualSumRight",
					"executedModeledBarrierCountLeft",
					"executedModeledBarrierCountRight",
					"executedModeledJoinInputRowsSumLeft",
					"executedModeledJoinInputRowsSumRight",
					"executedModeledJoinOutputRowsSumLeft",
					"executedModeledJoinOutputRowsSumRight",
					"executedModeledFilterInputRowsSumLeft",
					"executedModeledFilterInputRowsSumRight",
					"executedModeledFilterOutputRowsSumLeft",
					"executedModeledFilterOutputRowsSumRight",
					"executedModeledFilterPassRatioLeft",
					"executedModeledFilterPassRatioRight",
					"executedModeledFilterRejectRatioLeft",
					"executedModeledFilterRejectRatioRight",
					"executedJoinRightIteratorCreateCountSumLeft",
					"executedJoinRightIteratorCreateCountSumRight",
					"executedJoinLeftBindingSetConsumedCountSumLeft",
					"executedJoinLeftBindingSetConsumedCountSumRight",
					"executedJoinRightBindingSetConsumedCountSumLeft",
					"executedJoinRightBindingSetConsumedCountSumRight",
					"executedJoinRightBindingsPerLeftRatioLeft",
					"executedJoinRightBindingsPerLeftRatioRight",
					"executedJoinTelemetryNodeCountLeft",
					"executedJoinTelemetryNodeCountRight",
					"executedJoinRightBindingSetConsumedPerRightIteratorAverageLeft",
					"executedJoinRightBindingSetConsumedPerRightIteratorAverageRight",
					"executedJoinRightIteratorCreatePerJoinNodeAverageLeft",
					"executedJoinRightIteratorCreatePerJoinNodeAverageRight",
					"executedJoinLeftBindingSetConsumedPerJoinNodeAverageLeft",
					"executedJoinLeftBindingSetConsumedPerJoinNodeAverageRight",
					"executedJoinRightBindingSetConsumedPerJoinNodeAverageLeft",
					"executedJoinRightBindingSetConsumedPerJoinNodeAverageRight",
					"executedSourceRowsScannedSumLeft",
					"executedSourceRowsScannedSumRight",
					"executedSourceRowsMatchedSumLeft",
					"executedSourceRowsMatchedSumRight",
					"executedSourceRowsFilteredSumLeft",
					"executedSourceRowsFilteredSumRight",
					"executedSourceFilterOutRatioLeft",
					"executedSourceFilterOutRatioRight",
					"executedModeledWorkByCategoryLeft",
					"executedModeledWorkByCategoryRight",
					"executedModeledWorkVectorSignatureLeft",
					"executedModeledWorkVectorSignatureRight",
					"executedModeledOperatorCountByCategoryLeft",
					"executedModeledOperatorCountByCategoryRight",
					"executedModeledJoinWorkByAlgorithmLeft",
					"executedModeledJoinWorkByAlgorithmRight",
					"executedOperatorWorkBreakdownSignatureLeft",
					"executedOperatorWorkBreakdownSignatureRight",
					"executedOperatorWorkTopContributorsLeft",
					"executedOperatorWorkTopContributorsRight",
					"executedEstimateActualQErrorP95Left",
					"executedEstimateActualQErrorP95Right",
					"executedEstimateActualQErrorMaxLeft",
					"executedEstimateActualQErrorMaxRight",
					"executedJoinEstimateActualQErrorP95Left",
					"executedJoinEstimateActualQErrorP95Right",
					"executedModeledTopCategoryDeltas",
					"executedModeledTopOperatorDeltas",
					"executedModeledTopVectorDeltas",
					"executedModeledDominantResourceLeft",
					"executedModeledDominantResourceRight",
					"executedModeledTopResourceDeltas",
					"runtimeJavaVendorLeft",
					"runtimeJavaVendorRight",
					"runtimeOsNameLeft",
					"runtimeOsNameRight",
					"runtimeOsArchLeft",
					"runtimeOsArchRight"));
			writer.newLine();

			for (String queryId : sharedQueryIds) {
				QueryPlanSnapshotComparator.SnapshotRun left = leftRuns.get(queryId);
				QueryPlanSnapshotComparator.SnapshotRun right = rightRuns.get(queryId);
				QueryPlanSnapshotComparator.ComparisonSummary summary = QueryPlanSnapshotComparator.compareRuns(left,
						right, options.diffMode);
				QueryPlanSnapshotComparator.LevelDiff optimizedDiff = summary.explanationDiffs().get("optimized");
				QueryPlanSnapshotComparator.LevelDiff executedDiff = summary.explanationDiffs().get("telemetry");

				String leftAverageMillis = metadataValue(left.snapshot(), "execution.averageMillis");
				String rightAverageMillis = metadataValue(right.snapshot(), "execution.averageMillis");
				String deltaPct = calculateDeltaPercent(leftAverageMillis, rightAverageMillis);
				String leftExecutedModeledWorkUnits = explanationDebugMetric(left.snapshot(), "telemetry",
						"modeledWorkUnits");
				String rightExecutedModeledWorkUnits = explanationDebugMetric(right.snapshot(), "telemetry",
						"modeledWorkUnits");
				String executedModeledWorkDeltaPct = calculateDeltaPercent(leftExecutedModeledWorkUnits,
						rightExecutedModeledWorkUnits);
				QueryPlanExecutedWorkComparator.ExecutedWorkComparison executedWorkComparison = summary
						.executedWorkComparison();
				QueryPlanSnapshotComparator.PlanDifferenceDiagnosis planDifferenceDiagnosis = summary
						.planDifferenceDiagnosis();
				String inputFingerprintMatches = equalsIndicator(
						metadataValue(left.snapshot(), "planDeterminism.inputFingerprintSha256"),
						metadataValue(right.snapshot(), "planDeterminism.inputFingerprintSha256"));
				String environmentFingerprintMatches = equalsIndicator(
						metadataValue(left.snapshot(), "planDeterminism.environmentFingerprintSha256"),
						metadataValue(right.snapshot(), "planDeterminism.environmentFingerprintSha256"));
				String featureFlagsFingerprintMatches = equalsIndicator(
						metadataValue(left.snapshot(), "featureFlags.sha256"),
						metadataValue(right.snapshot(), "featureFlags.sha256"));
				String optimizerInputStructureFingerprintMatches = equalsIndicator(
						metadataValue(left.snapshot(), "optimizerInput.unoptimizedStructureNormalizedSha256"),
						metadataValue(right.snapshot(), "optimizerInput.unoptimizedStructureNormalizedSha256"));
				String optimizerOutputStructureFingerprintMatches = equalsIndicator(
						explanationDebugMetric(left.snapshot(), "optimized", "structureSignatureNormalizedSha256"),
						explanationDebugMetric(right.snapshot(), "optimized", "structureSignatureNormalizedSha256"));
				String executionPlanStructureFingerprintMatches = equalsIndicator(
						explanationDebugMetric(left.snapshot(), "telemetry", "structureSignatureNormalizedSha256"),
						explanationDebugMetric(right.snapshot(), "telemetry", "structureSignatureNormalizedSha256"));

				writer.write(String.join(",",
						csvValue(queryId),
						csvValue(leftRunName),
						csvValue(rightRunName),
						csvValue(left.snapshot().getCapturedAt()),
						csvValue(right.snapshot().getCapturedAt()),
						csvValue(leftAverageMillis),
						csvValue(rightAverageMillis),
						csvValue(deltaPct),
						csvValue(summary.unoptimizedFingerprint()),
						csvValue(summary.queryString()),
						csvValue(levelValue(optimizedDiff, FieldKind.STRUCTURE)),
						csvValue(levelValue(optimizedDiff, FieldKind.JOIN_ALGORITHMS)),
						csvValue(levelValue(optimizedDiff, FieldKind.ACTUAL_RESULT_SIZES)),
						csvValue(levelValue(optimizedDiff, FieldKind.ESTIMATES)),
						csvValue(levelValue(executedDiff, FieldKind.STRUCTURE)),
						csvValue(levelValue(executedDiff, FieldKind.JOIN_ALGORITHMS)),
						csvValue(levelValue(executedDiff, FieldKind.ACTUAL_RESULT_SIZES)),
						csvValue(levelValue(executedDiff, FieldKind.ESTIMATES)),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized", "planNodeCount")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized", "planNodeCount")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized", "joinNodeCount")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized", "joinNodeCount")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized", "anonymousTypeTokenCount")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized", "anonymousTypeTokenCount")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized", "structureSignatureRawSha256")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized", "structureSignatureRawSha256")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized",
								"structureSignatureNormalizedSha256")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized",
								"structureSignatureNormalizedSha256")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized",
								"estimatesMultisetSignatureSha256")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized",
								"estimatesMultisetSignatureSha256")),
						csvValue(explanationDebugMetric(left.snapshot(), "optimized",
								"statementPatternEstimatesMultisetSignatureSha256")),
						csvValue(explanationDebugMetric(right.snapshot(), "optimized",
								"statementPatternEstimatesMultisetSignatureSha256")),
						csvValue(metadataValue(left.snapshot(), "queryString.sha256")),
						csvValue(metadataValue(right.snapshot(), "queryString.sha256")),
						csvValue(metadataValue(left.snapshot(), "queryString.normalizedWhitespaceSha256")),
						csvValue(metadataValue(right.snapshot(), "queryString.normalizedWhitespaceSha256")),
						csvValue(metadataValue(left.snapshot(), "optimizerInput.unoptimizedStructureNormalizedSha256")),
						csvValue(
								metadataValue(right.snapshot(), "optimizerInput.unoptimizedStructureNormalizedSha256")),
						csvValue(metadataValue(left.snapshot(), "execution.stdDevMillis")),
						csvValue(metadataValue(right.snapshot(), "execution.stdDevMillis")),
						csvValue(metadataValue(left.snapshot(), "execution.coefficientOfVariationPct")),
						csvValue(metadataValue(right.snapshot(), "execution.coefficientOfVariationPct")),
						csvValue(metadataValue(left.snapshot(), "execution.optimizedPlanHashCount")),
						csvValue(metadataValue(right.snapshot(), "execution.optimizedPlanHashCount")),
						csvValue(metadataValue(left.snapshot(), "execution.optimizedPlanHashStable")),
						csvValue(metadataValue(right.snapshot(), "execution.optimizedPlanHashStable")),
						csvValue(metadataValue(left.snapshot(), "execution.verificationStatus")),
						csvValue(metadataValue(right.snapshot(), "execution.verificationStatus")),
						csvValue(metadataValue(left.snapshot(), "execution.failureClass")),
						csvValue(metadataValue(right.snapshot(), "execution.failureClass")),
						csvValue(metadataValue(left.snapshot(), "execution.failureMessage")),
						csvValue(metadataValue(right.snapshot(), "execution.failureMessage")),
						csvValue(metadataValue(left.snapshot(), "execution.failureCauseClass")),
						csvValue(metadataValue(right.snapshot(), "execution.failureCauseClass")),
						csvValue(metadataValue(left.snapshot(), "execution.failureCauseMessage")),
						csvValue(metadataValue(right.snapshot(), "execution.failureCauseMessage")),
						csvValue(metadataValue(left.snapshot(), "execution.failureRun")),
						csvValue(metadataValue(right.snapshot(), "execution.failureRun")),
						csvValue(metadataValue(left.snapshot(), "execution.failurePlanHash")),
						csvValue(metadataValue(right.snapshot(), "execution.failurePlanHash")),
						csvValue(metadataValue(left.snapshot(), "execution.optimizedPlanHashTransitionCount")),
						csvValue(metadataValue(right.snapshot(), "execution.optimizedPlanHashTransitionCount")),
						csvValue(metadataValue(left.snapshot(), "execution.optimizedPlanHashSequence")),
						csvValue(metadataValue(right.snapshot(), "execution.optimizedPlanHashSequence")),
						csvValue(metadataValue(left.snapshot(), "planDeterminism.inputFingerprintSha256")),
						csvValue(metadataValue(right.snapshot(), "planDeterminism.inputFingerprintSha256")),
						csvValue(metadataValue(left.snapshot(), "planDeterminism.environmentFingerprintSha256")),
						csvValue(metadataValue(right.snapshot(), "planDeterminism.environmentFingerprintSha256")),
						csvValue(metadataValue(left.snapshot(), "featureFlags.sha256")),
						csvValue(metadataValue(right.snapshot(), "featureFlags.sha256")),
						csvValue(inputFingerprintMatches),
						csvValue(environmentFingerprintMatches),
						csvValue(featureFlagsFingerprintMatches),
						csvValue(optimizerInputStructureFingerprintMatches),
						csvValue(optimizerOutputStructureFingerprintMatches),
						csvValue(executionPlanStructureFingerprintMatches),
						csvValue(planDifferenceDiagnosis == null ? "" : planDifferenceDiagnosis.likelyCause()),
						csvValue(planDifferenceDiagnosis == null ? "" : planDifferenceDiagnosis.evidence()),
						csvValue(metadataValue(left.snapshot(), "optimizerInput.unoptimizedRootTypeNormalized")),
						csvValue(metadataValue(right.snapshot(), "optimizerInput.unoptimizedRootTypeNormalized")),
						csvValue(metadataValue(left.snapshot(), "optimizerInput.unoptimizedPlanNodeCount")),
						csvValue(metadataValue(right.snapshot(), "optimizerInput.unoptimizedPlanNodeCount")),
						csvValue(metadataValue(left.snapshot(), "optimizerOutput.optimizedRootTypeNormalized")),
						csvValue(metadataValue(right.snapshot(), "optimizerOutput.optimizedRootTypeNormalized")),
						csvValue(metadataValue(left.snapshot(), "optimizerOutput.optimizedJoinAlgorithmCounts")),
						csvValue(metadataValue(right.snapshot(), "optimizerOutput.optimizedJoinAlgorithmCounts")),
						csvValue(metadataValue(left.snapshot(), "optimizerOutput.optimizedPlanNodeCount")),
						csvValue(metadataValue(right.snapshot(), "optimizerOutput.optimizedPlanNodeCount")),
						csvValue(metadataValue(left.snapshot(), "executionPlan.executedRootTypeNormalized")),
						csvValue(metadataValue(right.snapshot(), "executionPlan.executedRootTypeNormalized")),
						csvValue(metadataValue(left.snapshot(), "executionPlan.executedPlanNodeCount")),
						csvValue(metadataValue(right.snapshot(), "executionPlan.executedPlanNodeCount")),
						csvValue(leftExecutedModeledWorkUnits),
						csvValue(rightExecutedModeledWorkUnits),
						csvValue(executedModeledWorkDeltaPct),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.leftScore()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.rightScore()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.scoreDeltaPct()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.winner()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.decisionBasis()),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledInputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledInputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledOutputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledOutputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledSelfTimeActualSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledSelfTimeActualSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledTotalTimeActualSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledTotalTimeActualSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledBarrierCount")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledBarrierCount")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledJoinInputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledJoinInputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledJoinOutputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledJoinOutputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledFilterInputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledFilterInputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledFilterOutputRowsSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledFilterOutputRowsSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledFilterPassRatio")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledFilterPassRatio")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledFilterRejectRatio")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledFilterRejectRatio")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry",
										"modeledJoinRightIteratorCreateCountSum")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledJoinRightIteratorCreateCountSum")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry",
										"modeledJoinLeftBindingSetConsumedCountSum")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledJoinLeftBindingSetConsumedCountSum")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry",
										"modeledJoinRightBindingSetConsumedCountSum")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledJoinRightBindingSetConsumedCountSum")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry",
										"modeledJoinRightBindingsPerLeftRatio")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledJoinRightBindingsPerLeftRatio")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledJoinTelemetryNodeCount")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry", "modeledJoinTelemetryNodeCount")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry",
								"modeledJoinRightBindingSetConsumedPerRightIteratorAverage")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry",
								"modeledJoinRightBindingSetConsumedPerRightIteratorAverage")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry",
								"modeledJoinRightIteratorCreatePerJoinNodeAverage")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry",
								"modeledJoinRightIteratorCreatePerJoinNodeAverage")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry",
								"modeledJoinLeftBindingSetConsumedPerJoinNodeAverage")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry",
								"modeledJoinLeftBindingSetConsumedPerJoinNodeAverage")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry",
								"modeledJoinRightBindingSetConsumedPerJoinNodeAverage")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry",
								"modeledJoinRightBindingSetConsumedPerJoinNodeAverage")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledSourceRowsScannedSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledSourceRowsScannedSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledSourceRowsMatchedSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledSourceRowsMatchedSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledSourceRowsFilteredSum")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledSourceRowsFilteredSum")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledSourceFilterOutRatio")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledSourceFilterOutRatio")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledWorkByCategory")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledWorkByCategory")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry",
								"modeledWorkVectorSignatureSha256")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledWorkVectorSignatureSha256")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry", "modeledOperatorCountByCategory")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"modeledOperatorCountByCategory")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "modeledJoinWorkByAlgorithm")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "modeledJoinWorkByAlgorithm")),
						csvValue(
								explanationDebugMetric(left.snapshot(), "telemetry",
										"operatorWorkBreakdownSignatureSha256")),
						csvValue(
								explanationDebugMetric(right.snapshot(), "telemetry",
										"operatorWorkBreakdownSignatureSha256")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "operatorWorkTopContributors")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "operatorWorkTopContributors")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "estimateActualQErrorP95")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "estimateActualQErrorP95")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "estimateActualQErrorMax")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "estimateActualQErrorMax")),
						csvValue(explanationDebugMetric(left.snapshot(), "telemetry", "joinEstimateActualQErrorP95")),
						csvValue(explanationDebugMetric(right.snapshot(), "telemetry", "joinEstimateActualQErrorP95")),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.topCategoryDeltas()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.topOperatorDeltas()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.topVectorDeltas()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.dominantResourceLeft()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.dominantResourceRight()),
						csvValue(executedWorkComparison == null ? "" : executedWorkComparison.topResourceDeltas()),
						csvValue(metadataValue(left.snapshot(), "runtime.javaVendor")),
						csvValue(metadataValue(right.snapshot(), "runtime.javaVendor")),
						csvValue(metadataValue(left.snapshot(), "runtime.osName")),
						csvValue(metadataValue(right.snapshot(), "runtime.osName")),
						csvValue(metadataValue(left.snapshot(), "runtime.osArch")),
						csvValue(metadataValue(right.snapshot(), "runtime.osArch"))));
				writer.newLine();
			}
		}
		output.println("Batch CSV written: " + csvPath.toAbsolutePath());
	}

	private static LinkedHashMap<String, QueryPlanSnapshotComparator.SnapshotRun> latestRunsByQueryId(
			List<QueryPlanSnapshotComparator.SnapshotRun> allRuns, String runName, String queryIdFilter) {
		LinkedHashMap<String, QueryPlanSnapshotComparator.SnapshotRun> latestRuns = new LinkedHashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : allRuns) {
			QueryPlanSnapshot snapshot = run.snapshot();
			Map<String, String> metadata = snapshot.getMetadata();
			String snapshotRunName = metadata == null ? null : normalizedOrNull(metadata.get("runName"));
			if (!Objects.equals(snapshotRunName, runName)) {
				continue;
			}

			String queryId = normalizedOrNull(snapshot.getQueryId());
			if (queryId == null) {
				continue;
			}
			if (queryIdFilter != null && !queryIdFilter.equals(queryId)) {
				continue;
			}
			QueryPlanSnapshotComparator.SnapshotRun existing = latestRuns.get(queryId);
			if (existing == null || prefersForRunNameBatchComparison(run, existing)) {
				latestRuns.put(queryId, run);
			}
		}
		return latestRuns;
	}

	private static boolean prefersForRunNameBatchComparison(QueryPlanSnapshotComparator.SnapshotRun candidate,
			QueryPlanSnapshotComparator.SnapshotRun existing) {
		int candidateRank = runNameBatchSelectionRank(candidate.snapshot());
		int existingRank = runNameBatchSelectionRank(existing.snapshot());
		if (candidateRank != existingRank) {
			return candidateRank > existingRank;
		}
		long candidateEpochMillis = toEpochMillis(candidate.snapshot().getCapturedAt());
		long existingEpochMillis = toEpochMillis(existing.snapshot().getCapturedAt());
		return candidateEpochMillis > existingEpochMillis;
	}

	private static int runNameBatchSelectionRank(QueryPlanSnapshot snapshot) {
		Map<String, String> metadata = snapshot == null ? null : snapshot.getMetadata();
		if (metadata == null || metadata.isEmpty()) {
			return 0;
		}
		String verificationStatus = normalizedOrNull(metadata.get("execution.verificationStatus"));
		long averageMillis = parseNonNegativeLong(metadata.get("execution.averageMillis"));
		long executionRuns = parseNonNegativeLong(metadata.get("execution.runs"));
		boolean hasExecutionFailure = normalizedOrNull(metadata.get("execution.failureClass")) != null
				|| normalizedOrNull(metadata.get("execution.failureCauseClass")) != null;

		if (("max-runs-reached".equals(verificationStatus) || "soft-limit-reached".equals(verificationStatus))
				&& averageMillis > 0L) {
			return 4;
		}
		if (averageMillis > 0L || executionRuns > 0L) {
			return 3;
		}
		if (verificationStatus != null && !verificationStatus.isBlank()) {
			return 2;
		}
		if (hasExecutionFailure) {
			return 1;
		}
		return 0;
	}

	private static long parseNonNegativeLong(String value) {
		if (value == null || value.isBlank()) {
			return -1L;
		}
		try {
			long parsed = Long.parseLong(value);
			return Math.max(-1L, parsed);
		} catch (NumberFormatException ignored) {
			return -1L;
		}
	}

	private static String metadataValue(QueryPlanSnapshot snapshot, String key) {
		if (snapshot == null || snapshot.getMetadata() == null) {
			return "";
		}
		String value = snapshot.getMetadata().get(key);
		return value == null ? "" : value;
	}

	private static String explanationDebugMetric(QueryPlanSnapshot snapshot, String level, String key) {
		if (snapshot == null || snapshot.getExplanations() == null || key == null || level == null) {
			return "";
		}

		String value = explanationDebugMetricForLevel(snapshot, level, key);
		if (!value.isEmpty()) {
			return value;
		}

		if (EXPLANATION_LEVEL_TELEMETRY.equalsIgnoreCase(level)) {
			return explanationDebugMetricForLevel(snapshot, "executed", key);
		}

		return "";
	}

	private static String explanationDebugMetricForLevel(QueryPlanSnapshot snapshot, String level, String key) {
		QueryPlanExplanation explanation = snapshot.getExplanations().get(level);
		if (explanation != null && explanation.getDebugMetrics() != null) {
			String value = explanation.getDebugMetrics().get(key);
			if (value != null && !value.isBlank()) {
				return value;
			}
		}

		for (QueryPlanExplanation candidate : snapshot.getExplanations().values()) {
			if (candidate == null || candidate.getDebugMetrics() == null) {
				continue;
			}
			if (!level.equalsIgnoreCase(candidate.getLevel())) {
				continue;
			}
			String value = candidate.getDebugMetrics().get(key);
			if (value != null && !value.isBlank()) {
				return value;
			}
		}

		return "";
	}

	private static String equalsIndicator(String left, String right) {
		String normalizedLeft = normalizedOrNull(left);
		String normalizedRight = normalizedOrNull(right);
		if (normalizedLeft == null || normalizedRight == null) {
			return "";
		}
		return Boolean.toString(normalizedLeft.equals(normalizedRight));
	}

	private static String levelValue(QueryPlanSnapshotComparator.LevelDiff levelDiff, FieldKind fieldKind) {
		if (levelDiff == null) {
			return "missing";
		}
		switch (fieldKind) {
		case STRUCTURE:
			return levelDiff.structure();
		case JOIN_ALGORITHMS:
			return levelDiff.joinAlgorithms();
		case ACTUAL_RESULT_SIZES:
			return levelDiff.actualResultSizes();
		case ESTIMATES:
			return levelDiff.estimates();
		default:
			throw new IllegalStateException("Unhandled field kind: " + fieldKind);
		}
	}

	private static String calculateDeltaPercent(String baselineMillis, String candidateMillis) {
		if (baselineMillis == null || baselineMillis.isBlank() || candidateMillis == null
				|| candidateMillis.isBlank()) {
			return "";
		}
		double left;
		double right;
		try {
			left = Double.parseDouble(baselineMillis);
			right = Double.parseDouble(candidateMillis);
		} catch (NumberFormatException ignored) {
			return "";
		}
		if (left == 0.0d) {
			return "";
		}
		double deltaPercent = ((right - left) / left) * 100.0d;
		return Double.toString(deltaPercent);
	}

	private static String csvValue(String value) {
		if (value == null) {
			return "";
		}
		boolean requiresQuotes = value.contains(",") || value.contains("\"") || value.contains("\n")
				|| value.contains("\r");
		if (!requiresQuotes) {
			return value;
		}
		return "\"" + value.replace("\"", "\"\"") + "\"";
	}

	private enum FieldKind {
		STRUCTURE,
		JOIN_ALGORITHMS,
		ACTUAL_RESULT_SIZES,
		ESTIMATES
	}

	private void runRenameRunsByCommit(QueryPlanSnapshotCliOptions options) throws Exception {
		Path outputDirectory = resolveRenameOutputDirectory(options);
		QueryPlanCapture capture = new QueryPlanCapture();
		List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator.loadRuns(outputDirectory,
				capture);
		List<CommitRunGroup> groups = groupRunsByCommit(allRuns);
		if (groups.isEmpty()) {
			output.println("No runs with gitCommit metadata found in " + outputDirectory.toAbsolutePath());
			return;
		}

		int selectedIndex = promptChoiceIndex("Select commit", toCommitChoices(groups));
		CommitRunGroup selectedGroup = groups.get(selectedIndex);
		String newRunName = promptRequiredValue("New run name");
		int updatedRuns = renameRunsForCommit(allRuns, selectedGroup.commit(), newRunName, capture);
		output.println("Renamed " + updatedRuns + " run(s) for commit " + selectedGroup.commit()
				+ " to runName=" + newRunName);
	}

	private Path resolveRenameOutputDirectory(QueryPlanSnapshotCliOptions options) throws IOException {
		if (options.outputDirectory != null) {
			return options.outputDirectory;
		}
		Path prompted = promptOptionalPath("Output directory (blank uses default)");
		return prompted != null ? prompted : QueryPlanCapture.resolveOutputDirectory();
	}

	private List<CommitRunGroup> groupRunsByCommit(List<QueryPlanSnapshotComparator.SnapshotRun> runs) {
		Map<String, CommitRunGroup> byCommit = new java.util.LinkedHashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : runs) {
			Map<String, String> metadata = run.snapshot().getMetadata();
			if (metadata == null) {
				continue;
			}
			String commit = normalizedOrNull(metadata.get("gitCommit"));
			if (commit == null) {
				continue;
			}
			String branch = normalizedOrNull(metadata.get("gitBranch"));
			byCommit.computeIfAbsent(commit, CommitRunGroup::new).recordRun(run, branch);
		}

		List<CommitRunGroup> groups = new ArrayList<>(byCommit.values());
		groups.sort((left, right) -> {
			int byTime = Long.compare(right.latestEpochMillis(), left.latestEpochMillis());
			return byTime != 0 ? byTime : left.commit().compareTo(right.commit());
		});
		return groups;
	}

	private List<String> toCommitChoices(List<CommitRunGroup> groups) {
		List<String> choices = new ArrayList<>(groups.size());
		for (CommitRunGroup group : groups) {
			choices.add("commit=" + group.commit()
					+ " branch=" + group.branchSummary()
					+ " localTime=" + formatLocalTime(group.latestCapturedAt())
					+ " runs=" + group.runCount());
		}
		return choices;
	}

	private int renameRunsForCommit(List<QueryPlanSnapshotComparator.SnapshotRun> runs, String commit,
			String newRunName, QueryPlanCapture capture) throws IOException {
		int updatedRuns = 0;
		for (QueryPlanSnapshotComparator.SnapshotRun run : runs) {
			Map<String, String> metadata = run.snapshot().getMetadata();
			if (metadata == null || !commit.equals(normalizedOrNull(metadata.get("gitCommit")))) {
				continue;
			}
			Path snapshotPath = run.path();
			if (snapshotPath == null) {
				continue;
			}

			QueryPlanSnapshot snapshot = run.snapshot();
			java.util.LinkedHashMap<String, String> updatedMetadata = new java.util.LinkedHashMap<>(metadata);
			updatedMetadata.put("runName", newRunName);
			snapshot.setMetadata(updatedMetadata);
			capture.writeSnapshot(snapshotPath, snapshot);
			updatedRuns++;
		}
		return updatedRuns;
	}

	private void runInteractiveRunBrowser(List<QueryPlanSnapshotComparator.SnapshotRun> runs,
			QueryPlanSnapshotCliOptions.DiffMode diffMode) throws IOException {
		while (true) {
			String action = promptChoice("Browse runs", List.of("view run", "compare runs", "quit"));
			if ("view run".equals(action)) {
				int selectedIndex = promptRunSelection("Select run to view", runs);
				QueryPlanSnapshotComparator.SnapshotRun selectedRun = runs.get(selectedIndex);
				QueryPlanSnapshotComparator.printRunDetails(output, selectedRun);
				continue;
			}
			if ("compare runs".equals(action)) {
				if (runs.size() < 2) {
					output.println("Need at least two runs to compare.");
					continue;
				}

				int leftIndex = promptRunSelection("Select left run", runs);
				int rightIndex = promptRunSelection("Select right run", runs);
				if (leftIndex == rightIndex) {
					String compareSame = promptChoice("Same run selected for both sides. Continue anyway?",
							YES_NO_CHOICES);
					if ("no".equals(compareSame)) {
						continue;
					}
				}

				QueryPlanSnapshotComparator.printComparison(output, runs.get(leftIndex), runs.get(rightIndex),
						diffMode);
				return;
			}
			output.println("Browse ended.");
			return;
		}
	}

	private void compareWithLatest(Path outputDirectory, String queryId, QueryPlanSnapshot currentSnapshot,
			Path currentSnapshotPath, QueryPlanCapture capture, QueryPlanSnapshotCliOptions.DiffMode diffMode)
			throws IOException {
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> allRuns = QueryPlanSnapshotComparator
				.loadRuns(outputDirectory, capture);
		java.util.List<QueryPlanSnapshotComparator.SnapshotRun> matchingRuns = QueryPlanSnapshotComparator
				.filterRuns(allRuns, null, currentSnapshot.getUnoptimizedFingerprint(), null);
		if (matchingRuns.isEmpty()) {
			matchingRuns = QueryPlanSnapshotComparator.filterRuns(allRuns, normalizedOrNull(queryId), null, null);
		}
		QueryPlanSnapshotComparator.SnapshotRun previousRun = QueryPlanSnapshotComparator
				.latestExcludingPath(matchingRuns, currentSnapshotPath);
		if (previousRun == null) {
			output.println("No previous run found for compare-latest.");
			return;
		}

		output.println("Comparing current run against latest previous run:");
		QueryPlanSnapshotComparator.printComparison(output, previousRun,
				QueryPlanSnapshotComparator.inMemoryRun(currentSnapshot), diffMode);
	}

	private QueryPlanSnapshotCliOptions resolveRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (requiresInteractiveInput(resolved)) {
			output.println("Entering interactive mode.");
			fillMissingRunOptions(resolved);
			if (resolved.argumentCount == 0) {
				promptAllRunOptions(resolved);
			}
			promptForAssignments("System properties key=value (blank line ends section):",
					resolved.systemProperties);
			promptForAssignments("Metadata key=value (blank line ends section):", resolved.metadata);
		}
		validateRunOptions(resolved);
		return resolved;
	}

	private QueryPlanSnapshotCliOptions resolveCompareOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		QueryPlanSnapshotCliOptions resolved = options.copy();
		if (requiresInteractiveInput(resolved)) {
			output.println("Entering interactive compare mode.");
			fillMissingCompareOptions(resolved);
		}
		if (!resolved.hasComparisonFilter()) {
			throw new IllegalArgumentException(
					"Compare mode requires --query-id, --run-name, or --fingerprint (or interactive input).");
		}
		return resolved;
	}

	private static void validateRunOptions(QueryPlanSnapshotCliOptions options) {
		if (options.store == null) {
			throw new IllegalArgumentException(
					"Missing required run options. Required: --store and query selection.");
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (options.theme == null || !options.hasQueryInput()) {
			throw new IllegalArgumentException(
					"Missing required run options. Required: --store, --theme, and query input.");
		}
	}

	private void fillMissingRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		if (options.store == null) {
			options.store = promptStore();
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (!options.hasQueryInput()) {
			promptForQueryInput(options);
		}
		if (options.runAllThemeQueries) {
			return;
		}
		if (options.theme == null) {
			options.theme = promptTheme();
		}
	}

	private void fillMissingCompareOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		boolean outputDirectoryPrompted = false;
		if (!options.hasComparisonFilter()) {
			String mode = promptChoice("Compare filter", List.of("query-id", "run-name", "fingerprint"));
			if ("query-id".equals(mode)) {
				if (options.outputDirectory == null) {
					options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
					outputDirectoryPrompted = true;
				}
				Path outputDirectory = options.outputDirectory != null
						? options.outputDirectory
						: QueryPlanCapture.resolveOutputDirectory();
				List<String> availableQueryIds = loadAvailableQueryIds(outputDirectory);
				if (availableQueryIds.isEmpty()) {
					options.queryId = prompt("query-id");
				} else {
					List<String> choices = new ArrayList<>(availableQueryIds);
					choices.add(MANUAL_QUERY_ID_ENTRY);
					String selected = promptChoice("Query id", choices);
					options.queryId = MANUAL_QUERY_ID_ENTRY.equals(selected) ? prompt("query-id") : selected;
				}
			} else if ("run-name".equals(mode)) {
				if (options.outputDirectory == null) {
					options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
					outputDirectoryPrompted = true;
				}
				Path outputDirectory = options.outputDirectory != null
						? options.outputDirectory
						: QueryPlanCapture.resolveOutputDirectory();
				List<String> availableRunNames = loadAvailableRunNames(outputDirectory);
				if (availableRunNames.isEmpty()) {
					options.runName = prompt("run-name");
				} else {
					List<String> choices = new ArrayList<>(availableRunNames);
					choices.add(MANUAL_RUN_NAME_ENTRY);
					String selected = promptChoice("Run name", choices);
					options.runName = MANUAL_RUN_NAME_ENTRY.equals(selected) ? prompt("run-name") : selected;
				}
			} else {
				options.comparisonFingerprint = prompt("fingerprint");
			}
		}
		if (options.outputDirectory == null && !outputDirectoryPrompted) {
			options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
		}
		options.diffMode = promptDiffMode(options.diffMode);
		if (options.compareIndices == null) {
			String mode = promptChoice("Compare selection mode", List.of("browse runs", "enter indices"));
			if ("enter indices".equals(mode)) {
				options.compareIndices = promptComparisonPair();
			}
		}
	}

	private List<String> loadAvailableQueryIds(Path outputDirectory) throws IOException {
		QueryPlanCapture capture = new QueryPlanCapture();
		List<QueryPlanSnapshotComparator.SnapshotRun> runs = QueryPlanSnapshotComparator.loadRuns(outputDirectory,
				capture);
		Map<String, Integer> queryRunCounts = new java.util.LinkedHashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : runs) {
			String queryId = normalizedOrNull(run.snapshot().getQueryId());
			if (queryId == null) {
				continue;
			}
			queryRunCounts.merge(queryId, 1, Integer::sum);
		}
		if (queryRunCounts.isEmpty()) {
			return List.of();
		}

		output.println("Available queries:");
		queryRunCounts.forEach((queryId, count) -> output
				.println("  - " + queryId + " (" + count + " run" + (count == 1 ? "" : "s") + ")"));
		return new ArrayList<>(queryRunCounts.keySet());
	}

	private List<String> loadAvailableRunNames(Path outputDirectory) throws IOException {
		QueryPlanCapture capture = new QueryPlanCapture();
		List<QueryPlanSnapshotComparator.SnapshotRun> runs = QueryPlanSnapshotComparator.loadRuns(outputDirectory,
				capture);
		Map<String, Integer> runNameCounts = new java.util.LinkedHashMap<>();
		for (QueryPlanSnapshotComparator.SnapshotRun run : runs) {
			Map<String, String> metadata = run.snapshot().getMetadata();
			if (metadata == null) {
				continue;
			}
			String runName = normalizedOrNull(metadata.get("runName"));
			if (runName == null) {
				continue;
			}
			runNameCounts.merge(runName, 1, Integer::sum);
		}
		if (runNameCounts.isEmpty()) {
			return List.of();
		}

		output.println("Available run names:");
		runNameCounts.forEach((runName, count) -> output
				.println("  - " + runName + " (" + count + " run" + (count == 1 ? "" : "s") + ")"));
		return new ArrayList<>(runNameCounts.keySet());
	}

	private QueryPlanSnapshotCliOptions.ComparisonPair resolveComparisonPair(QueryPlanSnapshotCliOptions options,
			int runCount) throws IOException {
		if (options.compareIndices != null) {
			return options.compareIndices;
		}
		if (options.noInteractive) {
			return new QueryPlanSnapshotCliOptions.ComparisonPair(0, 1);
		}

		while (true) {
			String raw = prompt("Compare indices i,j [default 0,1]");
			if (raw.isBlank()) {
				return new QueryPlanSnapshotCliOptions.ComparisonPair(0, 1);
			}
			try {
				QueryPlanSnapshotCliOptions.ComparisonPair parsed = QueryPlanSnapshotCliOptions
						.parseComparisonPairValue(raw);
				if (parsed.leftIndex >= runCount || parsed.rightIndex >= runCount) {
					throw new IllegalArgumentException("Index out of range. Available 0-" + (runCount - 1));
				}
				return parsed;
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private String promptRequiredValue(String message) throws IOException {
		while (true) {
			String value = prompt(message);
			if (!value.isBlank()) {
				return value;
			}
			output.println(message + " cannot be blank.");
		}
	}

	private void promptForQueryInput(QueryPlanSnapshotCliOptions options) throws IOException {
		String mode = promptChoice("Query source [themed|manual|file|all-themed]",
				List.of("themed", "manual", "file", "all-themed"));
		if ("all-themed".equals(mode)) {
			options.runAllThemeQueries = true;
			options.queryIndex = null;
			options.query = null;
			options.queryFile = null;
			return;
		}
		options.runAllThemeQueries = false;
		if (options.theme == null) {
			options.theme = promptTheme();
		}
		if ("themed".equals(mode)) {
			printThemeQueries(options.theme);
			options.queryIndex = promptQueryIndex();
			options.query = null;
			options.queryFile = null;
			return;
		}
		if ("file".equals(mode)) {
			options.queryFile = promptQueryFile();
			options.query = null;
			options.queryIndex = null;
			return;
		}
		options.query = promptQueryText();
		options.queryFile = null;
		options.queryIndex = null;
	}

	private QueryPlanSnapshotCliOptions.StoreType promptStore() throws IOException {
		String value = promptChoice("Store [memory|lmdb]", List.of("memory", "lmdb"));
		return QueryPlanSnapshotCliOptions.parseStoreValue(value);
	}

	private Theme promptTheme() throws IOException {
		List<String> themes = java.util.Arrays.asList(QueryPlanSnapshotCliOptions.themeNames());
		String selectedTheme = promptChoice("Theme", themes);
		return QueryPlanSnapshotCliOptions.parseThemeValue(selectedTheme);
	}

	private int promptQueryIndex() throws IOException {
		while (true) {
			String raw = prompt("Theme query index [0-" + (ThemeQueryCatalog.QUERY_COUNT - 1) + "]");
			try {
				return QueryPlanSnapshotCliOptions.parseQueryIndexValue(raw);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private Path promptQueryFile() throws IOException {
		while (true) {
			String rawPath = prompt("Query file path");
			if (rawPath.isBlank()) {
				output.println("Query file path cannot be blank.");
				continue;
			}
			Path path = Path.of(rawPath.trim());
			if (!Files.exists(path)) {
				output.println("Query file not found: " + path.toAbsolutePath());
				continue;
			}
			return path;
		}
	}

	private String promptQueryText() throws IOException {
		output.println("Paste SPARQL query. End with line '" + QueryPlanSnapshotCliOptions.QUERY_END_SENTINEL + "'.");
		StringBuilder builder = new StringBuilder();
		while (true) {
			String line = readLine();
			if (line == null) {
				break;
			}
			if (QueryPlanSnapshotCliOptions.QUERY_END_SENTINEL.equals(line.trim())) {
				break;
			}
			builder.append(line).append('\n');
		}
		String query = builder.toString().trim();
		if (query.isBlank()) {
			throw new IllegalArgumentException("Query input was empty.");
		}
		return query;
	}

	private void promptAllRunOptions(QueryPlanSnapshotCliOptions options) throws IOException {
		options.persist = promptBoolean("Persist snapshot", options.persist);
		options.compareLatest = promptBoolean("Compare with latest previous run", options.compareLatest);
		if (options.compareLatest) {
			options.diffMode = promptDiffMode(options.diffMode);
		}
		options.queryId = promptOptionalValue("Query id (blank keeps default/auto)", options.queryId);
		options.runName = promptOptionalValue("Run name (blank keeps current)", options.runName);
		options.queryTimeoutSeconds = promptOptionalNonNegativeInteger(
				"Query timeout seconds (blank keeps current, 0 disables timeout)",
				options.queryTimeoutSeconds);
		if (options.outputDirectory == null) {
			options.outputDirectory = promptOptionalPath("Output directory (blank uses default)");
		}
		if (options.store == QueryPlanSnapshotCliOptions.StoreType.LMDB && options.lmdbDataDirectory == null) {
			options.lmdbDataDirectory = promptOptionalPath("LMDB data directory (blank uses temp)");
		}
	}

	private boolean promptBoolean(String message, boolean currentValue) throws IOException {
		List<String> choices = currentValue ? YES_NO_CHOICES : List.of("no", "yes");
		return "yes".equals(promptChoice(message, choices));
	}

	private QueryPlanSnapshotCliOptions.DiffMode promptDiffMode(QueryPlanSnapshotCliOptions.DiffMode currentValue)
			throws IOException {
		List<String> choices = currentValue == QueryPlanSnapshotCliOptions.DiffMode.STRUCTURE
				? List.of("structure", "structure+estimates")
				: List.of("structure+estimates", "structure");
		String selected = promptChoice("Diff mode", choices);
		return QueryPlanSnapshotCliOptions.parseDiffModeValue(selected);
	}

	private QueryPlanSnapshotCliOptions.ComparisonPair promptComparisonPair() throws IOException {
		while (true) {
			String raw = prompt("Compare indices i,j");
			try {
				return QueryPlanSnapshotCliOptions.parseComparisonPairValue(raw);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private String promptOptionalValue(String message, String currentValue) throws IOException {
		String suffix = currentValue == null || currentValue.isBlank()
				? ""
				: " [current=" + currentValue + "]";
		String raw = prompt(message + suffix);
		if (raw.isBlank()) {
			return currentValue;
		}
		return raw;
	}

	private Path promptOptionalPath(String message) throws IOException {
		String raw = prompt(message);
		if (raw.isBlank()) {
			return null;
		}
		return Path.of(raw.trim());
	}

	private Integer promptOptionalNonNegativeInteger(String message, Integer currentValue) throws IOException {
		while (true) {
			String raw = prompt(message);
			if (raw.isBlank()) {
				return currentValue;
			}
			try {
				return QueryPlanSnapshotCliOptions.parseNonNegativeInteger(raw, message);
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private void promptForAssignments(String heading, Map<String, String> target) throws IOException {
		output.println(heading);
		while (true) {
			String line = prompt("  key=value");
			if (line.isBlank()) {
				return;
			}
			try {
				QueryPlanSnapshotCliOptions.Assignment assignment = QueryPlanSnapshotCliOptions.parseAssignment(line,
						heading);
				target.put(assignment.getKey(), assignment.getValue());
			} catch (IllegalArgumentException e) {
				output.println(e.getMessage());
			}
		}
	}

	private String prompt(String message) throws IOException {
		return promptRaw(message).trim();
	}

	private String promptRaw(String message) throws IOException {
		output.print(message + ": ");
		output.flush();
		String line = readLine();
		if (line == null) {
			throw new IllegalStateException(
					"No interactive input available. Pass --no-interactive or complete args.");
		}
		return line;
	}

	private String readLine() throws IOException {
		return input.readLine();
	}

	private String promptChoice(String message, List<String> options) throws IOException {
		int selectedIndex = promptChoiceIndex(message, options);
		return options.get(selectedIndex);
	}

	private int promptChoiceIndex(String message, List<String> options) throws IOException {
		Objects.requireNonNull(options, "options");
		if (options.isEmpty()) {
			throw new IllegalArgumentException("No choices available for " + message);
		}
		if (jLineChoiceMenu != null) {
			Integer selected = jLineChoiceMenu.promptChoiceIndex(message, options);
			if (selected != null) {
				output.println(message + ": " + options.get(selected));
				return selected;
			}
		}
		return promptChoiceIndexFallback(message, options);
	}

	private int promptChoiceIndexFallback(String message, List<String> options) throws IOException {

		output.println(message + ":");
		for (int i = 0; i < options.size(); i++) {
			output.println("  [" + (i + 1) + "] " + options.get(i));
		}
		output.println("Type number/value. Enter chooses [1]. (Arrow keys unavailable in fallback mode.)");

		while (true) {
			String rawValue = promptRaw("Select");
			if (rawValue.isBlank()) {
				return 0;
			}

			int arrowSelected = resolveArrowSelection(rawValue, options.size());
			if (arrowSelected >= 0) {
				return arrowSelected;
			}

			String candidate = rawValue.trim();
			try {
				int numeric = Integer.parseInt(candidate);
				if (numeric >= 1 && numeric <= options.size()) {
					return numeric - 1;
				}
			} catch (NumberFormatException ignored) {
				// fall through to textual matching
			}

			for (int i = 0; i < options.size(); i++) {
				if (options.get(i).equalsIgnoreCase(candidate)) {
					return i;
				}
			}

			output.println("Invalid selection '" + candidate + "'. Choose one of the listed options.");
		}
	}

	private static int resolveArrowSelection(String rawValue, int optionCount) {
		int currentIndex = 0;
		boolean moved = false;
		for (int i = 0; i < rawValue.length(); i++) {
			char c = rawValue.charAt(i);
			if (c != ESCAPE || i + 2 >= rawValue.length() || rawValue.charAt(i + 1) != '[') {
				continue;
			}

			char code = rawValue.charAt(i + 2);
			if (code == 'A' || code == 'D') {
				currentIndex = (currentIndex - 1 + optionCount) % optionCount;
				moved = true;
				i += 2;
				continue;
			}
			if (code == 'B' || code == 'C') {
				currentIndex = (currentIndex + 1) % optionCount;
				moved = true;
				i += 2;
			}
		}

		return moved ? currentIndex : -1;
	}

	private int promptRunSelection(String message, List<QueryPlanSnapshotComparator.SnapshotRun> runs)
			throws IOException {
		List<String> choices = new ArrayList<>(runs.size());
		for (int i = 0; i < runs.size(); i++) {
			QueryPlanSnapshotComparator.SnapshotRun run = runs.get(i);
			QueryPlanSnapshot snapshot = run.snapshot();
			String capturedAt = snapshot.getCapturedAt();
			String queryId = snapshot.getQueryId();
			String runName = snapshot.getMetadata() == null ? null : snapshot.getMetadata().get("runName");
			String fingerprint = snapshot.getUnoptimizedFingerprint();
			choices.add(capturedAt + " queryId=" + queryId + " runName=" + formatRunName(runName)
					+ " fingerprint=" + fingerprint);
		}
		return promptChoiceIndex(message, choices);
	}

	private void printThemes() {
		output.println("Themes:");
		for (String themeName : QueryPlanSnapshotCliOptions.themeNames()) {
			output.println("  - " + themeName);
		}
	}

	private void printThemeQueries(Theme theme) {
		output.println("Theme queries for " + theme + ":");
		for (int i = 0; i < ThemeQueryCatalog.QUERY_COUNT; i++) {
			BenchmarkQuery query = ThemeQueryCatalog.benchmarkQueryFor(theme, i);
			output.println("  " + i + ": " + query.getName());
		}
	}

	private void printThemeDataLoadStatus(QueryPlanSnapshotStoreSupport.ThemeDataLoadStatus themeDataLoadStatus) {
		if (themeDataLoadStatus.lmdbFullyLoadedSizeBytes == null) {
			return;
		}
		if (themeDataLoadStatus.reusedLmdbData) {
			output.println("LMDB data already fully loaded (" + themeDataLoadStatus.lmdbFullyLoadedSizeBytes
					+ " bytes). Skipping reload.");
			return;
		}
		output.println("LMDB data loaded. Recorded fully-loaded size=" + themeDataLoadStatus.lmdbFullyLoadedSizeBytes
				+ " bytes.");
	}

	private static QueryPlanCaptureContext createContext(QueryPlanSnapshotCliOptions options,
			BenchmarkQuery benchmarkQuery,
			String queryText, String querySource, String queryId, Path outputDirectory,
			FeatureFlagCollector featureFlags) {
		QueryPlanCaptureContext.Builder contextBuilder = QueryPlanCaptureContext.builder()
				.outputDirectory(outputDirectory)
				.queryId(queryId)
				.queryString(queryText)
				.benchmark("QueryPlanSnapshotCli")
				.levels(List.of(Explanation.Level.Unoptimized, Explanation.Level.Optimized,
						Explanation.Level.Telemetry))
				.irRenderedLevels(Set.of(Explanation.Level.Optimized, Explanation.Level.Telemetry))
				.addMetadata("store", options.store.id)
				.addMetadata("theme", options.theme.name())
				.addMetadata("querySource", querySource)
				.addMetadata(options.metadata)
				.addMetadata(QueryPlanCapture.metadataFromSystemProperties())
				.featureFlagCollector(featureFlags)
				.tupleExprRenderer(QueryPlanSnapshotCli::renderTupleExprWithIr);
		if (options.runName != null && !options.runName.isBlank()) {
			contextBuilder.addMetadata("runName", options.runName);
		}
		if (options.queryTimeoutSeconds != null) {
			contextBuilder.addMetadata("queryTimeoutSeconds", options.queryTimeoutSeconds.toString());
		}

		if (options.queryIndex != null && benchmarkQuery != null) {
			contextBuilder.addMetadata("queryIndex", Integer.toString(options.queryIndex))
					.addMetadata("queryName", benchmarkQuery.getName())
					.addMetadata("expectedCount", Long.toString(benchmarkQuery.getExpectedCount()));
		}

		return contextBuilder.build();
	}

	private static FeatureFlagCollector createFeatureFlagCollector(QueryPlanSnapshotCliOptions options,
			QueryPlanSnapshotStoreSupport.StoreRuntime storeRuntime, String querySource,
			QueryPlanSnapshotStoreSupport.ThemeDataLoadStatus themeDataLoadStatus) {
		FeatureFlagCollector featureFlags = new FeatureFlagCollector()
				.addValue("cli.store", options.store.id)
				.addValue("cli.theme", options.theme.name())
				.addValue("cli.querySource", querySource)
				.addValue("cli.persist", Boolean.toString(options.persist))
				.addValue("cli.runName",
						options.runName == null || options.runName.isBlank() ? "<none>" : options.runName)
				.addValue("cli.queryTimeoutSeconds", formatQueryTimeoutSeconds(options.queryTimeoutSeconds))
				.addValue("cli.executionRepeatMinRuns", Integer.toString(resolveExecutionRepeatMinRuns(options)))
				.addValue("cli.executionRepeatMaxRuns", Integer.toString(resolveExecutionRepeatMaxRuns(options)))
				.addValue("cli.executionRepeatSoftLimitMillis",
						Long.toString(TimeUnit.NANOSECONDS.toMillis(resolveExecutionRepeatSoftLimitNanos(options))));
		if (options.queryIndex != null) {
			featureFlags.addValue("cli.queryIndex", options.queryIndex.toString());
		}
		options.systemProperties.forEach((name, value) -> featureFlags.addValue("systemProperty." + name, value));

		if (storeRuntime.memoryStore != null) {
			featureFlags.addReflectiveGetter("memoryStore.persist", storeRuntime.memoryStore, "getPersist")
					.addReflectiveGetter("memoryStore.syncDelay", storeRuntime.memoryStore, "getSyncDelay")
					.addReflectiveGetter("memoryStore.iterationCacheSyncThreshold", storeRuntime.memoryStore,
							"getIterationCacheSyncThreshold");
		}

		if (storeRuntime.lmdbStore != null) {
			featureFlags.addReflectiveGetter("lmdbStore.writable", storeRuntime.lmdbStore, "isWritable")
					.addReflectiveGetter("lmdbConfig.tripleIndexes", storeRuntime.lmdbStoreConfig, "getTripleIndexes")
					.addReflectiveGetter("lmdbConfig.forceSync", storeRuntime.lmdbStoreConfig, "getForceSync")
					.addReflectiveGetter("lmdbConfig.pageCardinalityEstimator", storeRuntime.lmdbStoreConfig,
							"getPageCardinalityEstimator")
					.addReflectiveField("lmdbConfig.autoGrow", storeRuntime.lmdbStoreConfig, "autoGrow")
					.addReflectiveGetter("lmdbConfig.valueDbSize", storeRuntime.lmdbStoreConfig, "getValueDBSize")
					.addReflectiveGetter("lmdbConfig.tripleDbSize", storeRuntime.lmdbStoreConfig, "getTripleDBSize");
			if (themeDataLoadStatus.lmdbFullyLoadedSizeBytes != null) {
				featureFlags.addValue("lmdbData.fullyLoadedSizeBytes",
						themeDataLoadStatus.lmdbFullyLoadedSizeBytes.toString());
			}
			featureFlags.addValue("lmdbData.reusedWithoutReload", Boolean.toString(themeDataLoadStatus.reusedLmdbData));
		}

		QueryPlanCapture.registerConfiguredFeatureFlags(featureFlags);
		return featureFlags;
	}

	private static String defaultQueryId(QueryPlanSnapshotCliOptions options, BenchmarkQuery benchmarkQuery) {
		if (options.queryIndex != null && benchmarkQuery != null) {
			return options.store.id + "-" + options.theme.name().toLowerCase(java.util.Locale.ROOT) + "-q"
					+ options.queryIndex;
		}
		return options.store.id + "-" + options.theme.name().toLowerCase(java.util.Locale.ROOT) + "-manual";
	}

	private static Path defaultOutputDirectory(QueryPlanSnapshotCliOptions.StoreType storeType) {
		return QueryPlanCapture.resolveOutputDirectory().resolve("cli").resolve(storeType.id);
	}

	private static BenchmarkQuery resolveBenchmarkQuery(QueryPlanSnapshotCliOptions options) {
		if (options.queryIndex == null) {
			return null;
		}
		return ThemeQueryCatalog.benchmarkQueryFor(options.theme, options.queryIndex);
	}

	private static String resolveQueryText(QueryPlanSnapshotCliOptions options, BenchmarkQuery benchmarkQuery)
			throws IOException {
		if (benchmarkQuery != null) {
			return benchmarkQuery.getQuery();
		}
		if (options.query != null && !options.query.isBlank()) {
			return options.query;
		}
		if (options.queryFile != null) {
			String loaded = Files.readString(options.queryFile, StandardCharsets.UTF_8).trim();
			if (!loaded.isBlank()) {
				return loaded;
			}
		}
		throw new IllegalArgumentException("No query text resolved. Provide --query, --query-file, or --query-index.");
	}

	private static void applySystemProperties(Map<String, String> systemProperties) {
		systemProperties.forEach(System::setProperty);
	}

	private static String renderTupleExprWithIr(org.eclipse.rdf4j.query.algebra.TupleExpr tupleExpr) {
		TupleExprIRRenderer.Config config = new TupleExprIRRenderer.Config();
		config.verifyRoundTrip = false;
		return new TupleExprIRRenderer(config).render(tupleExpr);
	}

	private static String normalizedOrNull(String value) {
		if (value == null) {
			return null;
		}
		String normalized = value.trim();
		return normalized.isEmpty() ? null : normalized;
	}

	private static String formatLocalTime(String capturedAt) {
		if (capturedAt == null || capturedAt.isBlank()) {
			return UNKNOWN_VALUE;
		}
		try {
			return LOCAL_TIME_FORMATTER.format(Instant.parse(capturedAt).atZone(LOCAL_ZONE));
		} catch (Exception ignored) {
			return capturedAt;
		}
	}

	private static String formatLocalTime(long epochMillis) {
		if (epochMillis <= 0L) {
			return UNKNOWN_VALUE;
		}
		return LOCAL_TIME_FORMATTER.format(Instant.ofEpochMilli(epochMillis).atZone(LOCAL_ZONE));
	}

	private static String formatDurationMillis(long durationMillis) {
		if (durationMillis < 0L) {
			return UNKNOWN_VALUE;
		}
		long totalSeconds = TimeUnit.MILLISECONDS.toSeconds(durationMillis);
		long hours = totalSeconds / 3600L;
		long minutes = (totalSeconds % 3600L) / 60L;
		long seconds = totalSeconds % 60L;
		return String.format(Locale.ROOT, "%02d:%02d:%02d", hours, minutes, seconds);
	}

	private static long toEpochMillis(String capturedAt) {
		if (capturedAt == null || capturedAt.isBlank()) {
			return Long.MIN_VALUE;
		}
		try {
			return Instant.parse(capturedAt).toEpochMilli();
		} catch (Exception ignored) {
			return Long.MIN_VALUE;
		}
	}

	private static String formatQueryTimeoutSeconds(Integer queryTimeoutSeconds) {
		if (queryTimeoutSeconds == null || queryTimeoutSeconds == 0) {
			return "<none>";
		}
		return queryTimeoutSeconds.toString();
	}

	private static void applySnapshotPlanDebugMetadata(QueryPlanSnapshot snapshot) {
		if (snapshot == null) {
			return;
		}
		LinkedHashMap<String, String> metadata = new LinkedHashMap<>();
		if (snapshot.getMetadata() != null) {
			metadata.putAll(snapshot.getMetadata());
		}

		String queryString = snapshot.getQueryString();
		if (queryString != null) {
			metadata.putIfAbsent("queryString.charCount", Integer.toString(queryString.length()));
			metadata.putIfAbsent("queryString.lineCount", Integer.toString(countLines(queryString)));
		}
		metadata.putIfAbsent("runtime.javaVendor", System.getProperty("java.vendor", UNKNOWN_VALUE));
		metadata.putIfAbsent("runtime.javaVmName", System.getProperty("java.vm.name", UNKNOWN_VALUE));
		metadata.putIfAbsent("runtime.osName", System.getProperty("os.name", UNKNOWN_VALUE));
		metadata.putIfAbsent("runtime.osVersion", System.getProperty("os.version", UNKNOWN_VALUE));
		metadata.putIfAbsent("runtime.osArch", System.getProperty("os.arch", UNKNOWN_VALUE));
		metadata.putIfAbsent("runtime.availableProcessors",
				Integer.toString(Runtime.getRuntime().availableProcessors()));
		metadata.putIfAbsent("runtime.maxMemoryBytes", Long.toString(Runtime.getRuntime().maxMemory()));
		metadata.putIfAbsent("runtime.timeZone", ZoneId.systemDefault().getId());

		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "rootTypeNormalized",
				"optimizerInput.unoptimizedRootTypeNormalized");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "planNodeCount",
				"optimizerInput.unoptimizedPlanNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "joinNodeCount",
				"optimizerInput.unoptimizedJoinNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "filterNodeCount",
				"optimizerInput.unoptimizedFilterNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "statementPatternCount",
				"optimizerInput.unoptimizedStatementPatternCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "joinAlgorithmCounts",
				"optimizerInput.unoptimizedJoinAlgorithmCounts");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "structureSignatureNormalizedSha256",
				"optimizerInput.unoptimizedStructureNormalizedSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized", "estimatesMultisetSignatureSha256",
				"optimizerInput.unoptimizedEstimatesMultisetSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "unoptimized",
				"statementPatternEstimatesMultisetSignatureSha256",
				"optimizerInput.unoptimizedStatementPatternEstimatesMultisetSignatureSha256");

		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "rootTypeNormalized",
				"optimizerOutput.optimizedRootTypeNormalized");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "planNodeCount",
				"optimizerOutput.optimizedPlanNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "joinNodeCount",
				"optimizerOutput.optimizedJoinNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "filterNodeCount",
				"optimizerOutput.optimizedFilterNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "statementPatternCount",
				"optimizerOutput.optimizedStatementPatternCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "joinAlgorithmCounts",
				"optimizerOutput.optimizedJoinAlgorithmCounts");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "structureSignatureNormalizedSha256",
				"optimizerOutput.optimizedStructureNormalizedSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized", "estimatesMultisetSignatureSha256",
				"optimizerOutput.optimizedEstimatesMultisetSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "optimized",
				"statementPatternEstimatesMultisetSignatureSha256",
				"optimizerOutput.optimizedStatementPatternEstimatesMultisetSignatureSha256");

		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "rootTypeNormalized",
				"executionPlan.executedRootTypeNormalized");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "planNodeCount",
				"executionPlan.executedPlanNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "joinNodeCount",
				"executionPlan.executedJoinNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "filterNodeCount",
				"executionPlan.executedFilterNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "statementPatternCount",
				"executionPlan.executedStatementPatternCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "joinAlgorithmCounts",
				"executionPlan.executedJoinAlgorithmCounts");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "structureSignatureNormalizedSha256",
				"executionPlan.executedStructureNormalizedSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "estimatesMultisetSignatureSha256",
				"executionPlan.executedEstimatesMultisetSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry",
				"statementPatternEstimatesMultisetSignatureSha256",
				"executionPlan.executedStatementPatternEstimatesMultisetSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledWorkUnits",
				"executionPlan.executedModeledWorkUnits");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledInputRowsSum",
				"executionPlan.executedModeledInputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledOutputRowsSum",
				"executionPlan.executedModeledOutputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledSelfTimeActualSum",
				"executionPlan.executedModeledSelfTimeActualSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledTotalTimeActualSum",
				"executionPlan.executedModeledTotalTimeActualSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledBarrierCount",
				"executionPlan.executedModeledBarrierCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinInputRowsSum",
				"executionPlan.executedModeledJoinInputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinOutputRowsSum",
				"executionPlan.executedModeledJoinOutputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledFilterInputRowsSum",
				"executionPlan.executedModeledFilterInputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledFilterOutputRowsSum",
				"executionPlan.executedModeledFilterOutputRowsSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledFilterPassRatio",
				"executionPlan.executedModeledFilterPassRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledFilterRejectRatio",
				"executionPlan.executedModeledFilterRejectRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledWorkByCategory",
				"executionPlan.executedModeledWorkByCategory");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledOperatorCountByCategory",
				"executionPlan.executedModeledOperatorCountByCategory");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledInputRowsByCategory",
				"executionPlan.executedModeledInputRowsByCategory");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledOutputRowsByCategory",
				"executionPlan.executedModeledOutputRowsByCategory");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinWorkByAlgorithm",
				"executionPlan.executedModeledJoinWorkByAlgorithm");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledWorkVector",
				"executionPlan.executedModeledWorkVector");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledWorkVectorSignatureSha256",
				"executionPlan.executedModeledWorkVectorSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "operatorWorkBreakdownSignatureSha256",
				"executionPlan.executedOperatorWorkBreakdownSignatureSha256");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "operatorWorkTopContributors",
				"executionPlan.executedOperatorWorkTopContributors");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "estimateActualComparableNodeCount",
				"executionPlan.executedEstimateActualComparableNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledHasNextCallCountSum",
				"executionPlan.executedHasNextCallCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledHasNextTrueCountSum",
				"executionPlan.executedHasNextTrueCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledHasNextTimeNanosSum",
				"executionPlan.executedHasNextTimeNanosSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledNextCallCountSum",
				"executionPlan.executedNextCallCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledNextTimeNanosSum",
				"executionPlan.executedNextTimeNanosSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinRightIteratorCreateCountSum",
				"executionPlan.executedJoinRightIteratorCreateCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinLeftBindingSetConsumedCountSum",
				"executionPlan.executedJoinLeftBindingSetConsumedCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinRightBindingSetConsumedCountSum",
				"executionPlan.executedJoinRightBindingSetConsumedCountSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinRightBindingsPerLeftRatio",
				"executionPlan.executedJoinRightBindingsPerLeftRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledJoinTelemetryNodeCount",
				"executionPlan.executedJoinTelemetryNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry",
				"modeledJoinRightBindingSetConsumedPerRightIteratorAverage",
				"executionPlan.executedJoinRightBindingSetConsumedPerRightIteratorAverage");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry",
				"modeledJoinRightIteratorCreatePerJoinNodeAverage",
				"executionPlan.executedJoinRightIteratorCreatePerJoinNodeAverage");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry",
				"modeledJoinLeftBindingSetConsumedPerJoinNodeAverage",
				"executionPlan.executedJoinLeftBindingSetConsumedPerJoinNodeAverage");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry",
				"modeledJoinRightBindingSetConsumedPerJoinNodeAverage",
				"executionPlan.executedJoinRightBindingSetConsumedPerJoinNodeAverage");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledSourceRowsScannedSum",
				"executionPlan.executedSourceRowsScannedSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledSourceRowsMatchedSum",
				"executionPlan.executedSourceRowsMatchedSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledSourceRowsFilteredSum",
				"executionPlan.executedSourceRowsFilteredSum");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledSourceFilterOutRatio",
				"executionPlan.executedSourceFilterOutRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledHasNextPerNextRatio",
				"executionPlan.executedHasNextPerNextRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "modeledHasNextTruePerNextRatio",
				"executionPlan.executedHasNextTruePerNextRatio");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "estimateActualQErrorP95",
				"executionPlan.executedEstimateActualQErrorP95");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "estimateActualQErrorMax",
				"executionPlan.executedEstimateActualQErrorMax");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "joinEstimateActualComparableNodeCount",
				"executionPlan.executedJoinEstimateActualComparableNodeCount");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "joinEstimateActualQErrorP95",
				"executionPlan.executedJoinEstimateActualQErrorP95");
		copyLevelDebugMetricToMetadata(snapshot, metadata, "telemetry", "joinEstimateActualQErrorMax",
				"executionPlan.executedJoinEstimateActualQErrorMax");

		Map<String, String> featureFlags = snapshot.getFeatureFlags();
		String featureFlagsFingerprint = mapFingerprintSha256(featureFlags, null);
		metadata.put("featureFlags.sha256", featureFlagsFingerprint);
		metadata.put("planDeterminism.inputFingerprintSha256", buildPlanInputFingerprint(metadata, featureFlags));
		metadata.put("planDeterminism.environmentFingerprintSha256",
				buildEnvironmentFingerprint(metadata, featureFlagsFingerprint));

		snapshot.setMetadata(metadata);
	}

	private static int countLines(String value) {
		if (value == null || value.isEmpty()) {
			return 0;
		}
		int lines = 1;
		for (int i = 0; i < value.length(); i++) {
			if (value.charAt(i) == '\n') {
				lines++;
			}
		}
		return lines;
	}

	private static void copyLevelDebugMetricToMetadata(QueryPlanSnapshot snapshot, Map<String, String> metadata,
			String level, String debugMetricKey, String metadataKey) {
		String value = explanationDebugMetric(snapshot, level, debugMetricKey);
		if (value == null || value.isBlank()) {
			return;
		}
		metadata.putIfAbsent(metadataKey, value);
	}

	private static String buildPlanInputFingerprint(Map<String, String> metadata, Map<String, String> featureFlags) {
		StringBuilder fingerprint = new StringBuilder();
		appendFingerprintField(fingerprint, "queryString.normalizedWhitespaceSha256",
				metadata.get("queryString.normalizedWhitespaceSha256"));
		appendFingerprintField(fingerprint, "optimizerInput.unoptimizedStructureNormalizedSha256",
				metadata.get("optimizerInput.unoptimizedStructureNormalizedSha256"));
		appendFingerprintField(fingerprint, "store", metadata.get("store"));
		appendFingerprintField(fingerprint, "theme", metadata.get("theme"));
		appendFingerprintField(fingerprint, "querySource", metadata.get("querySource"));
		appendFingerprintField(fingerprint, "queryTimeoutSeconds", metadata.get("queryTimeoutSeconds"));
		appendFingerprintField(fingerprint, "featureFlags.optimizerInputSubsetSha256",
				mapFingerprintSha256(featureFlags, PLAN_INPUT_FEATURE_FLAG_PREFIXES));
		return sha256Hex(fingerprint.toString());
	}

	private static String buildEnvironmentFingerprint(Map<String, String> metadata, String featureFlagsFingerprint) {
		StringBuilder fingerprint = new StringBuilder();
		appendFingerprintField(fingerprint, "gitCommit", metadata.get("gitCommit"));
		appendFingerprintField(fingerprint, "gitBranch", metadata.get("gitBranch"));
		appendFingerprintField(fingerprint, "javaVersion", metadata.get("javaVersion"));
		appendFingerprintField(fingerprint, "runtime.javaVendor", metadata.get("runtime.javaVendor"));
		appendFingerprintField(fingerprint, "runtime.javaVmName", metadata.get("runtime.javaVmName"));
		appendFingerprintField(fingerprint, "runtime.osName", metadata.get("runtime.osName"));
		appendFingerprintField(fingerprint, "runtime.osVersion", metadata.get("runtime.osVersion"));
		appendFingerprintField(fingerprint, "runtime.osArch", metadata.get("runtime.osArch"));
		appendFingerprintField(fingerprint, "runtime.availableProcessors",
				metadata.get("runtime.availableProcessors"));
		appendFingerprintField(fingerprint, "runtime.maxMemoryBytes", metadata.get("runtime.maxMemoryBytes"));
		appendFingerprintField(fingerprint, "runtime.timeZone", metadata.get("runtime.timeZone"));
		appendFingerprintField(fingerprint, "featureFlags.sha256", featureFlagsFingerprint);
		return sha256Hex(fingerprint.toString());
	}

	private static void appendFingerprintField(StringBuilder fingerprint, String key, String value) {
		if (fingerprint.length() > 0) {
			fingerprint.append('\n');
		}
		fingerprint.append(key).append('=').append(value == null ? "<null>" : value);
	}

	private static String mapFingerprintSha256(Map<String, String> values, List<String> includePrefixes) {
		if (values == null || values.isEmpty()) {
			return sha256Hex("<empty>");
		}
		ArrayList<String> entries = new ArrayList<>();
		for (Map.Entry<String, String> entry : values.entrySet()) {
			String key = entry.getKey() == null ? "<null>" : entry.getKey();
			if (includePrefixes != null && !includePrefixes.isEmpty() && !matchesAnyPrefix(key, includePrefixes)) {
				continue;
			}
			String value = entry.getValue() == null ? "<null>" : entry.getValue();
			entries.add(key + "=" + value);
		}
		if (entries.isEmpty()) {
			return sha256Hex("<empty>");
		}
		Collections.sort(entries);
		return sha256Hex(String.join("\n", entries));
	}

	private static boolean matchesAnyPrefix(String key, List<String> prefixes) {
		for (String prefix : prefixes) {
			if (key.startsWith(prefix)) {
				return true;
			}
		}
		return false;
	}

	private static String sha256Hex(String input) {
		try {
			MessageDigest digest = MessageDigest.getInstance("SHA-256");
			byte[] bytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));
			StringBuilder hex = new StringBuilder(bytes.length * 2);
			for (byte value : bytes) {
				hex.append(String.format("%02x", value));
			}
			return hex.toString();
		} catch (NoSuchAlgorithmException e) {
			throw new IllegalStateException("SHA-256 unavailable", e);
		}
	}

	private static int validateExecutionRepeatMinRuns(int minRuns) {
		if (minRuns < 1) {
			throw new IllegalArgumentException("executionRepeatMinRuns must be >= 1.");
		}
		return minRuns;
	}

	private static int validateExecutionRepeatMaxRuns(int maxRuns) {
		if (maxRuns < 1) {
			throw new IllegalArgumentException("executionRepeatMaxRuns must be >= 1.");
		}
		return maxRuns;
	}

	private static long validateExecutionRepeatSoftLimitNanos(long softLimitNanos) {
		if (softLimitNanos < 1L) {
			throw new IllegalArgumentException("executionRepeatSoftLimitNanos must be >= 1.");
		}
		return softLimitNanos;
	}

	private static int resolveExecutionRepeatMinRuns(QueryPlanSnapshotCliOptions options) {
		return options.executionRepeatMinRuns == null
				? DEFAULT_EXECUTION_REPEAT_MIN_RUNS
				: options.executionRepeatMinRuns;
	}

	private static int resolveExecutionRepeatMaxRuns(QueryPlanSnapshotCliOptions options) {
		return options.executionRepeatMaxRuns == null
				? DEFAULT_EXECUTION_REPEAT_MAX_RUNS
				: options.executionRepeatMaxRuns;
	}

	private static long resolveExecutionRepeatSoftLimitNanos(QueryPlanSnapshotCliOptions options) {
		return options.executionRepeatSoftLimitMillis == null
				? DEFAULT_EXECUTION_REPEAT_SOFT_LIMIT_NANOS
				: TimeUnit.MILLISECONDS.toNanos(options.executionRepeatSoftLimitMillis);
	}

	private static long validateBatchEtaUpdateIntervalNanos(long batchEtaUpdateIntervalNanos) {
		if (batchEtaUpdateIntervalNanos < 1L) {
			throw new IllegalArgumentException("batchEtaUpdateIntervalNanos must be >= 1.");
		}
		return batchEtaUpdateIntervalNanos;
	}

	private static TupleQuery prepareTupleQuery(SailRepositoryConnection connection, String queryText,
			Integer queryTimeoutSeconds) {
		TupleQuery tupleQuery = connection.prepareTupleQuery(queryText);
		if (queryTimeoutSeconds != null && queryTimeoutSeconds > 0) {
			tupleQuery.setMaxExecutionTime(queryTimeoutSeconds);
		}
		return tupleQuery;
	}

	private void printPrettyExplanations(QueryPlanSnapshot snapshot) {
		Map<String, QueryPlanExplanation> explanations = snapshot.getExplanations();
		if (explanations == null || explanations.isEmpty()) {
			output.println("No query explanations captured.");
			return;
		}

		LinkedHashSet<String> orderedLevels = new LinkedHashSet<>(EXPLANATION_LEVEL_ORDER);
		orderedLevels.addAll(explanations.keySet());
		for (String levelKey : orderedLevels) {
			QueryPlanExplanation explanation = explanations.get(levelKey);
			if (explanation == null) {
				continue;
			}
			printExplanation(levelKey, explanation);
		}
	}

	private void printResultsSection(QueryPlanSnapshotCliOptions options, String queryId, String queryText) {
		output.println("=== Results ===");
		output.println("Original query:");
		output.println(queryText.trim());
		output.println("Store=" + options.store.id + ", Theme=" + options.theme + ", QueryId=" + queryId
				+ ", RunName=" + formatRunName(options.runName)
				+ ", QueryTimeoutSeconds=" + formatQueryTimeoutSeconds(options.queryTimeoutSeconds));
	}

	private static String formatRunName(String runName) {
		if (runName == null || runName.isBlank()) {
			return "<none>";
		}
		return runName;
	}

	private void printExplanation(String levelKey, QueryPlanExplanation explanation) {
		String levelName = explanation.getLevel();
		if (levelName == null || levelName.isBlank()) {
			levelName = levelKey;
		}
		String label = levelName.substring(0, 1).toUpperCase(Locale.ROOT)
				+ levelName.substring(1).toLowerCase(Locale.ROOT);

		output.println();
		output.println("=== " + label + " Explanation ===");
		String explanationText = explanation.getExplanationText();
		if (explanationText == null || explanationText.isBlank()) {
			output.println("(no explanation text)");
		} else {
			output.println(explanationText.trim());
		}

		String renderedQuery = explanation.getIrRenderedQuery();
		if (renderedQuery != null && !renderedQuery.isBlank()) {
			output.println("--- IR Rendered Query ---");
			output.println(renderedQuery.trim());
		}
	}

	private QueryExecutionVerification verifyRepeatedExecution(SailRepositoryConnection connection, String queryText,
			Integer queryTimeoutSeconds) {
		long elapsedNanos = 0;
		long stableResultCount = Long.MIN_VALUE;
		int runs = 0;
		boolean softLimitReached = false;
		long minRunNanos = Long.MAX_VALUE;
		long maxRunNanos = Long.MIN_VALUE;
		ArrayList<Long> runDurationsNanos = new ArrayList<>();
		ArrayList<String> optimizedPlanSignatureSequence = new ArrayList<>();
		LinkedHashSet<String> optimizedPlanSignatures = new LinkedHashSet<>();
		VerificationFailure failure = null;

		while (runs < executionRepeatMaxRuns) {
			if (runs >= executionRepeatMinRuns) {
				long averageNanos = Math.max(1L, elapsedNanos / runs);
				if (elapsedNanos + averageNanos > executionRepeatSoftLimitNanos) {
					softLimitReached = true;
					break;
				}
			} else if (elapsedNanos >= executionRepeatSoftLimitNanos) {
				softLimitReached = true;
				break;
			}

			TupleQuery tupleQuery = prepareTupleQuery(connection, queryText, queryTimeoutSeconds);
			String optimizedPlanSignature = optimizedPlanSignature(tupleQuery);
			optimizedPlanSignatureSequence.add(optimizedPlanSignature);
			optimizedPlanSignatures.add(optimizedPlanSignature);
			long startedAt = System.nanoTime();
			long currentResultCount;
			try {
				try (TupleQueryResult result = tupleQuery.evaluate()) {
					currentResultCount = result.stream().count();
				}
			} catch (QueryInterruptedException interrupted) {
				softLimitReached = true;
				failure = VerificationFailure.interrupted(runs + 1, optimizedPlanSignature, interrupted);
				break;
			} catch (Exception evaluationError) {
				failure = VerificationFailure.error(runs + 1, optimizedPlanSignature, evaluationError);
				break;
			}

			long runNanos = Math.max(1L, System.nanoTime() - startedAt);
			elapsedNanos += runNanos;
			runs++;
			minRunNanos = Math.min(minRunNanos, runNanos);
			maxRunNanos = Math.max(maxRunNanos, runNanos);
			runDurationsNanos.add(runNanos);

			if (stableResultCount == Long.MIN_VALUE) {
				stableResultCount = currentResultCount;
			} else if (stableResultCount != currentResultCount) {
				failure = VerificationFailure.resultCountChanged(runs, stableResultCount, currentResultCount,
						optimizedPlanSignature);
				break;
			}
		}

		boolean maxRunsReached = runs >= executionRepeatMaxRuns;
		if (runs == 0) {
			return new QueryExecutionVerification(0, 0, 0, softLimitReached, maxRunsReached, 0, 0, List.of(),
					List.copyOf(optimizedPlanSignatures), List.copyOf(optimizedPlanSignatureSequence), failure);
		}

		return new QueryExecutionVerification(runs, elapsedNanos, stableResultCount, softLimitReached,
				maxRunsReached, minRunNanos, maxRunNanos, List.copyOf(runDurationsNanos),
				List.copyOf(optimizedPlanSignatures), List.copyOf(optimizedPlanSignatureSequence), failure);
	}

	private static String optimizedPlanSignature(TupleQuery tupleQuery) {
		try {
			Explanation explanation = tupleQuery.explain(Explanation.Level.Optimized);
			if (explanation == null) {
				return "missing-explanation";
			}
			Map<String, String> metrics = QueryPlanCapture.extractDebugMetrics(explanation.toJson());
			String structure = metricOrMissing(metrics, "structureSignatureNormalizedSha256");
			String estimates = metricOrMissing(metrics, "estimatesMultisetSignatureSha256");
			String statementPatterns = metricOrMissing(metrics, "statementPatternEstimatesMultisetSignatureSha256");
			return structure + "|" + estimates + "|" + statementPatterns;
		} catch (Exception e) {
			return "error:" + e.getClass().getSimpleName();
		}
	}

	private static String metricOrMissing(Map<String, String> metrics, String key) {
		if (metrics == null) {
			return "missing-metrics";
		}
		String value = metrics.get(key);
		if (value == null || value.isBlank()) {
			return "missing-" + key;
		}
		return value;
	}

	private void printExecutionVerification(QueryExecutionVerification executionVerification) {
		output.println();
		output.println("=== Execution Verification ===");
		if (executionVerification.runs == 0) {
			output.println("No repeated runs executed.");
			return;
		}

		long totalMillis = TimeUnit.NANOSECONDS.toMillis(executionVerification.elapsedNanos);
		long averageMillis = TimeUnit.NANOSECONDS.toMillis(
				executionVerification.elapsedNanos / executionVerification.runs);
		long minMillis = TimeUnit.NANOSECONDS.toMillis(executionVerification.minRunNanos);
		long maxMillis = TimeUnit.NANOSECONDS.toMillis(executionVerification.maxRunNanos);
		output.println("runs=" + executionVerification.runs
				+ ", totalMillis=" + totalMillis
				+ ", averageMillis=" + averageMillis
				+ ", minMillis=" + minMillis
				+ ", maxMillis=" + maxMillis
				+ ", verificationStatus=" + executionVerification.verificationStatus()
				+ ", stdDevMillis=" + executionVerification.stdDevMillis()
				+ ", coefficientOfVariationPct=" + executionVerification.coefficientOfVariationPct()
				+ ", resultCount=" + executionVerification.resultCount
				+ ", sampleMillis=" + executionVerification.sampleMillis()
				+ ", optimizedPlanHashCount=" + executionVerification.optimizedPlanHashCount()
				+ ", optimizedPlanHashStable=" + executionVerification.optimizedPlanHashStable()
				+ ", optimizedPlanHashTransitionCount=" + executionVerification.optimizedPlanHashTransitionCount()
				+ ", softLimitMillis=" + TimeUnit.NANOSECONDS.toMillis(executionRepeatSoftLimitNanos)
				+ ", softLimitReached=" + executionVerification.softLimitReached
				+ ", maxRunsReached=" + executionVerification.maxRunsReached);
		if (executionVerification.hasFailure()) {
			output.println("failure: run=" + executionVerification.failureRun()
					+ ", class=" + executionVerification.failureClass()
					+ ", message=" + executionVerification.failureMessage()
					+ ", causeClass=" + executionVerification.failureCauseClass()
					+ ", causeMessage=" + executionVerification.failureCauseMessage()
					+ ", planHash=" + executionVerification.failurePlanHash());
		}
	}

	private static void applyExecutionVerificationMetadata(QueryPlanSnapshot snapshot,
			QueryExecutionVerification executionVerification) {
		if (snapshot == null || executionVerification == null) {
			return;
		}
		LinkedHashMap<String, String> metadata = new LinkedHashMap<>();
		if (snapshot.getMetadata() != null) {
			metadata.putAll(snapshot.getMetadata());
		}

		metadata.put("execution.runs", Integer.toString(executionVerification.runs));
		metadata.put("execution.resultCount", Long.toString(executionVerification.resultCount));
		metadata.put("execution.totalMillis",
				Long.toString(TimeUnit.NANOSECONDS.toMillis(executionVerification.elapsedNanos)));
		metadata.put("execution.averageMillis", Long.toString(executionVerification.averageMillis()));
		metadata.put("execution.minMillis", Long.toString(executionVerification.minMillis()));
		metadata.put("execution.maxMillis", Long.toString(executionVerification.maxMillis()));
		metadata.put("execution.stdDevMillis", Long.toString(executionVerification.stdDevMillis()));
		metadata.put("execution.coefficientOfVariationPct", executionVerification.coefficientOfVariationPct());
		metadata.put("execution.sampleMillis", executionVerification.sampleMillis());
		metadata.put("execution.verificationStatus", executionVerification.verificationStatus());
		metadata.put("execution.optimizedPlanHashCount",
				Integer.toString(executionVerification.optimizedPlanHashCount()));
		metadata.put("execution.optimizedPlanHashStable",
				Boolean.toString(executionVerification.optimizedPlanHashStable()));
		metadata.put("execution.optimizedPlanHashes", executionVerification.optimizedPlanHashes());
		metadata.put("execution.optimizedPlanHashTransitionCount",
				Integer.toString(executionVerification.optimizedPlanHashTransitionCount()));
		metadata.put("execution.optimizedPlanHashSequence", executionVerification.optimizedPlanHashSequence());
		metadata.put("execution.failureRun", executionVerification.failureRun());
		metadata.put("execution.failureClass", executionVerification.failureClass());
		metadata.put("execution.failureMessage", executionVerification.failureMessage());
		metadata.put("execution.failureCauseClass", executionVerification.failureCauseClass());
		metadata.put("execution.failureCauseMessage", executionVerification.failureCauseMessage());
		metadata.put("execution.failurePlanHash", executionVerification.failurePlanHash());
		metadata.put("execution.softLimitReached", Boolean.toString(executionVerification.softLimitReached));
		metadata.put("execution.maxRunsReached", Boolean.toString(executionVerification.maxRunsReached));
		snapshot.setMetadata(metadata);
	}

	private static final class BatchQueryTarget {
		private final Theme theme;
		private final int queryIndex;
		private final BenchmarkQuery benchmarkQuery;
		private final String queryId;
		private final String queryText;

		private BatchQueryTarget(Theme theme, int queryIndex, BenchmarkQuery benchmarkQuery, String queryId,
				String queryText) {
			this.theme = theme;
			this.queryIndex = queryIndex;
			this.benchmarkQuery = benchmarkQuery;
			this.queryId = queryId;
			this.queryText = queryText;
		}
	}

	private static final class HistoricalQueryTiming {
		private final long executionMillis;
		private final long capturedAtEpochMillis;

		private HistoricalQueryTiming(long executionMillis, long capturedAtEpochMillis) {
			this.executionMillis = executionMillis;
			this.capturedAtEpochMillis = capturedAtEpochMillis;
		}
	}

	private static final class BatchRunEtaReporter {
		private final PrintStream output;
		private final LinkedHashMap<String, Long> plannedEstimateMillisByQueryId = new LinkedHashMap<>();
		private final LinkedHashSet<String> completedQueryIds = new LinkedHashSet<>();
		private final long startedAtNanos = System.nanoTime();
		private final long startedAtEpochMillis = System.currentTimeMillis();
		private final long updateIntervalNanos;
		private final long fallbackEstimateMillis;
		private final int totalQueries;
		private final int directHistoryQueryCount;
		private final ScheduledExecutorService scheduler;
		private long observedElapsedMillisTotal;
		private int observedElapsedCount;
		private boolean stopped;

		private BatchRunEtaReporter(PrintStream output, List<String> queryIds, Map<String, Long> historicalByQueryId,
				long fallbackEstimateMillis, long updateIntervalNanos) {
			this.output = Objects.requireNonNull(output, "output");
			this.updateIntervalNanos = updateIntervalNanos;
			this.fallbackEstimateMillis = Math.max(0L, fallbackEstimateMillis);
			this.totalQueries = queryIds.size();
			this.scheduler = Executors.newSingleThreadScheduledExecutor(task -> {
				Thread thread = new Thread(task, "query-plan-snapshot-cli-eta");
				thread.setDaemon(true);
				return thread;
			});

			int directCount = 0;
			for (String queryId : queryIds) {
				long directEstimate = Math.max(0L, historicalByQueryId.getOrDefault(queryId, 0L));
				if (directEstimate > 0L) {
					directCount++;
				}
				plannedEstimateMillisByQueryId.put(queryId, directEstimate);
			}
			this.directHistoryQueryCount = directCount;
		}

		void start() {
			printStart();
			if (totalQueries == 0) {
				return;
			}
			scheduler.scheduleAtFixedRate(() -> {
				try {
					printUpdate();
				} catch (RuntimeException ignored) {
					// Ignore transient logging errors in periodic ETA updates.
				}
			}, updateIntervalNanos, updateIntervalNanos, TimeUnit.NANOSECONDS);
		}

		void markCompleted(String queryId, long actualElapsedMillis) {
			synchronized (this) {
				if (!completedQueryIds.add(queryId)) {
					return;
				}
				long sanitizedElapsed = Math.max(0L, actualElapsedMillis);
				if (sanitizedElapsed > 0L) {
					observedElapsedMillisTotal += sanitizedElapsed;
					observedElapsedCount++;
				}
			}
		}

		void stop() {
			synchronized (this) {
				stopped = true;
			}
			scheduler.shutdownNow();
		}

		private void printStart() {
			long estimatedTotalMillis;
			synchronized (this) {
				estimatedTotalMillis = estimateTotalMillisLocked();
			}

			String estimatedTotal = estimatedTotalMillis > 0L ? formatDurationMillis(estimatedTotalMillis)
					: UNKNOWN_VALUE;
			String eta = estimatedTotalMillis > 0L ? formatLocalTime(startedAtEpochMillis + estimatedTotalMillis)
					: UNKNOWN_VALUE;
			printLine("ETA start: totalQueries=" + totalQueries
					+ ", directHistory=" + directHistoryQueryCount + "/" + totalQueries
					+ ", estimatedTotal=" + estimatedTotal
					+ ", eta=" + eta);
		}

		private void printUpdate() {
			int completed;
			long elapsedMillis;
			RemainingEstimate remainingEstimate;
			synchronized (this) {
				if (stopped) {
					return;
				}
				completed = completedQueryIds.size();
				if (completed >= totalQueries) {
					return;
				}
				elapsedMillis = TimeUnit.NANOSECONDS.toMillis(Math.max(1L, System.nanoTime() - startedAtNanos));
				remainingEstimate = estimateRemainingLocked();
			}

			String remainingText = remainingEstimate.unknown ? UNKNOWN_VALUE
					: formatDurationMillis(remainingEstimate.millis);
			String etaText = remainingEstimate.unknown ? UNKNOWN_VALUE
					: formatLocalTime(System.currentTimeMillis() + remainingEstimate.millis);
			printLine("ETA update: completed=" + completed + "/" + totalQueries
					+ ", elapsed=" + formatDurationMillis(elapsedMillis)
					+ ", remainingEstimate=" + remainingText
					+ ", eta=" + etaText);
		}

		private synchronized long estimateTotalMillisLocked() {
			long total = 0L;
			boolean anyEstimate = false;
			long fallback = fallbackEstimateForRemainingQueriesLocked();
			for (long estimateMillis : plannedEstimateMillisByQueryId.values()) {
				if (estimateMillis <= 0L) {
					estimateMillis = fallback;
				}
				if (estimateMillis <= 0L) {
					continue;
				}
				total += estimateMillis;
				anyEstimate = true;
			}
			if (anyEstimate) {
				return total;
			}
			return 0L;
		}

		private synchronized RemainingEstimate estimateRemainingLocked() {
			long remaining = 0L;
			boolean unknown = false;
			long fallback = fallbackEstimateForRemainingQueriesLocked();
			for (Map.Entry<String, Long> entry : plannedEstimateMillisByQueryId.entrySet()) {
				if (completedQueryIds.contains(entry.getKey())) {
					continue;
				}
				long estimate = entry.getValue();
				if (estimate <= 0L) {
					estimate = fallback;
				}
				if (estimate <= 0L) {
					unknown = true;
					continue;
				}
				remaining += estimate;
			}
			if (remaining <= 0L) {
				return new RemainingEstimate(0L, true);
			}
			return new RemainingEstimate(remaining, unknown);
		}

		private synchronized long fallbackEstimateForRemainingQueriesLocked() {
			long directTotal = 0L;
			int directCount = 0;
			for (Map.Entry<String, Long> entry : plannedEstimateMillisByQueryId.entrySet()) {
				if (completedQueryIds.contains(entry.getKey())) {
					continue;
				}
				long directEstimate = entry.getValue();
				if (directEstimate <= 0L) {
					continue;
				}
				directTotal += directEstimate;
				directCount++;
			}
			if (directCount > 0) {
				return Math.max(1L, directTotal / directCount);
			}
			if (observedElapsedCount > 0) {
				return Math.max(1L, observedElapsedMillisTotal / observedElapsedCount);
			}
			return fallbackEstimateMillis;
		}

		private void printLine(String line) {
			synchronized (output) {
				output.println(line);
				output.flush();
			}
		}

		private static final class RemainingEstimate {
			private final long millis;
			private final boolean unknown;

			private RemainingEstimate(long millis, boolean unknown) {
				this.millis = millis;
				this.unknown = unknown;
			}
		}
	}

	private static final class VerificationFailure {
		private final String status;
		private final int runNumber;
		private final String planHash;
		private final String errorClass;
		private final String errorMessage;
		private final String causeClass;
		private final String causeMessage;

		private VerificationFailure(String status, int runNumber, String planHash, String errorClass,
				String errorMessage, String causeClass, String causeMessage) {
			this.status = status;
			this.runNumber = runNumber;
			this.planHash = planHash;
			this.errorClass = errorClass;
			this.errorMessage = errorMessage;
			this.causeClass = causeClass;
			this.causeMessage = causeMessage;
		}

		private static VerificationFailure interrupted(int runNumber, String planHash, Throwable throwable) {
			return fromThrowable("interrupted", runNumber, planHash, throwable);
		}

		private static VerificationFailure error(int runNumber, String planHash, Throwable throwable) {
			return fromThrowable("evaluation-error", runNumber, planHash, throwable);
		}

		private static VerificationFailure resultCountChanged(int runNumber, long expected, long actual,
				String planHash) {
			String message = "Result count changed between repeated runs: expected " + expected + " but got "
					+ actual + " on run " + runNumber;
			return new VerificationFailure("result-count-changed", runNumber, planHash, "ResultCountChanged", message,
					"", "");
		}

		private static VerificationFailure fromThrowable(String status, int runNumber, String planHash,
				Throwable throwable) {
			Throwable rootCause = rootCause(throwable);
			String errorClass = throwable == null ? "UnknownError" : throwable.getClass().getSimpleName();
			String errorMessage = throwable == null || throwable.getMessage() == null ? "" : throwable.getMessage();
			String causeClass = rootCause == null || rootCause == throwable ? ""
					: rootCause.getClass().getSimpleName();
			String causeMessage = rootCause == null || rootCause == throwable || rootCause.getMessage() == null ? ""
					: rootCause.getMessage();
			return new VerificationFailure(status, runNumber, planHash, errorClass, errorMessage, causeClass,
					causeMessage);
		}

		private static Throwable rootCause(Throwable throwable) {
			if (throwable == null) {
				return null;
			}
			Throwable current = throwable;
			while (current.getCause() != null && current.getCause() != current) {
				current = current.getCause();
			}
			return current;
		}
	}

	private static final class QueryExecutionVerification {
		private final int runs;
		private final long elapsedNanos;
		private final long resultCount;
		private final boolean softLimitReached;
		private final boolean maxRunsReached;
		private final long minRunNanos;
		private final long maxRunNanos;
		private final List<Long> runDurationsNanos;
		private final List<String> optimizedPlanSignatures;
		private final List<String> optimizedPlanSignatureSequence;
		private final VerificationFailure failure;

		private QueryExecutionVerification(int runs, long elapsedNanos, long resultCount, boolean softLimitReached,
				boolean maxRunsReached, long minRunNanos, long maxRunNanos, List<Long> runDurationsNanos,
				List<String> optimizedPlanSignatures, List<String> optimizedPlanSignatureSequence,
				VerificationFailure failure) {
			this.runs = runs;
			this.elapsedNanos = elapsedNanos;
			this.resultCount = resultCount;
			this.softLimitReached = softLimitReached;
			this.maxRunsReached = maxRunsReached;
			this.minRunNanos = minRunNanos;
			this.maxRunNanos = maxRunNanos;
			this.runDurationsNanos = runDurationsNanos;
			this.optimizedPlanSignatures = optimizedPlanSignatures;
			this.optimizedPlanSignatureSequence = optimizedPlanSignatureSequence;
			this.failure = failure;
		}

		private boolean hasFailure() {
			return failure != null;
		}

		private String verificationStatus() {
			if (failure != null) {
				return failure.status;
			}
			if (runs == 0) {
				return softLimitReached ? "soft-limit-reached-no-runs" : "no-runs";
			}
			if (maxRunsReached) {
				return "max-runs-reached";
			}
			if (softLimitReached) {
				return "soft-limit-reached";
			}
			return "completed";
		}

		private long averageMillis() {
			if (runs == 0) {
				return 0;
			}
			return TimeUnit.NANOSECONDS.toMillis(elapsedNanos / runs);
		}

		private long minMillis() {
			return TimeUnit.NANOSECONDS.toMillis(minRunNanos);
		}

		private long maxMillis() {
			return TimeUnit.NANOSECONDS.toMillis(maxRunNanos);
		}

		private long stdDevMillis() {
			if (runs == 0 || runDurationsNanos.isEmpty()) {
				return 0L;
			}
			double meanNanos = elapsedNanos / (double) runs;
			double squaredDiffSum = 0.0d;
			for (long duration : runDurationsNanos) {
				double diff = duration - meanNanos;
				squaredDiffSum += diff * diff;
			}
			double variance = squaredDiffSum / runDurationsNanos.size();
			return TimeUnit.NANOSECONDS.toMillis(Math.max(0L, Math.round(Math.sqrt(variance))));
		}

		private String coefficientOfVariationPct() {
			if (runs == 0 || runDurationsNanos.isEmpty()) {
				return "0.0";
			}
			double meanNanos = elapsedNanos / (double) runs;
			if (meanNanos <= 0.0d) {
				return "0.0";
			}
			double squaredDiffSum = 0.0d;
			for (long duration : runDurationsNanos) {
				double diff = duration - meanNanos;
				squaredDiffSum += diff * diff;
			}
			double variance = squaredDiffSum / runDurationsNanos.size();
			double stdDev = Math.sqrt(variance);
			double coefficientPct = (stdDev / meanNanos) * 100.0d;
			return String.format(Locale.ROOT, "%.4f", coefficientPct);
		}

		private String sampleMillis() {
			if (runDurationsNanos.isEmpty()) {
				return "";
			}
			StringBuilder values = new StringBuilder();
			for (int i = 0; i < runDurationsNanos.size(); i++) {
				if (i > 0) {
					values.append(',');
				}
				values.append(TimeUnit.NANOSECONDS.toMillis(runDurationsNanos.get(i)));
			}
			return values.toString();
		}

		private int optimizedPlanHashCount() {
			return optimizedPlanSignatures.size();
		}

		private boolean optimizedPlanHashStable() {
			return optimizedPlanSignatures.size() <= 1;
		}

		private int optimizedPlanHashTransitionCount() {
			if (optimizedPlanSignatureSequence.size() <= 1) {
				return 0;
			}
			int transitions = 0;
			String previous = optimizedPlanSignatureSequence.get(0);
			for (int i = 1; i < optimizedPlanSignatureSequence.size(); i++) {
				String current = optimizedPlanSignatureSequence.get(i);
				if (!Objects.equals(previous, current)) {
					transitions++;
				}
				previous = current;
			}
			return transitions;
		}

		private String optimizedPlanHashes() {
			if (optimizedPlanSignatures.isEmpty()) {
				return "";
			}
			return String.join(";", optimizedPlanSignatures);
		}

		private String optimizedPlanHashSequence() {
			if (optimizedPlanSignatureSequence.isEmpty()) {
				return "";
			}
			return String.join(";", optimizedPlanSignatureSequence);
		}

		private String failureRun() {
			if (failure == null || failure.runNumber <= 0) {
				return "";
			}
			return Integer.toString(failure.runNumber);
		}

		private String failureClass() {
			return failure == null ? "" : failure.errorClass;
		}

		private String failureMessage() {
			return failure == null ? "" : failure.errorMessage;
		}

		private String failureCauseClass() {
			return failure == null ? "" : failure.causeClass;
		}

		private String failureCauseMessage() {
			return failure == null ? "" : failure.causeMessage;
		}

		private String failurePlanHash() {
			return failure == null ? "" : failure.planHash;
		}
	}

	private static final class CommitRunGroup {
		private final String commit;
		private final LinkedHashSet<String> branches = new LinkedHashSet<>();
		private long latestEpochMillis = Long.MIN_VALUE;
		private String latestCapturedAt;
		private int runCount;

		private CommitRunGroup(String commit) {
			this.commit = commit;
		}

		private void recordRun(QueryPlanSnapshotComparator.SnapshotRun run, String branch) {
			runCount++;
			branches.add(branch == null ? UNKNOWN_VALUE : branch);
			String capturedAt = run.snapshot().getCapturedAt();
			long epochMillis = toEpochMillis(capturedAt);
			if (epochMillis >= latestEpochMillis) {
				latestEpochMillis = epochMillis;
				latestCapturedAt = capturedAt;
			}
		}

		private String commit() {
			return commit;
		}

		private String branchSummary() {
			return String.join(",", branches);
		}

		private long latestEpochMillis() {
			return latestEpochMillis;
		}

		private String latestCapturedAt() {
			return latestCapturedAt;
		}

		private int runCount() {
			return runCount;
		}
	}

	static QueryPlanSnapshotCliOptions parseArgs(String[] args) {
		return QueryPlanSnapshotCliOptions.parseArgs(args);
	}

	static boolean requiresInteractiveInput(QueryPlanSnapshotCliOptions options) {
		return QueryPlanSnapshotCliOptions.requiresInteractiveInput(options);
	}
}
