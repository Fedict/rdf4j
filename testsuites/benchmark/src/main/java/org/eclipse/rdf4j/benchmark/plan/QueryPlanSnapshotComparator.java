/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.IOException;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.TreeSet;
import java.util.stream.Stream;

import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCapture;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

final class QueryPlanSnapshotComparator {

	private static final ObjectMapper JSON_MAPPER = new ObjectMapper();

	private QueryPlanSnapshotComparator() {
	}

	static List<SnapshotRun> loadRuns(Path outputDirectory, QueryPlanCapture capture) throws IOException {
		Objects.requireNonNull(outputDirectory, "outputDirectory");
		Objects.requireNonNull(capture, "capture");
		if (!Files.exists(outputDirectory)) {
			return List.of();
		}

		List<SnapshotRun> runs = new ArrayList<>();
		try (Stream<Path> paths = Files.walk(outputDirectory)) {
			paths.filter(Files::isRegularFile)
					.filter(QueryPlanSnapshotComparator::isJsonFile)
					.forEach(path -> readRun(capture, path).ifPresent(runs::add));
		}
		runs.sort((left, right) -> Long.compare(right.epochMillis, left.epochMillis));
		return runs;
	}

	static List<SnapshotRun> filterRuns(List<SnapshotRun> runs, String queryId, String fingerprint) {
		List<SnapshotRun> filtered = new ArrayList<>();
		for (SnapshotRun run : runs) {
			boolean matchesQueryId = queryId == null || queryId.equals(run.snapshot.getQueryId());
			boolean matchesFingerprint = fingerprint == null
					|| fingerprint.equals(run.snapshot.getUnoptimizedFingerprint());
			if (matchesQueryId && matchesFingerprint) {
				filtered.add(run);
			}
		}
		return filtered;
	}

	static SnapshotRun latestExcludingPath(List<SnapshotRun> runs, Path excludedPath) {
		for (SnapshotRun run : runs) {
			if (excludedPath == null || !excludedPath.equals(run.path)) {
				return run;
			}
		}
		return null;
	}

	static void printRunList(PrintStream out, List<SnapshotRun> runs) {
		out.println("Matching runs:");
		for (int i = 0; i < runs.size(); i++) {
			SnapshotRun run = runs.get(i);
			out.println("  [" + i + "] " + run.snapshot.getCapturedAt() + "  queryId=" + run.snapshot.getQueryId()
					+ "  fingerprint=" + run.snapshot.getUnoptimizedFingerprint());
			if (run.path != null) {
				out.println("       " + run.path.toAbsolutePath());
			}
		}
	}

	static void printRunDetails(PrintStream out, SnapshotRun run) {
		Objects.requireNonNull(out, "out");
		Objects.requireNonNull(run, "run");
		QueryPlanSnapshot snapshot = run.snapshot;

		out.println("Run details:");
		out.println("  capturedAt: " + normalize(snapshot.getCapturedAt()));
		out.println("  queryId: " + normalize(snapshot.getQueryId()));
		out.println("  unoptimizedFingerprint: " + normalize(snapshot.getUnoptimizedFingerprint()));
		if (run.path != null) {
			out.println("  path: " + run.path.toAbsolutePath());
		}
		printStringMap(out, "metadata", snapshot.getMetadata());
		printStringMap(out, "featureFlags", snapshot.getFeatureFlags());

		out.println();
		out.println("=== Results ===");
		out.println("Original query:");
		printTextBlock(out, snapshot.getQueryString(), "");
		printFullExplanations(out, snapshot.getExplanations());
	}

	private static void printFullExplanations(PrintStream out, Map<String, QueryPlanExplanation> explanations) {
		if (explanations == null || explanations.isEmpty()) {
			out.println();
			out.println("No query explanations captured.");
			return;
		}

		LinkedHashSet<String> orderedLevels = new LinkedHashSet<>(List.of("unoptimized", "optimized", "executed"));
		orderedLevels.addAll(explanations.keySet());
		for (String levelKey : orderedLevels) {
			QueryPlanExplanation explanation = explanations.get(levelKey);
			if (explanation == null) {
				continue;
			}

			out.println();
			out.println("=== " + displayLevelName(levelKey, explanation.getLevel()) + " Explanation ===");
			String explanationText = explanation.getExplanationText();
			if (isPresent(explanationText)) {
				printTextBlock(out, explanationText, "");
			} else {
				out.println("(no explanation text)");
			}

			if (isPresent(explanation.getIrRenderedQuery())) {
				out.println("--- IR Rendered Query ---");
				printTextBlock(out, explanation.getIrRenderedQuery(), "");
			}
			if (isPresent(explanation.getIrRenderingError())) {
				out.println("--- IR Rendering Error ---");
				printTextBlock(out, explanation.getIrRenderingError(), "");
			}
		}
	}

	private static String displayLevelName(String levelKey, String levelValue) {
		String base = isPresent(levelValue) ? levelValue : levelKey;
		if (!isPresent(base)) {
			return "Unknown";
		}
		String lower = base.toLowerCase(Locale.ROOT);
		return lower.substring(0, 1).toUpperCase(Locale.ROOT) + lower.substring(1);
	}

	static void printComparison(PrintStream out, SnapshotRun left, SnapshotRun right) {
		printComparison(out, left, right, QueryPlanSnapshotCliOptions.DiffMode.STRUCTURE);
	}

	static void printComparison(PrintStream out, SnapshotRun left, SnapshotRun right,
			QueryPlanSnapshotCliOptions.DiffMode diffMode) {
		out.println("Compare:");
		out.println("  left : " + describeRun(left));
		out.println("  right: " + describeRun(right));
		out.println("  diffMode: " + diffMode.id);
		out.println("  unoptimizedFingerprint: " + sameOrDiff(
				left.snapshot.getUnoptimizedFingerprint(), right.snapshot.getUnoptimizedFingerprint()));
		out.println("  queryString: " + sameOrDiff(left.snapshot.getQueryString(), right.snapshot.getQueryString()));

		printExplanationDiff(out, left.snapshot.getExplanations(), right.snapshot.getExplanations(), diffMode);
		printMapDiff(out, "metadata", left.snapshot.getMetadata(), right.snapshot.getMetadata());
		printMapDiff(out, "featureFlags", left.snapshot.getFeatureFlags(), right.snapshot.getFeatureFlags());
	}

	static SnapshotRun inMemoryRun(QueryPlanSnapshot snapshot) {
		return new SnapshotRun(null, snapshot, epochMillis(snapshot));
	}

	static SnapshotRun runAtIndex(List<SnapshotRun> runs, int index) {
		if (index < 0 || index >= runs.size()) {
			throw new IllegalArgumentException(
					"Run index out of range: " + index + ", available 0-" + (runs.size() - 1));
		}
		return runs.get(index);
	}

	private static void printExplanationDiff(PrintStream out, Map<String, QueryPlanExplanation> left,
			Map<String, QueryPlanExplanation> right, QueryPlanSnapshotCliOptions.DiffMode diffMode) {
		TreeSet<String> levels = new TreeSet<>();
		if (left != null) {
			levels.addAll(left.keySet());
		}
		if (right != null) {
			levels.addAll(right.keySet());
		}
		out.println("  explanationDiff:");
		for (String level : levels) {
			QueryPlanExplanation leftExplanation = left == null ? null : left.get(level);
			QueryPlanExplanation rightExplanation = right == null ? null : right.get(level);
			if (leftExplanation == null || rightExplanation == null) {
				out.println("    " + level + ": " + (leftExplanation == null ? "missing-left" : "missing-right"));
				continue;
			}
			String tupleExprStatus = sameOrDiff(leftExplanation.getTupleExprJson(),
					rightExplanation.getTupleExprJson());
			String irStatus = sameOrDiff(leftExplanation.getIrRenderedQuery(), rightExplanation.getIrRenderedQuery());
			SemanticDiff semanticDiff = semanticDiff(leftExplanation.getExplanationJson(),
					rightExplanation.getExplanationJson(), diffMode);
			out.println("    " + level + ": tupleExprJson=" + tupleExprStatus
					+ ", irRenderedQuery=" + irStatus
					+ ", structure=" + semanticDiff.structure
					+ ", joinAlgorithms=" + semanticDiff.joinAlgorithms
					+ ", actualResultSizes=" + semanticDiff.actualResultSizes
					+ ", estimates=" + semanticDiff.estimates);
		}
	}

	private static void printMapDiff(PrintStream out, String title, Map<String, String> left,
			Map<String, String> right) {
		TreeSet<String> keys = new TreeSet<>();
		if (left != null) {
			keys.addAll(left.keySet());
		}
		if (right != null) {
			keys.addAll(right.keySet());
		}

		int changed = 0;
		out.println("  " + title + "Diff:");
		for (String key : keys) {
			String leftValue = left == null ? null : left.get(key);
			String rightValue = right == null ? null : right.get(key);
			if (!Objects.equals(leftValue, rightValue)) {
				changed++;
				out.println("    " + key + ": '" + normalize(leftValue) + "' -> '" + normalize(rightValue) + "'");
			}
		}
		if (changed == 0) {
			out.println("    no changes");
		}
	}

	private static String describeRun(SnapshotRun run) {
		if (run.path == null) {
			return "in-memory snapshot";
		}
		return run.path.toAbsolutePath().toString();
	}

	private static String sameOrDiff(String left, String right) {
		return Objects.equals(left, right) ? "same" : "diff";
	}

	private static String normalize(String value) {
		return value == null ? "<null>" : value;
	}

	private static void printStringMap(PrintStream out, String label, Map<String, String> values) {
		out.println("  " + label + ":");
		if (values == null || values.isEmpty()) {
			out.println("    <none>");
			return;
		}
		for (Map.Entry<String, String> entry : values.entrySet()) {
			out.println("    " + entry.getKey() + "=" + normalize(entry.getValue()));
		}
	}

	private static void printTextBlock(PrintStream out, String value, String indent) {
		if (value == null) {
			out.println(indent + "<null>");
			return;
		}

		String normalized = value.replace("\r\n", "\n").replace('\r', '\n');
		if (normalized.isEmpty()) {
			out.println(indent + "<empty>");
			return;
		}

		String[] lines = normalized.split("\n", -1);
		for (String line : lines) {
			out.println(indent + line);
		}
	}

	private static boolean isPresent(String value) {
		return value != null && !value.isBlank();
	}

	private static SemanticDiff semanticDiff(String leftJson, String rightJson,
			QueryPlanSnapshotCliOptions.DiffMode mode) {
		JsonNode leftNode;
		JsonNode rightNode;
		try {
			leftNode = leftJson == null || leftJson.isBlank() ? null : JSON_MAPPER.readTree(leftJson);
			rightNode = rightJson == null || rightJson.isBlank() ? null : JSON_MAPPER.readTree(rightJson);
		} catch (Exception e) {
			return SemanticDiff.unavailable(e.getClass().getSimpleName());
		}

		String structure = sameOrDiff(signature(leftNode, SignatureAspect.STRUCTURE),
				signature(rightNode, SignatureAspect.STRUCTURE));
		String joinAlgorithms = sameOrDiff(signature(leftNode, SignatureAspect.JOIN_ALGORITHMS),
				signature(rightNode, SignatureAspect.JOIN_ALGORITHMS));
		String actualResultSizes = sameOrDiff(signature(leftNode, SignatureAspect.ACTUAL_RESULT_SIZES),
				signature(rightNode, SignatureAspect.ACTUAL_RESULT_SIZES));

		String estimates;
		if (mode.includeEstimates) {
			estimates = sameOrDiff(signature(leftNode, SignatureAspect.ESTIMATES),
					signature(rightNode, SignatureAspect.ESTIMATES));
		} else {
			estimates = "ignored";
		}

		return new SemanticDiff(structure, joinAlgorithms, actualResultSizes, estimates);
	}

	private static String signature(JsonNode root, SignatureAspect aspect) {
		StringBuilder signature = new StringBuilder();
		appendSignature(signature, root, aspect);
		return signature.toString();
	}

	private static void appendSignature(StringBuilder signature, JsonNode node, SignatureAspect aspect) {
		if (node == null || node.isNull()) {
			signature.append("null");
			return;
		}

		String type = readText(node, "type");
		signature.append('(').append(type);
		switch (aspect) {
		case JOIN_ALGORITHMS:
			if (isJoinType(type)) {
				signature.append("|algorithm=").append(readText(node, "algorithm"));
			}
			break;
		case ACTUAL_RESULT_SIZES:
			signature.append("|resultSizeActual=").append(readNumberToken(node, "resultSizeActual"));
			break;
		case ESTIMATES:
			signature.append("|costEstimate=").append(readNumberToken(node, "costEstimate"));
			signature.append("|resultSizeEstimate=").append(readNumberToken(node, "resultSizeEstimate"));
			break;
		case STRUCTURE:
			break;
		default:
			throw new IllegalStateException("Unhandled signature aspect: " + aspect);
		}

		for (JsonNode child : readChildren(node)) {
			appendSignature(signature, child, aspect);
		}
		signature.append(')');
	}

	private static List<JsonNode> readChildren(JsonNode node) {
		JsonNode plans = node.get("plans");
		if (plans == null || !plans.isArray()) {
			return List.of();
		}
		List<JsonNode> children = new ArrayList<>();
		plans.forEach(children::add);
		return children;
	}

	private static String readText(JsonNode node, String field) {
		JsonNode value = node.get(field);
		if (value == null || value.isNull()) {
			return "<null>";
		}
		return value.asText();
	}

	private static String readNumberToken(JsonNode node, String field) {
		JsonNode value = node.get(field);
		if (value == null || value.isNull()) {
			return "<null>";
		}
		String asText = value.asText();
		try {
			return new BigDecimal(asText).stripTrailingZeros().toPlainString();
		} catch (NumberFormatException ignored) {
			return asText;
		}
	}

	private static boolean isJoinType(String type) {
		return type != null && type.contains("Join");
	}

	private static boolean isJsonFile(Path path) {
		return path.getFileName().toString().endsWith(".json");
	}

	private static java.util.Optional<SnapshotRun> readRun(QueryPlanCapture capture, Path path) {
		try {
			QueryPlanSnapshot snapshot = capture.readSnapshot(path);
			return java.util.Optional.of(new SnapshotRun(path, snapshot, epochMillis(snapshot)));
		} catch (Exception ignored) {
			return java.util.Optional.empty();
		}
	}

	private static long epochMillis(QueryPlanSnapshot snapshot) {
		if (snapshot == null || snapshot.getCapturedAt() == null) {
			return Long.MIN_VALUE;
		}
		try {
			return Instant.parse(snapshot.getCapturedAt()).toEpochMilli();
		} catch (Exception ignored) {
			return Long.MIN_VALUE;
		}
	}

	private enum SignatureAspect {
		STRUCTURE,
		JOIN_ALGORITHMS,
		ACTUAL_RESULT_SIZES,
		ESTIMATES
	}

	private static final class SemanticDiff {
		private final String structure;
		private final String joinAlgorithms;
		private final String actualResultSizes;
		private final String estimates;

		private SemanticDiff(String structure, String joinAlgorithms, String actualResultSizes, String estimates) {
			this.structure = structure;
			this.joinAlgorithms = joinAlgorithms;
			this.actualResultSizes = actualResultSizes;
			this.estimates = estimates;
		}

		private static SemanticDiff unavailable(String reason) {
			String unavailable = "unavailable(" + reason + ")";
			return new SemanticDiff(unavailable, unavailable, unavailable, unavailable);
		}
	}

	static final class SnapshotRun {
		private final Path path;
		private final QueryPlanSnapshot snapshot;
		private final long epochMillis;

		SnapshotRun(Path path, QueryPlanSnapshot snapshot, long epochMillis) {
			this.path = path;
			this.snapshot = snapshot;
			this.epochMillis = epochMillis;
		}

		QueryPlanSnapshot snapshot() {
			return snapshot;
		}

		Path path() {
			return path;
		}
	}
}
