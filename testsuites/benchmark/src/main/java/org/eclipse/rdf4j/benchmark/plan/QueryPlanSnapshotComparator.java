/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.IOException;
import java.io.PrintStream;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.TreeSet;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanCapture;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

final class QueryPlanSnapshotComparator {

	private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
	private static final Pattern ANONYMOUS_VARIABLE_NAME_PATTERN = Pattern
			.compile("(_anon_[A-Za-z]+_)[A-Za-z0-9]+");

	private QueryPlanSnapshotComparator() {
	}

	static List<SnapshotRun> loadRuns(Path outputDirectory, QueryPlanCapture capture) throws IOException {
		Objects.requireNonNull(outputDirectory, "outputDirectory");
		Objects.requireNonNull(capture, "capture");
		if (!Files.exists(outputDirectory)) {
			return List.of();
		}

		List<SnapshotRun> runs = new ArrayList<>();
		try (Stream<Path> paths = Files.walk(outputDirectory)) {
			paths.filter(Files::isRegularFile)
					.filter(QueryPlanSnapshotComparator::isJsonFile)
					.forEach(path -> readRun(capture, path).ifPresent(runs::add));
		}
		runs.sort((left, right) -> Long.compare(right.epochMillis, left.epochMillis));
		return runs;
	}

	static List<SnapshotRun> filterRuns(List<SnapshotRun> runs, String queryId, String fingerprint, String runName) {
		List<SnapshotRun> filtered = new ArrayList<>();
		for (SnapshotRun run : runs) {
			boolean matchesQueryId = queryId == null || queryId.equals(run.snapshot.getQueryId());
			boolean matchesFingerprint = fingerprint == null
					|| fingerprint.equals(run.snapshot.getUnoptimizedFingerprint());
			boolean matchesRunName = runName == null || runName.equals(resolveRunName(run.snapshot));
			if (matchesQueryId && matchesFingerprint && matchesRunName) {
				filtered.add(run);
			}
		}
		return filtered;
	}

	static SnapshotRun latestExcludingPath(List<SnapshotRun> runs, Path excludedPath) {
		for (SnapshotRun run : runs) {
			if (excludedPath == null || !excludedPath.equals(run.path)) {
				return run;
			}
		}
		return null;
	}

	static void printRunList(PrintStream out, List<SnapshotRun> runs) {
		out.println("Matching runs:");
		for (int i = 0; i < runs.size(); i++) {
			SnapshotRun run = runs.get(i);
			String runName = normalize(resolveRunName(run.snapshot));
			out.println("  [" + i + "] " + run.snapshot.getCapturedAt() + "  queryId=" + run.snapshot.getQueryId()
					+ "  runName=" + runName + "  fingerprint=" + run.snapshot.getUnoptimizedFingerprint());
			if (run.path != null) {
				out.println("       " + run.path.toAbsolutePath());
			}
		}
	}

	static void printRunDetails(PrintStream out, SnapshotRun run) {
		Objects.requireNonNull(out, "out");
		Objects.requireNonNull(run, "run");
		QueryPlanSnapshot snapshot = run.snapshot;

		out.println("Run details:");
		out.println("  capturedAt: " + normalize(snapshot.getCapturedAt()));
		out.println("  queryId: " + normalize(snapshot.getQueryId()));
		out.println("  unoptimizedFingerprint: " + normalize(snapshot.getUnoptimizedFingerprint()));
		if (run.path != null) {
			out.println("  path: " + run.path.toAbsolutePath());
		}
		printStringMap(out, "metadata", snapshot.getMetadata());
		printStringMap(out, "featureFlags", snapshot.getFeatureFlags());

		out.println();
		out.println("=== Results ===");
		out.println("Original query:");
		printTextBlock(out, snapshot.getQueryString(), "");
		printFullExplanations(out, snapshot.getExplanations());
	}

	private static void printFullExplanations(PrintStream out, Map<String, QueryPlanExplanation> explanations) {
		if (explanations == null || explanations.isEmpty()) {
			out.println();
			out.println("No query explanations captured.");
			return;
		}

		LinkedHashSet<String> orderedLevels = new LinkedHashSet<>(List.of("unoptimized", "optimized", "telemetry"));
		orderedLevels.addAll(explanations.keySet());
		for (String levelKey : orderedLevels) {
			QueryPlanExplanation explanation = explanations.get(levelKey);
			if (explanation == null) {
				continue;
			}

			out.println();
			out.println("=== " + displayLevelName(levelKey, explanation.getLevel()) + " Explanation ===");
			String explanationText = explanation.getExplanationText();
			if (isPresent(explanationText)) {
				printTextBlock(out, explanationText, "");
			} else {
				out.println("(no explanation text)");
			}

			if (isPresent(explanation.getIrRenderedQuery())) {
				out.println("--- IR Rendered Query ---");
				printTextBlock(out, explanation.getIrRenderedQuery(), "");
			}
			if (isPresent(explanation.getIrRenderingError())) {
				out.println("--- IR Rendering Error ---");
				printTextBlock(out, explanation.getIrRenderingError(), "");
			}
		}
	}

	private static String displayLevelName(String levelKey, String levelValue) {
		String base = isPresent(levelValue) ? levelValue : levelKey;
		if (!isPresent(base)) {
			return "Unknown";
		}
		String lower = base.toLowerCase(Locale.ROOT);
		return lower.substring(0, 1).toUpperCase(Locale.ROOT) + lower.substring(1);
	}

	static void printComparison(PrintStream out, SnapshotRun left, SnapshotRun right) {
		printComparison(out, left, right, QueryPlanSnapshotCliOptions.DiffMode.STRUCTURE);
	}

	static void printComparison(PrintStream out, SnapshotRun left, SnapshotRun right,
			QueryPlanSnapshotCliOptions.DiffMode diffMode) {
		ComparisonSummary summary = compareRuns(left, right, diffMode);
		out.println("Compare:");
		out.println("  left : " + describeRun(left));
		out.println("  right: " + describeRun(right));
		out.println("  diffMode: " + diffMode.id);
		out.println("  unoptimizedFingerprint: " + summary.unoptimizedFingerprint);
		out.println("  queryString: " + summary.queryString);

		printExplanationDiff(out, summary.explanationDiffs);
		printExecutedWorkComparison(out, summary.executedWorkComparison);
		printPlanDifferenceDiagnosis(out, summary.planDifferenceDiagnosis);
		printMapDiff(out, "metadata", left.snapshot.getMetadata(), right.snapshot.getMetadata());
		printMapDiff(out, "featureFlags", left.snapshot.getFeatureFlags(), right.snapshot.getFeatureFlags());
	}

	static ComparisonSummary compareRuns(SnapshotRun left, SnapshotRun right,
			QueryPlanSnapshotCliOptions.DiffMode diffMode) {
		Objects.requireNonNull(left, "left");
		Objects.requireNonNull(right, "right");
		Objects.requireNonNull(diffMode, "diffMode");

		String unoptimizedFingerprint = sameOrDiff(left.snapshot.getUnoptimizedFingerprint(),
				right.snapshot.getUnoptimizedFingerprint());
		String queryString = sameOrDiff(left.snapshot.getQueryString(), right.snapshot.getQueryString());

		TreeSet<String> levels = new TreeSet<>();
		Map<String, QueryPlanExplanation> leftExplanations = left.snapshot.getExplanations();
		Map<String, QueryPlanExplanation> rightExplanations = right.snapshot.getExplanations();
		if (leftExplanations != null) {
			levels.addAll(leftExplanations.keySet());
		}
		if (rightExplanations != null) {
			levels.addAll(rightExplanations.keySet());
		}

		java.util.LinkedHashMap<String, LevelDiff> explanationDiffs = new java.util.LinkedHashMap<>();
		for (String level : levels) {
			QueryPlanExplanation leftExplanation = leftExplanations == null ? null : leftExplanations.get(level);
			QueryPlanExplanation rightExplanation = rightExplanations == null ? null : rightExplanations.get(level);
			if (leftExplanation == null || rightExplanation == null) {
				String missingStatus = leftExplanation == null ? "missing-left" : "missing-right";
				explanationDiffs.put(level, LevelDiff.missing(missingStatus));
				continue;
			}

			String tupleExprStatus = sameOrDiff(leftExplanation.getTupleExprJson(),
					rightExplanation.getTupleExprJson());
			String irStatus = sameOrDiff(leftExplanation.getIrRenderedQuery(), rightExplanation.getIrRenderedQuery());
			SemanticDiff semanticDiff = semanticDiff(leftExplanation.getExplanationJson(),
					rightExplanation.getExplanationJson(), diffMode);
			explanationDiffs.put(level, new LevelDiff(tupleExprStatus, irStatus, semanticDiff.structure,
					semanticDiff.joinAlgorithms, semanticDiff.actualResultSizes, semanticDiff.estimates));
		}

		QueryPlanExecutedWorkComparator.ExecutedWorkComparison executedWorkComparison = QueryPlanExecutedWorkComparator
				.compare(left.snapshot, right.snapshot);
		PlanDifferenceDiagnosis planDifferenceDiagnosis = diagnosePlanDifference(left.snapshot, right.snapshot,
				explanationDiffs);
		return new ComparisonSummary(unoptimizedFingerprint, queryString, explanationDiffs, executedWorkComparison,
				planDifferenceDiagnosis);
	}

	static SnapshotRun inMemoryRun(QueryPlanSnapshot snapshot) {
		return new SnapshotRun(null, snapshot, epochMillis(snapshot));
	}

	static SnapshotRun runAtIndex(List<SnapshotRun> runs, int index) {
		if (index < 0 || index >= runs.size()) {
			throw new IllegalArgumentException(
					"Run index out of range: " + index + ", available 0-" + (runs.size() - 1));
		}
		return runs.get(index);
	}

	private static void printExplanationDiff(PrintStream out, Map<String, LevelDiff> explanationDiffs) {
		out.println("  explanationDiff:");
		for (Map.Entry<String, LevelDiff> entry : explanationDiffs.entrySet()) {
			LevelDiff levelDiff = entry.getValue();
			out.println("    " + entry.getKey() + ": tupleExprJson=" + levelDiff.tupleExprJson
					+ ", irRenderedQuery=" + levelDiff.irRenderedQuery
					+ ", structure=" + levelDiff.structure
					+ ", joinAlgorithms=" + levelDiff.joinAlgorithms
					+ ", actualResultSizes=" + levelDiff.actualResultSizes
					+ ", estimates=" + levelDiff.estimates);
		}
	}

	private static void printExecutedWorkComparison(PrintStream out,
			QueryPlanExecutedWorkComparator.ExecutedWorkComparison comparison) {
		out.println("  executedWorkModel:");
		if (comparison == null || !comparison.available()) {
			String unavailableReason = comparison == null ? "missing" : comparison.unavailableReason();
			out.println("    unavailable: " + normalize(unavailableReason));
			return;
		}
		out.println("    winner=" + comparison.winner() + ", decisionBasis=" + comparison.decisionBasis());
		out.println("    leftScore=" + comparison.leftScore() + ", rightScore=" + comparison.rightScore()
				+ ", scoreDeltaPct=" + comparison.scoreDeltaPct());
		out.println("    topCategoryDeltas=" + comparison.topCategoryDeltas());
		out.println("    topOperatorDeltas=" + comparison.topOperatorDeltas());
		out.println("    topVectorDeltas=" + comparison.topVectorDeltas());
		out.println("    dominantResourceLeft=" + comparison.dominantResourceLeft() + ", dominantResourceRight="
				+ comparison.dominantResourceRight());
		out.println("    topResourceDeltas=" + comparison.topResourceDeltas());
	}

	private static void printPlanDifferenceDiagnosis(PrintStream out, PlanDifferenceDiagnosis diagnosis) {
		out.println("  planDifferenceDiagnosis:");
		if (diagnosis == null) {
			out.println("    likelyCause=unknown");
			out.println("    evidence=<none>");
			return;
		}
		out.println("    likelyCause=" + diagnosis.likelyCause);
		out.println("    evidence=" + diagnosis.evidence);
	}

	private static void printMapDiff(PrintStream out, String title, Map<String, String> left,
			Map<String, String> right) {
		TreeSet<String> keys = new TreeSet<>();
		if (left != null) {
			keys.addAll(left.keySet());
		}
		if (right != null) {
			keys.addAll(right.keySet());
		}

		int changed = 0;
		out.println("  " + title + "Diff:");
		for (String key : keys) {
			String leftValue = left == null ? null : left.get(key);
			String rightValue = right == null ? null : right.get(key);
			if (!Objects.equals(leftValue, rightValue)) {
				changed++;
				out.println("    " + key + ": '" + normalize(leftValue) + "' -> '" + normalize(rightValue) + "'");
			}
		}
		if (changed == 0) {
			out.println("    no changes");
		}
	}

	private static String describeRun(SnapshotRun run) {
		if (run.path == null) {
			return "in-memory snapshot";
		}
		return run.path.toAbsolutePath().toString();
	}

	private static String sameOrDiff(String left, String right) {
		return Objects.equals(left, right) ? "same" : "diff";
	}

	private static String equalsIndicator(String left, String right) {
		if (left == null || right == null) {
			return "unknown";
		}
		return Objects.equals(left, right) ? "same" : "diff";
	}

	private static String metadataValue(QueryPlanSnapshot snapshot, String key) {
		if (snapshot == null || snapshot.getMetadata() == null || key == null) {
			return null;
		}
		return snapshot.getMetadata().get(key);
	}

	private static String explanationDebugMetric(QueryPlanSnapshot snapshot, String level, String key) {
		if (snapshot == null || snapshot.getExplanations() == null || key == null || level == null) {
			return null;
		}

		QueryPlanExplanation explanation = snapshot.getExplanations().get(level);
		if (explanation != null && explanation.getDebugMetrics() != null) {
			String value = explanation.getDebugMetrics().get(key);
			if (isPresent(value)) {
				return value;
			}
		}

		for (QueryPlanExplanation candidate : snapshot.getExplanations().values()) {
			if (candidate == null) {
				continue;
			}
			if (!level.equalsIgnoreCase(candidate.getLevel()) || candidate.getDebugMetrics() == null) {
				continue;
			}
			String value = candidate.getDebugMetrics().get(key);
			if (isPresent(value)) {
				return value;
			}
		}

		return null;
	}

	private static String normalize(String value) {
		return value == null ? "<null>" : value;
	}

	private static String resolveRunName(QueryPlanSnapshot snapshot) {
		if (snapshot == null || snapshot.getMetadata() == null) {
			return null;
		}
		return snapshot.getMetadata().get("runName");
	}

	private static void printStringMap(PrintStream out, String label, Map<String, String> values) {
		out.println("  " + label + ":");
		if (values == null || values.isEmpty()) {
			out.println("    <none>");
			return;
		}
		for (Map.Entry<String, String> entry : values.entrySet()) {
			out.println("    " + entry.getKey() + "=" + normalize(entry.getValue()));
		}
	}

	private static void printTextBlock(PrintStream out, String value, String indent) {
		if (value == null) {
			out.println(indent + "<null>");
			return;
		}

		String normalized = value.replace("\r\n", "\n").replace('\r', '\n');
		if (normalized.isEmpty()) {
			out.println(indent + "<empty>");
			return;
		}

		String[] lines = normalized.split("\n", -1);
		for (String line : lines) {
			out.println(indent + line);
		}
	}

	private static boolean isPresent(String value) {
		return value != null && !value.isBlank();
	}

	private static PlanDifferenceDiagnosis diagnosePlanDifference(QueryPlanSnapshot left, QueryPlanSnapshot right,
			Map<String, LevelDiff> explanationDiffs) {
		String inputFingerprint = equalsIndicator(
				metadataValue(left, "planDeterminism.inputFingerprintSha256"),
				metadataValue(right, "planDeterminism.inputFingerprintSha256"));
		String environmentFingerprint = equalsIndicator(
				metadataValue(left, "planDeterminism.environmentFingerprintSha256"),
				metadataValue(right, "planDeterminism.environmentFingerprintSha256"));
		String featureFlags = equalsIndicator(
				metadataValue(left, "featureFlags.sha256"),
				metadataValue(right, "featureFlags.sha256"));
		String optimizerInputStructure = equalsIndicator(
				metadataValue(left, "optimizerInput.unoptimizedStructureNormalizedSha256"),
				metadataValue(right, "optimizerInput.unoptimizedStructureNormalizedSha256"));
		String optimizedStructureSignature = equalsIndicator(
				explanationDebugMetric(left, "optimized", "structureSignatureNormalizedSha256"),
				explanationDebugMetric(right, "optimized", "structureSignatureNormalizedSha256"));
		String optimizedEstimatesSignature = equalsIndicator(
				explanationDebugMetric(left, "optimized", "estimatesMultisetSignatureSha256"),
				explanationDebugMetric(right, "optimized", "estimatesMultisetSignatureSha256"));
		String optimizedStatementPatternEstimatesSignature = equalsIndicator(
				explanationDebugMetric(left, "optimized", "statementPatternEstimatesMultisetSignatureSha256"),
				explanationDebugMetric(right, "optimized", "statementPatternEstimatesMultisetSignatureSha256"));
		String optimizedJoinAlgorithmSignature = equalsIndicator(
				explanationDebugMetric(left, "optimized", "joinAlgorithmMultisetSignatureSha256"),
				explanationDebugMetric(right, "optimized", "joinAlgorithmMultisetSignatureSha256"));

		LevelDiff optimizedDiff = levelDiff(explanationDiffs, "optimized");
		LevelDiff executedDiff = firstLevelDiff(explanationDiffs, "telemetry", "executed");
		String optimizedStructure = optimizedDiff == null ? "unknown" : optimizedDiff.structure;
		String optimizedEstimates = optimizedDiff == null ? "unknown" : optimizedDiff.estimates;
		String executedStructure = executedDiff == null ? "unknown" : executedDiff.structure;

		String likelyCause;
		if ("diff".equals(inputFingerprint) || "diff".equals(optimizerInputStructure)) {
			likelyCause = "different-optimizer-input";
		} else if ("diff".equals(featureFlags)) {
			likelyCause = "different-feature-flags";
		} else if ("diff".equals(environmentFingerprint)) {
			likelyCause = "different-environment";
		} else if ("diff".equals(optimizedStructureSignature)
				&& ("diff".equals(optimizedEstimatesSignature)
						|| "diff".equals(optimizedStatementPatternEstimatesSignature))) {
			likelyCause = "estimate-driven-optimizer-reorder";
		} else if ("diff".equals(optimizedStructureSignature) && "diff".equals(optimizedJoinAlgorithmSignature)) {
			likelyCause = "join-algorithm-selection-drift";
		} else if ("diff".equals(optimizedStructureSignature) && "same".equals(optimizedEstimatesSignature)
				&& "same".equals(optimizedStatementPatternEstimatesSignature)) {
			likelyCause = "optimizer-structure-drift-with-stable-estimates";
		} else if ("diff".equals(optimizedEstimatesSignature)
				|| "diff".equals(optimizedStatementPatternEstimatesSignature)
				|| "diff".equals(optimizedEstimates)) {
			likelyCause = "estimate-drift";
		} else if ("same".equals(optimizedStructure) && "diff".equals(executedStructure)) {
			likelyCause = "runtime-plan-drift";
		} else if ("same".equals(optimizedStructure) && "same".equals(executedStructure)) {
			likelyCause = "no-plan-difference";
		} else {
			likelyCause = "unknown";
		}

		String evidence = "inputFingerprint=" + inputFingerprint
				+ ";featureFlags=" + featureFlags
				+ ";environmentFingerprint=" + environmentFingerprint
				+ ";optimizerInputStructure=" + optimizerInputStructure
				+ ";optimizedStructure=" + optimizedStructure
				+ ";optimizedEstimates=" + optimizedEstimates
				+ ";optimizedStructureSignature=" + optimizedStructureSignature
				+ ";optimizedEstimatesSignature=" + optimizedEstimatesSignature
				+ ";optimizedStatementPatternEstimatesSignature=" + optimizedStatementPatternEstimatesSignature
				+ ";optimizedJoinAlgorithmSignature=" + optimizedJoinAlgorithmSignature
				+ ";executedStructure=" + executedStructure;
		return new PlanDifferenceDiagnosis(likelyCause, evidence);
	}

	private static LevelDiff firstLevelDiff(Map<String, LevelDiff> explanationDiffs, String... levels) {
		for (String level : levels) {
			LevelDiff diff = levelDiff(explanationDiffs, level);
			if (diff != null) {
				return diff;
			}
		}
		return null;
	}

	private static LevelDiff levelDiff(Map<String, LevelDiff> explanationDiffs, String level) {
		if (explanationDiffs == null || level == null) {
			return null;
		}

		LevelDiff directMatch = explanationDiffs.get(level);
		if (directMatch != null) {
			return directMatch;
		}

		for (Map.Entry<String, LevelDiff> entry : explanationDiffs.entrySet()) {
			if (level.equalsIgnoreCase(entry.getKey())) {
				return entry.getValue();
			}
		}
		return null;
	}

	private static SemanticDiff semanticDiff(String leftJson, String rightJson,
			QueryPlanSnapshotCliOptions.DiffMode mode) {
		JsonNode leftNode;
		JsonNode rightNode;
		try {
			leftNode = leftJson == null || leftJson.isBlank() ? null : JSON_MAPPER.readTree(leftJson);
			rightNode = rightJson == null || rightJson.isBlank() ? null : JSON_MAPPER.readTree(rightJson);
		} catch (Exception e) {
			return SemanticDiff.unavailable(e.getClass().getSimpleName());
		}

		String structure = sameOrDiff(signature(leftNode, SignatureAspect.STRUCTURE),
				signature(rightNode, SignatureAspect.STRUCTURE));
		String joinAlgorithms = sameOrDiff(signature(leftNode, SignatureAspect.JOIN_ALGORITHMS),
				signature(rightNode, SignatureAspect.JOIN_ALGORITHMS));
		String actualResultSizes = sameOrDiff(signature(leftNode, SignatureAspect.ACTUAL_RESULT_SIZES),
				signature(rightNode, SignatureAspect.ACTUAL_RESULT_SIZES));

		String estimates;
		if (mode.includeEstimates) {
			estimates = sameOrDiff(signature(leftNode, SignatureAspect.ESTIMATES),
					signature(rightNode, SignatureAspect.ESTIMATES));
		} else {
			estimates = "ignored";
		}

		return new SemanticDiff(structure, joinAlgorithms, actualResultSizes, estimates);
	}

	private static String signature(JsonNode root, SignatureAspect aspect) {
		StringBuilder signature = new StringBuilder();
		appendSignature(signature, root, aspect);
		return signature.toString();
	}

	private static void appendSignature(StringBuilder signature, JsonNode node, SignatureAspect aspect) {
		if (node == null || node.isNull()) {
			signature.append("null");
			return;
		}

		String type = canonicalizeType(readText(node, "type"));
		signature.append('(').append(type);
		switch (aspect) {
		case JOIN_ALGORITHMS:
			if (isJoinType(type)) {
				signature.append("|algorithm=").append(readText(node, "algorithm"));
			}
			break;
		case ACTUAL_RESULT_SIZES:
			signature.append("|resultSizeActual=").append(readNumberToken(node, "resultSizeActual"));
			break;
		case ESTIMATES:
			signature.append("|costEstimate=").append(readNumberToken(node, "costEstimate"));
			signature.append("|resultSizeEstimate=").append(readNumberToken(node, "resultSizeEstimate"));
			break;
		case STRUCTURE:
			break;
		default:
			throw new IllegalStateException("Unhandled signature aspect: " + aspect);
		}

		for (JsonNode child : readChildren(node)) {
			appendSignature(signature, child, aspect);
		}
		signature.append(')');
	}

	private static List<JsonNode> readChildren(JsonNode node) {
		JsonNode plans = node.get("plans");
		if (plans == null || !plans.isArray()) {
			return List.of();
		}
		List<JsonNode> children = new ArrayList<>();
		plans.forEach(children::add);
		return children;
	}

	private static String readText(JsonNode node, String field) {
		JsonNode value = node.get(field);
		if (value == null || value.isNull()) {
			return "<null>";
		}
		return value.asText();
	}

	private static String readNumberToken(JsonNode node, String field) {
		JsonNode value = node.get(field);
		if (value == null || value.isNull()) {
			return "<null>";
		}
		String asText = value.asText();
		try {
			return new BigDecimal(asText).stripTrailingZeros().toPlainString();
		} catch (NumberFormatException ignored) {
			return asText;
		}
	}

	private static boolean isJoinType(String type) {
		return type != null && type.contains("Join");
	}

	private static String canonicalizeType(String type) {
		if (type == null || type.isBlank()) {
			return type;
		}
		return ANONYMOUS_VARIABLE_NAME_PATTERN.matcher(type).replaceAll("$1<normalized>");
	}

	private static boolean isJsonFile(Path path) {
		return path.getFileName().toString().endsWith(".json");
	}

	private static java.util.Optional<SnapshotRun> readRun(QueryPlanCapture capture, Path path) {
		try {
			QueryPlanSnapshot snapshot = capture.readSnapshot(path);
			return java.util.Optional.of(new SnapshotRun(path, snapshot, epochMillis(snapshot)));
		} catch (Exception ignored) {
			return java.util.Optional.empty();
		}
	}

	private static long epochMillis(QueryPlanSnapshot snapshot) {
		if (snapshot == null || snapshot.getCapturedAt() == null) {
			return Long.MIN_VALUE;
		}
		try {
			return Instant.parse(snapshot.getCapturedAt()).toEpochMilli();
		} catch (Exception ignored) {
			return Long.MIN_VALUE;
		}
	}

	private enum SignatureAspect {
		STRUCTURE,
		JOIN_ALGORITHMS,
		ACTUAL_RESULT_SIZES,
		ESTIMATES
	}

	private static final class SemanticDiff {
		private final String structure;
		private final String joinAlgorithms;
		private final String actualResultSizes;
		private final String estimates;

		private SemanticDiff(String structure, String joinAlgorithms, String actualResultSizes, String estimates) {
			this.structure = structure;
			this.joinAlgorithms = joinAlgorithms;
			this.actualResultSizes = actualResultSizes;
			this.estimates = estimates;
		}

		private static SemanticDiff unavailable(String reason) {
			String unavailable = "unavailable(" + reason + ")";
			return new SemanticDiff(unavailable, unavailable, unavailable, unavailable);
		}
	}

	static final class PlanDifferenceDiagnosis {
		private final String likelyCause;
		private final String evidence;

		private PlanDifferenceDiagnosis(String likelyCause, String evidence) {
			this.likelyCause = likelyCause;
			this.evidence = evidence;
		}

		String likelyCause() {
			return likelyCause;
		}

		String evidence() {
			return evidence;
		}
	}

	static final class ComparisonSummary {
		private final String unoptimizedFingerprint;
		private final String queryString;
		private final Map<String, LevelDiff> explanationDiffs;
		private final QueryPlanExecutedWorkComparator.ExecutedWorkComparison executedWorkComparison;
		private final PlanDifferenceDiagnosis planDifferenceDiagnosis;

		private ComparisonSummary(String unoptimizedFingerprint, String queryString,
				Map<String, LevelDiff> explanationDiffs,
				QueryPlanExecutedWorkComparator.ExecutedWorkComparison executedWorkComparison,
				PlanDifferenceDiagnosis planDifferenceDiagnosis) {
			this.unoptimizedFingerprint = unoptimizedFingerprint;
			this.queryString = queryString;
			this.explanationDiffs = explanationDiffs;
			this.executedWorkComparison = executedWorkComparison;
			this.planDifferenceDiagnosis = planDifferenceDiagnosis;
		}

		String unoptimizedFingerprint() {
			return unoptimizedFingerprint;
		}

		String queryString() {
			return queryString;
		}

		Map<String, LevelDiff> explanationDiffs() {
			return explanationDiffs;
		}

		QueryPlanExecutedWorkComparator.ExecutedWorkComparison executedWorkComparison() {
			return executedWorkComparison;
		}

		PlanDifferenceDiagnosis planDifferenceDiagnosis() {
			return planDifferenceDiagnosis;
		}
	}

	static final class LevelDiff {
		private final String tupleExprJson;
		private final String irRenderedQuery;
		private final String structure;
		private final String joinAlgorithms;
		private final String actualResultSizes;
		private final String estimates;

		private LevelDiff(String tupleExprJson, String irRenderedQuery, String structure, String joinAlgorithms,
				String actualResultSizes, String estimates) {
			this.tupleExprJson = tupleExprJson;
			this.irRenderedQuery = irRenderedQuery;
			this.structure = structure;
			this.joinAlgorithms = joinAlgorithms;
			this.actualResultSizes = actualResultSizes;
			this.estimates = estimates;
		}

		private static LevelDiff missing(String missingStatus) {
			return new LevelDiff(missingStatus, missingStatus, missingStatus, missingStatus, missingStatus,
					missingStatus);
		}

		String tupleExprJson() {
			return tupleExprJson;
		}

		String irRenderedQuery() {
			return irRenderedQuery;
		}

		String structure() {
			return structure;
		}

		String joinAlgorithms() {
			return joinAlgorithms;
		}

		String actualResultSizes() {
			return actualResultSizes;
		}

		String estimates() {
			return estimates;
		}
	}

	static final class SnapshotRun {
		private final Path path;
		private final QueryPlanSnapshot snapshot;
		private final long epochMillis;

		SnapshotRun(Path path, QueryPlanSnapshot snapshot, long epochMillis) {
			this.path = path;
			this.snapshot = snapshot;
			this.epochMillis = epochMillis;
		}

		QueryPlanSnapshot snapshot() {
			return snapshot;
		}

		Path path() {
			return path;
		}
	}
}
