/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import java.io.IOException;
import java.io.PrintStream;
import java.util.List;

import org.jline.terminal.Attributes;
import org.jline.terminal.Terminal;
import org.jline.terminal.TerminalBuilder;
import org.jline.utils.InfoCmp;
import org.jline.utils.NonBlockingReader;

final class JLineChoiceMenu implements AutoCloseable {

	private static final int KEY_ESCAPE = 27;
	private static final int KEY_ENTER_CR = '\r';
	private static final int KEY_ENTER_LF = '\n';
	private static final int ESCAPE_SEQUENCE_TIMEOUT_MILLIS = 30;
	private static final String FALLBACK_CLEAR_LINE = "\r                                                                                \r";

	private final Terminal terminal;
	private final NonBlockingReader reader;

	private JLineChoiceMenu(Terminal terminal) {
		this.terminal = terminal;
		this.reader = terminal.reader();
	}

	static JLineChoiceMenu tryCreate(PrintStream output) {
		try {
			Terminal terminal = TerminalBuilder.builder()
					.system(true)
					.streams(System.in, output)
					.build();
			if (isUnsupportedTerminal(terminal)) {
				terminal.close();
				return null;
			}
			return new JLineChoiceMenu(terminal);
		} catch (Exception ignored) {
			return null;
		}
	}

	Integer promptChoiceIndex(String message, List<String> options) {
		Attributes originalAttributes = terminal.enterRawMode();
		int selected = 0;
		try {
			renderOptions(message, options);
			while (true) {
				renderSelection(options, selected);
				int key = reader.read();
				if (key < 0) {
					return null;
				}
				if (key == KEY_ENTER_CR || key == KEY_ENTER_LF) {
					clearSelectionLine();
					terminal.writer().println("Selected: " + options.get(selected));
					return selected;
				}
				if (key == 'k' || key == 'K') {
					selected = previousIndex(selected, options.size());
					continue;
				}
				if (key == 'j' || key == 'J') {
					selected = nextIndex(selected, options.size());
					continue;
				}
				if (key >= '1' && key <= '9') {
					int index = key - '1';
					if (index < options.size()) {
						return index;
					}
					continue;
				}
				if (key == KEY_ESCAPE) {
					int sequenceStart = reader.read(ESCAPE_SEQUENCE_TIMEOUT_MILLIS);
					if (sequenceStart != '[' && sequenceStart != 'O') {
						continue;
					}
					int sequenceCode = reader.read(ESCAPE_SEQUENCE_TIMEOUT_MILLIS);
					if (sequenceCode == 'A' || sequenceCode == 'D') {
						selected = previousIndex(selected, options.size());
					} else if (sequenceCode == 'B' || sequenceCode == 'C') {
						selected = nextIndex(selected, options.size());
					}
				}
			}
		} catch (Exception ignored) {
			return null;
		} finally {
			clearSelectionLine();
			terminal.setAttributes(originalAttributes);
			terminal.writer().flush();
		}
	}

	private void renderOptions(String message, List<String> options) {
		terminal.writer().println(message + ":");
		for (int i = 0; i < options.size(); i++) {
			terminal.writer().println("  [" + (i + 1) + "] " + options.get(i));
		}
		terminal.writer().println("Use Up/Down arrows (or j/k), Enter to select.");
		terminal.writer().flush();
	}

	private void renderSelection(List<String> options, int selected) {
		clearSelectionLine();
		terminal.writer()
				.print("Selection: [" + (selected + 1) + "] " + options.get(selected));
		terminal.writer().flush();
	}

	private void clearSelectionLine() {
		if (terminal.getStringCapability(InfoCmp.Capability.carriage_return) != null) {
			terminal.puts(InfoCmp.Capability.carriage_return);
		} else {
			terminal.writer().print('\r');
		}
		if (terminal.getStringCapability(InfoCmp.Capability.clr_eol) != null) {
			terminal.puts(InfoCmp.Capability.clr_eol);
		} else {
			terminal.writer().print(FALLBACK_CLEAR_LINE);
		}
		terminal.writer().flush();
	}

	private static boolean isUnsupportedTerminal(Terminal terminal) {
		String terminalType = terminal.getType();
		return "dumb".equalsIgnoreCase(terminalType);
	}

	private static int nextIndex(int current, int size) {
		return (current + 1) % size;
	}

	private static int previousIndex(int current, int size) {
		return (current - 1 + size) % size;
	}

	@Override
	public void close() throws IOException {
		terminal.close();
	}
}
