/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.benchmark.plan;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanExplanation;
import org.eclipse.rdf4j.benchmark.common.plan.QueryPlanSnapshot;
import org.junit.jupiter.api.Test;

class QueryPlanSnapshotComparatorTest {

	@Test
	void semanticDiffIgnoresEstimateOnlyChangesByDefault() {
		QueryPlanSnapshot left = snapshotWithOptimizedJson(explanationJson(1.0, 2.0, 7));
		QueryPlanSnapshot right = snapshotWithOptimizedJson(explanationJson(99.0, 88.0, 7));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("structure=same"));
		assertTrue(output.contains("joinAlgorithms=same"));
		assertTrue(output.contains("actualResultSizes=same"));
		assertTrue(output.contains("estimates=ignored"));
	}

	@Test
	void semanticDiffCanIncludeEstimateChanges() {
		QueryPlanSnapshot left = snapshotWithOptimizedJson(explanationJson(1.0, 2.0, 7));
		QueryPlanSnapshot right = snapshotWithOptimizedJson(explanationJson(99.0, 88.0, 7));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right),
				QueryPlanSnapshotCliOptions.DiffMode.STRUCTURE_WITH_ESTIMATES);

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("actualResultSizes=same"));
		assertTrue(output.contains("estimates=diff"));
	}

	@Test
	void semanticDiffIgnoresAnonymousHavingVariableNameDrift() {
		QueryPlanSnapshot left = snapshotWithOptimizedJson(explanationJsonWithAnonymousHavingName(
				"_anon_having_394440ef6ac92f1f44af483210db23bce3403012"));
		QueryPlanSnapshot right = snapshotWithOptimizedJson(explanationJsonWithAnonymousHavingName(
				"_anon_having_8644416ef2aaea93e425996586130076565d001234567"));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("structure=same"), output);
		assertTrue(output.contains("joinAlgorithms=same"), output);
	}

	@Test
	void semanticDiffIgnoresAnonymousPathVariableNameDrift() {
		QueryPlanSnapshot left = snapshotWithOptimizedJson(explanationJsonWithAnonymousPathName(
				"_anon_path_00660ef6ac92f1f44af483210db23bce3403"));
		QueryPlanSnapshot right = snapshotWithOptimizedJson(explanationJsonWithAnonymousPathName(
				"_anon_path_006616ef2aaea93e425996586130076565d0"));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("structure=same"), output);
		assertTrue(output.contains("joinAlgorithms=same"), output);
	}

	@Test
	void printRunDetailsIncludesFullExplanationText() {
		QueryPlanExplanation explanation = new QueryPlanExplanation();
		explanation.setLevel("optimized");
		explanation.setTupleExprJson("tuple-expr");
		explanation.setIrRenderedQuery("SELECT * WHERE { ?s ?p ?o }");
		explanation
				.setExplanationText("line-01-abcdefghij\nline-02-abcdefghij\nline-03-abcdefghij\nline-04-abcdefghij\n"
						+ "line-05-abcdefghij\nline-06-abcdefghij\nline-07-abcdefghij\nline-08-abcdefghij\n"
						+ "line-09-abcdefghij\nline-10-abcdefghij\nline-11-abcdefghij\nline-12-abcdefghij\n"
						+ "line-13-abcdefghij\nline-14-abcdefghij\nline-15-abcdefghij\nline-16-abcdefghij\n"
						+ "line-17-abcdefghij\nline-18-abcdefghij\nline-19-abcdefghij\nline-20-tail-marker");

		QueryPlanSnapshot snapshot = new QueryPlanSnapshot();
		snapshot.setCapturedAt("2026-02-17T10:00:00Z");
		snapshot.setQueryId("q0");
		snapshot.setQueryString("SELECT * WHERE { ?s ?p ?o }");
		snapshot.setUnoptimizedFingerprint("abc123");
		LinkedHashMap<String, QueryPlanExplanation> explanations = new LinkedHashMap<>();
		explanations.put("optimized", explanation);
		snapshot.setExplanations(explanations);

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printRunDetails(new PrintStream(capture),
				QueryPlanSnapshotComparator.inMemoryRun(snapshot));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("line-20-tail-marker"), output);
	}

	@Test
	void printComparisonIncludesExecutedModeledWorkVerdict() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "100"),
						Map.entry("modeledSelfTimeActualSum", "40"),
						Map.entry("modeledInputRowsSum", "500"),
						Map.entry("modeledOutputRowsSum", "140"),
						Map.entry("modeledJoinInputRowsSum", "200"),
						Map.entry("modeledJoinOutputRowsSum", "80"),
						Map.entry("modeledBarrierCount", "3"),
						Map.entry("estimateActualQErrorP95", "2.5"),
						Map.entry("joinEstimateActualQErrorP95", "3.0"),
						Map.entry("modeledWorkByCategory", "join=100;scan=25"),
						Map.entry("operatorWorkByTypeAlgorithm",
								"Join[JoinIterator]|nodes=1|workUnits=100|inputRows=200|outputRows=80|selfTimeActual=11|totalTimeActual=21;"
										+ "StatementPattern[UNKNOWN]|nodes=2|workUnits=25|inputRows=25|outputRows=25|selfTimeActual=2|totalTimeActual=4")));
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "125"),
						Map.entry("modeledSelfTimeActualSum", "65"),
						Map.entry("modeledInputRowsSum", "820"),
						Map.entry("modeledOutputRowsSum", "230"),
						Map.entry("modeledJoinInputRowsSum", "260"),
						Map.entry("modeledJoinOutputRowsSum", "95"),
						Map.entry("modeledBarrierCount", "5"),
						Map.entry("estimateActualQErrorP95", "4.0"),
						Map.entry("joinEstimateActualQErrorP95", "5.5"),
						Map.entry("modeledWorkByCategory", "join=125;scan=30"),
						Map.entry("operatorWorkByTypeAlgorithm",
								"Join[JoinIterator]|nodes=1|workUnits=125|inputRows=260|outputRows=95|selfTimeActual=13|totalTimeActual=25;"
										+ "StatementPattern[UNKNOWN]|nodes=2|workUnits=30|inputRows=30|outputRows=30|selfTimeActual=3|totalTimeActual=5")));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("executedWorkModel:"), output);
		assertTrue(output.contains("winner=left"), output);
		assertTrue(output.contains("topCategoryDeltas=join:+25"), output);
		assertTrue(output.contains("topOperatorDeltas=Join[JoinIterator]:+25"), output);
		assertTrue(output.contains("topVectorDeltas="), output);
		assertTrue(output.contains("modeledInputRowsSum:+320"), output);
		assertTrue(output.contains("dominantResourceLeft="), output);
		assertTrue(output.contains("dominantResourceRight="), output);
		assertTrue(output.contains("topResourceDeltas="), output);
	}

	@Test
	void printComparisonSupportsLegacyExecutedLevelDebugMetrics() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "100"),
						Map.entry("modeledSelfTimeActualSum", "40"),
						Map.entry("modeledInputRowsSum", "500"),
						Map.entry("modeledOutputRowsSum", "140"),
						Map.entry("modeledJoinInputRowsSum", "200"),
						Map.entry("modeledJoinOutputRowsSum", "80"),
						Map.entry("modeledBarrierCount", "3"),
						Map.entry("estimateActualQErrorP95", "2.5"),
						Map.entry("joinEstimateActualQErrorP95", "3.0"),
						Map.entry("modeledWorkByCategory", "join=100;scan=25"),
						Map.entry("operatorWorkByTypeAlgorithm",
								"Join[JoinIterator]|nodes=1|workUnits=100|inputRows=200|outputRows=80|selfTimeActual=11|totalTimeActual=21;"
										+ "StatementPattern[UNKNOWN]|nodes=2|workUnits=25|inputRows=25|outputRows=25|selfTimeActual=2|totalTimeActual=4")),
				Map.of(), Map.of(), Map.of());
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "125"),
						Map.entry("modeledSelfTimeActualSum", "65"),
						Map.entry("modeledInputRowsSum", "820"),
						Map.entry("modeledOutputRowsSum", "230"),
						Map.entry("modeledJoinInputRowsSum", "260"),
						Map.entry("modeledJoinOutputRowsSum", "95"),
						Map.entry("modeledBarrierCount", "5"),
						Map.entry("estimateActualQErrorP95", "4.0"),
						Map.entry("joinEstimateActualQErrorP95", "5.5"),
						Map.entry("modeledWorkByCategory", "join=125;scan=30"),
						Map.entry("operatorWorkByTypeAlgorithm",
								"Join[JoinIterator]|nodes=1|workUnits=125|inputRows=260|outputRows=95|selfTimeActual=13|totalTimeActual=25;"
										+ "StatementPattern[UNKNOWN]|nodes=2|workUnits=30|inputRows=30|outputRows=30|selfTimeActual=3|totalTimeActual=5")),
				Map.of(), Map.of(), Map.of());

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("executedWorkModel:"), output);
		assertFalse(output.contains("unavailableReason=missing-executed-modeledWorkUnits"), output);
		assertTrue(output.contains("topCategoryDeltas=join:+25"), output);
	}

	@Test
	void printComparisonUsesTopContributorFallbackWhenAlgorithmBreakdownMissing() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "100"),
						Map.entry("modeledSelfTimeActualSum", "40"),
						Map.entry("modeledInputRowsSum", "500"),
						Map.entry("modeledOutputRowsSum", "140"),
						Map.entry("modeledJoinInputRowsSum", "200"),
						Map.entry("modeledJoinOutputRowsSum", "80"),
						Map.entry("modeledBarrierCount", "3"),
						Map.entry("estimateActualQErrorP95", "2.5"),
						Map.entry("joinEstimateActualQErrorP95", "3.0"),
						Map.entry("modeledWorkByCategory", "join=100;scan=25"),
						Map.entry("operatorWorkTopContributors",
								"Join[JoinIterator]:100;StatementPattern[UNKNOWN]:25")),
				Map.of(), Map.of(), Map.of());
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "125"),
						Map.entry("modeledSelfTimeActualSum", "65"),
						Map.entry("modeledInputRowsSum", "820"),
						Map.entry("modeledOutputRowsSum", "230"),
						Map.entry("modeledJoinInputRowsSum", "260"),
						Map.entry("modeledJoinOutputRowsSum", "95"),
						Map.entry("modeledBarrierCount", "5"),
						Map.entry("estimateActualQErrorP95", "4.0"),
						Map.entry("joinEstimateActualQErrorP95", "5.5"),
						Map.entry("modeledWorkByCategory", "join=125;scan=30"),
						Map.entry("operatorWorkTopContributors",
								"Join[JoinIterator]:125;StatementPattern[UNKNOWN]:30")),
				Map.of(), Map.of(), Map.of());

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("topOperatorDeltas=Join[JoinIterator]:+25"), output);
	}

	@Test
	void printComparisonUsesAdditionalTelemetryScalarsWhenPresent() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "100"),
						Map.entry("modeledInputRowsSum", "500"),
						Map.entry("modeledOutputRowsSum", "140"),
						Map.entry("modeledJoinInputRowsSum", "200"),
						Map.entry("modeledJoinOutputRowsSum", "80"),
						Map.entry("modeledTotalTimeActualSum", "20")));
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.ofEntries(
						Map.entry("modeledWorkUnits", "100"),
						Map.entry("modeledInputRowsSum", "500"),
						Map.entry("modeledOutputRowsSum", "140"),
						Map.entry("modeledJoinInputRowsSum", "200"),
						Map.entry("modeledJoinOutputRowsSum", "80"),
						Map.entry("modeledTotalTimeActualSum", "620")));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("winner=left"), output);
		assertTrue(output.contains("modeledTotalTimeActualSum:+600"), output);
	}

	@Test
	void printComparisonIncludesPlanDifferenceDiagnosis() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.of(),
				Map.of(
						"planDeterminism.inputFingerprintSha256", "input-same",
						"planDeterminism.environmentFingerprintSha256", "env-same",
						"featureFlags.sha256", "flags-left",
						"optimizerInput.unoptimizedStructureNormalizedSha256", "structure-same"));
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.of(),
				Map.of(
						"planDeterminism.inputFingerprintSha256", "input-same",
						"planDeterminism.environmentFingerprintSha256", "env-same",
						"featureFlags.sha256", "flags-right",
						"optimizerInput.unoptimizedStructureNormalizedSha256", "structure-same"));

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("planDifferenceDiagnosis:"), output);
		assertTrue(output.contains("likelyCause=different-feature-flags"), output);
		assertTrue(output.contains("featureFlags=diff"), output);
	}

	@Test
	void printComparisonDiagnosesOptimizerStructureDriftWithStableEstimates() {
		Map<String, String> sharedMetadata = Map.of(
				"planDeterminism.inputFingerprintSha256", "input-same",
				"planDeterminism.environmentFingerprintSha256", "env-same",
				"featureFlags.sha256", "flags-same",
				"optimizerInput.unoptimizedStructureNormalizedSha256", "structure-same");
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.of(),
				sharedMetadata,
				Map.of(
						"structureSignatureNormalizedSha256", "optimized-structure-left",
						"estimatesMultisetSignatureSha256", "optimized-estimates-same",
						"statementPatternEstimatesMultisetSignatureSha256", "optimized-sp-estimates-same",
						"joinAlgorithmMultisetSignatureSha256", "optimized-joins-same"),
				Map.of());
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.of(),
				sharedMetadata,
				Map.of(
						"structureSignatureNormalizedSha256", "optimized-structure-right",
						"estimatesMultisetSignatureSha256", "optimized-estimates-same",
						"statementPatternEstimatesMultisetSignatureSha256", "optimized-sp-estimates-same",
						"joinAlgorithmMultisetSignatureSha256", "optimized-joins-same"),
				Map.of());

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("likelyCause=optimizer-structure-drift-with-stable-estimates"), output);
	}

	@Test
	void printComparisonDoesNotBlameOptimizerInputWhenFingerprintIsUnknown() {
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson(1.0, 2.0, 7),
				Map.of());
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutedDebugMetrics(
				"{\"type\":\"Projection\",\"plans\":[]}",
				Map.of());

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("inputFingerprint=unknown"), output);
		assertTrue(output.contains("likelyCause=unknown"), output);
	}

	@Test
	void printComparisonDiagnosesRuntimePlanDriftWithLegacyExecutedDiff() {
		Map<String, String> sharedMetadata = Map.of(
				"planDeterminism.inputFingerprintSha256", "input-same",
				"planDeterminism.environmentFingerprintSha256", "env-same",
				"featureFlags.sha256", "flags-same",
				"optimizerInput.unoptimizedStructureNormalizedSha256", "structure-same");
		QueryPlanSnapshot left = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", "{\"type\":\"Join\",\"plans\":[{\"type\":\"StatementPattern\"}]}",
				Map.of(
						"modeledWorkUnits", "100"),
				sharedMetadata,
				Map.of(
						"structureSignatureNormalizedSha256", "optimized-structure-same",
						"estimatesMultisetSignatureSha256", "optimized-estimates-same",
						"statementPatternEstimatesMultisetSignatureSha256", "optimized-sp-estimates-same",
						"joinAlgorithmMultisetSignatureSha256", "optimized-joins-same"),
				Map.of());
		QueryPlanSnapshot right = snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson(1.0, 2.0, 7),
				"executed", "executed", "{\"type\":\"LeftJoin\",\"plans\":[{\"type\":\"StatementPattern\"}]}",
				Map.of(
						"modeledWorkUnits", "100"),
				sharedMetadata,
				Map.of(
						"structureSignatureNormalizedSha256", "optimized-structure-same",
						"estimatesMultisetSignatureSha256", "optimized-estimates-same",
						"statementPatternEstimatesMultisetSignatureSha256", "optimized-sp-estimates-same",
						"joinAlgorithmMultisetSignatureSha256", "optimized-joins-same"),
				Map.of());

		ByteArrayOutputStream capture = new ByteArrayOutputStream();
		QueryPlanSnapshotComparator.printComparison(new PrintStream(capture), run(left), run(right));

		String output = capture.toString(StandardCharsets.UTF_8);
		assertTrue(output.contains("executedStructure=diff"), output);
		assertTrue(output.contains("likelyCause=runtime-plan-drift"), output);
	}

	private static QueryPlanSnapshotComparator.SnapshotRun run(QueryPlanSnapshot snapshot) {
		return QueryPlanSnapshotComparator.inMemoryRun(snapshot);
	}

	private static QueryPlanSnapshot snapshotWithOptimizedJson(String explanationJson) {
		QueryPlanExplanation explanation = new QueryPlanExplanation();
		explanation.setLevel("optimized");
		explanation.setExplanationJson(explanationJson);
		explanation.setTupleExprJson("tuple-expr");
		explanation.setIrRenderedQuery("SELECT * WHERE { ?s ?p ?o }");

		QueryPlanSnapshot snapshot = new QueryPlanSnapshot();
		snapshot.setCapturedAt("2026-02-17T10:00:00Z");
		snapshot.setQueryId("q0");
		snapshot.setQueryString("SELECT * WHERE { ?s ?p ?o }");
		snapshot.setUnoptimizedFingerprint("abc123");
		LinkedHashMap<String, QueryPlanExplanation> explanations = new LinkedHashMap<>();
		explanations.put("optimized", explanation);
		snapshot.setExplanations(explanations);
		return snapshot;
	}

	private static QueryPlanSnapshot snapshotWithOptimizedJsonAndExecutedDebugMetrics(String explanationJson,
			Map<String, String> executedDebugMetrics) {
		return snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson, executedDebugMetrics, Map.of(),
				Map.of(), Map.of());
	}

	private static QueryPlanSnapshot snapshotWithOptimizedJsonAndExecutedDebugMetrics(String explanationJson,
			Map<String, String> executedDebugMetrics, Map<String, String> metadata) {
		return snapshotWithOptimizedJsonAndExecutedDebugMetrics(explanationJson, executedDebugMetrics, metadata,
				Map.of(), Map.of());
	}

	private static QueryPlanSnapshot snapshotWithOptimizedJsonAndExecutedDebugMetrics(String explanationJson,
			Map<String, String> executedDebugMetrics, Map<String, String> metadata,
			Map<String, String> optimizedDebugMetrics, Map<String, String> unoptimizedDebugMetrics) {
		return snapshotWithOptimizedJsonAndExecutionDebugMetrics(explanationJson, "telemetry", "telemetry", null,
				executedDebugMetrics, metadata, optimizedDebugMetrics, unoptimizedDebugMetrics);
	}

	private static QueryPlanSnapshot snapshotWithOptimizedJsonAndExecutionDebugMetrics(String explanationJson,
			String executionLevelKey, String executionLevel,
			String executionExplanationJson,
			Map<String, String> executionDebugMetrics, Map<String, String> metadata,
			Map<String, String> optimizedDebugMetrics, Map<String, String> unoptimizedDebugMetrics) {
		QueryPlanExplanation optimized = new QueryPlanExplanation();
		optimized.setLevel("optimized");
		optimized.setExplanationJson(explanationJson);
		optimized.setTupleExprJson("tuple-expr");
		optimized.setIrRenderedQuery("SELECT * WHERE { ?s ?p ?o }");
		optimized.setDebugMetrics(new LinkedHashMap<>(optimizedDebugMetrics));

		QueryPlanExplanation unoptimized = new QueryPlanExplanation();
		unoptimized.setLevel("unoptimized");
		unoptimized.setExplanationText("unoptimized-plan");
		unoptimized.setDebugMetrics(new LinkedHashMap<>(unoptimizedDebugMetrics));

		QueryPlanExplanation executed = new QueryPlanExplanation();
		executed.setLevel(executionLevel);
		executed.setExplanationJson(executionExplanationJson);
		executed.setExplanationText("executed-plan");
		executed.setDebugMetrics(new LinkedHashMap<>(executionDebugMetrics));

		QueryPlanSnapshot snapshot = new QueryPlanSnapshot();
		snapshot.setCapturedAt("2026-02-17T10:00:00Z");
		snapshot.setQueryId("q0");
		snapshot.setQueryString("SELECT * WHERE { ?s ?p ?o }");
		snapshot.setUnoptimizedFingerprint("abc123");
		snapshot.setMetadata(new LinkedHashMap<>(metadata));
		LinkedHashMap<String, QueryPlanExplanation> explanations = new LinkedHashMap<>();
		explanations.put("unoptimized", unoptimized);
		explanations.put("optimized", optimized);
		explanations.put(executionLevelKey, executed);
		snapshot.setExplanations(explanations);
		return snapshot;
	}

	private static String explanationJson(double costEstimate, double resultSizeEstimate, int resultSizeActual) {
		return "{\n"
				+ "  \"type\": \"Join\",\n"
				+ "  \"algorithm\": \"HashJoinIteration\",\n"
				+ "  \"costEstimate\": " + costEstimate + ",\n"
				+ "  \"resultSizeEstimate\": " + resultSizeEstimate + ",\n"
				+ "  \"resultSizeActual\": " + resultSizeActual + ",\n"
				+ "  \"plans\": [\n"
				+ "    {\"type\": \"StatementPattern\", \"resultSizeActual\": 3},\n"
				+ "    {\"type\": \"StatementPattern\", \"resultSizeActual\": 4}\n"
				+ "  ]\n"
				+ "}";
	}

	private static String explanationJsonWithAnonymousHavingName(String anonymousHavingName) {
		return "{\n"
				+ "  \"type\": \"Projection\",\n"
				+ "  \"plans\": [\n"
				+ "    {\n"
				+ "      \"type\": \"GroupElem (" + anonymousHavingName + ")\",\n"
				+ "      \"plans\": [\n"
				+ "        {\"type\": \"Var (name=" + anonymousHavingName + ", anonymous)\"}\n"
				+ "      ]\n"
				+ "    },\n"
				+ "    {\n"
				+ "      \"type\": \"ExtensionElem (" + anonymousHavingName + ")\",\n"
				+ "      \"plans\": [\n"
				+ "        {\"type\": \"Var (name=" + anonymousHavingName + ", anonymous)\"}\n"
				+ "      ]\n"
				+ "    }\n"
				+ "  ]\n"
				+ "}";
	}

	private static String explanationJsonWithAnonymousPathName(String anonymousPathName) {
		return "{\n"
				+ "  \"type\": \"Projection\",\n"
				+ "  \"plans\": [\n"
				+ "    {\n"
				+ "      \"type\": \"ExtensionElem (" + anonymousPathName + ")\",\n"
				+ "      \"plans\": [\n"
				+ "        {\"type\": \"Var (name=" + anonymousPathName + ", anonymous)\"}\n"
				+ "      ]\n"
				+ "    }\n"
				+ "  ]\n"
				+ "}";
	}
}
