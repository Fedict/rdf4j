/*******************************************************************************
 * Copyright (c) 2020 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.explanation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import org.apache.commons.text.StringEscapeUtils;
import org.eclipse.rdf4j.common.annotation.Experimental;

import com.fasterxml.jackson.annotation.JsonIgnore;

/**
 * This is an experimental feature. The interface may be changed, moved or potentially removed in a future release.
 * <p>
 * The interface is used to implement query explanations (query plan)
 *
 * @since 3.2.0
 */
@Experimental
public class GenericPlanNode {

	public static final String UNKNOWN = "UNKNOWN";

	// static UUID as prefix together with a thread safe incrementing long ensures a unique identifier.
	private final static String uniqueIdPrefix = UUID.randomUUID().toString().replace("-", "");
	private final static AtomicLong uniqueIdSuffix = new AtomicLong();

	private static final String spoc[] = { "s", "p", "o", "c" };

	private final static String newLine = System.getProperty("line.separator");
	private static final Pattern OFFSET_PATTERN = Pattern.compile("offset=([0-9]+)");
	private static final Pattern LIMIT_PATTERN = Pattern.compile("limit=([0-9]+)");
	private static final Set<String> JOIN_ONLY_METRICS = Set.of(
			TelemetryMetricNames.LEFT_ROWS_PROBED_ACTUAL,
			TelemetryMetricNames.RIGHT_ROWS_SCANNED_ACTUAL,
			TelemetryMetricNames.AVG_RIGHT_ROWS_PER_LEFT_ACTUAL,
			TelemetryMetricNames.EMPTY_RIGHT_PROBE_COUNT_ACTUAL,
			TelemetryMetricNames.MAX_RIGHT_ROWS_PER_LEFT_ACTUAL,
			TelemetryMetricNames.JOIN_MATCH_RATE_ACTUAL,
			TelemetryMetricNames.JOIN_OUTPUT_PER_LEFT_ACTUAL,
			TelemetryMetricNames.LEFT_ROWS_WITH_MATCH_ACTUAL,
			TelemetryMetricNames.LEFT_JOIN_NULL_EXTENDED_ROWS_ACTUAL,
			TelemetryMetricNames.LEFT_JOIN_CONDITION_REJECTED_ROWS_ACTUAL);
	private static final Set<String> FILTER_ONLY_METRICS = Set.of(
			TelemetryMetricNames.FILTER_REJECT_RATE_ACTUAL,
			TelemetryMetricNames.PREDICATE_ERROR_COUNT_ACTUAL,
			TelemetryMetricNames.PREDICATE_NULL_COUNT_ACTUAL);
	private static final Set<String> ORDER_ONLY_METRICS = Set.of(
			TelemetryMetricNames.ROWS_SORTED_ACTUAL,
			TelemetryMetricNames.SPILL_COUNT_ACTUAL,
			TelemetryMetricNames.SPILL_BYTES_ACTUAL,
			TelemetryMetricNames.SORT_COMPARISONS_ACTUAL);
	private static final Set<String> GROUP_ONLY_METRICS = Set.of(
			TelemetryMetricNames.GROUPS_CREATED_ACTUAL,
			TelemetryMetricNames.AVG_GROUP_SIZE_ACTUAL,
			TelemetryMetricNames.MAX_GROUP_SIZE_ACTUAL,
			TelemetryMetricNames.AGGREGATE_EVAL_COUNT_ACTUAL);
	private static final Set<String> SLICE_ONLY_METRICS = Set.of(
			TelemetryMetricNames.ROWS_SKIPPED_BY_OFFSET_ACTUAL,
			TelemetryMetricNames.ROWS_DROPPED_BY_LIMIT_ACTUAL);
	private static final Set<String> SERVICE_ONLY_METRICS = Set.of(
			TelemetryMetricNames.REMOTE_REQUEST_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_ASK_REQUEST_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_SELECT_REQUEST_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_EVALUATE_REQUEST_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_BYTES_SENT_ACTUAL,
			TelemetryMetricNames.REMOTE_BYTES_RECEIVED_ACTUAL,
			TelemetryMetricNames.REMOTE_RETRY_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_TIMEOUT_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_ERROR_COUNT_ACTUAL,
			TelemetryMetricNames.REMOTE_LATENCY_TOTAL_NANOS_ACTUAL,
			TelemetryMetricNames.REMOTE_LATENCY_P50_NANOS_ACTUAL,
			TelemetryMetricNames.REMOTE_LATENCY_P95_NANOS_ACTUAL);
	private static final Set<String> SET_OPERATOR_ONLY_METRICS = Set.of(
			TelemetryMetricNames.LEFT_ROWS_CONSUMED_ACTUAL,
			TelemetryMetricNames.RIGHT_ROWS_CONSUMED_ACTUAL,
			TelemetryMetricNames.LEFT_ROWS_OUTPUT_CONTRIBUTION_ACTUAL,
			TelemetryMetricNames.RIGHT_ROWS_OUTPUT_CONTRIBUTION_ACTUAL,
			TelemetryMetricNames.OVERLAP_ROWS_ACTUAL);
	private static final Set<String> ACCESS_ONLY_METRICS = Set.of(
			TelemetryMetricNames.INDEX_LOOKUP_COUNT_ACTUAL,
			TelemetryMetricNames.INDEX_HIT_RATE_ACTUAL,
			TelemetryMetricNames.INDEX_NAME);

	private final String id = "UUID_" + uniqueIdPrefix + uniqueIdSuffix.incrementAndGet();

	// The name of the node, eg. "Join" or "Join (HashJoinIteration)".
	private String type;

	// Retrieving the explanation timed out while the query was executed.
	private Boolean timedOut;

	// The cost estimate that the query planner calculated for this node. Value has no meaning outside of this
	// explanation and is only used to compare and order the nodes in the query plan.
	private Double costEstimate;

	// The number of results that this node was estimated to produce.
	private Double resultSizeEstimate;

	// The actual number of results that this node produced while the query was executed.
	private Long resultSizeActual;

	// The total time in milliseconds that this node-tree (all children and so on) used while the query was executed.
	// selfTimeActual is the amount of time that this node used by itself (eg. totalTimeActual - sum of
	// plans[0..n].totalTimeActual)
	private Double totalTimeActual;

	// Telemetry counters captured while iterating this node during telemetry-level explanations.
	private Long hasNextCallCountActual;
	private Long hasNextTrueCountActual;
	private Long hasNextTimeNanosActual;
	private Long nextCallCountActual;
	private Long nextTimeNanosActual;
	private Long joinRightIteratorsCreatedActual;
	private Long joinLeftBindingsConsumedActual;
	private Long joinRightBindingsConsumedActual;
	private Long sourceRowsScannedActual;
	private Long sourceRowsMatchedActual;
	private Long sourceRowsFilteredActual;
	private boolean runtimeTelemetryEnabled = true;
	private Map<String, Long> longMetricsActual = new LinkedHashMap<>();
	private Map<String, Double> doubleMetricsActual = new LinkedHashMap<>();
	private Map<String, String> stringMetricsActual = new LinkedHashMap<>();

	// true if this node introduces a new scope
	private Boolean newScope;

	// the name of the algorithm used as an annotation to the node type
	private String algorithm;

	// Child plans for this node
	private List<GenericPlanNode> plans = new ArrayList<>();

	public GenericPlanNode() {
	}

	public GenericPlanNode(String type) {
		this.type = type;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public List<GenericPlanNode> getPlans() {
		return plans.isEmpty() ? null : plans; // for simplified json
	}

	public void setPlans(List<GenericPlanNode> plans) {
		this.plans = plans;
	}

	public void addPlans(GenericPlanNode... children) {
		this.plans.addAll(Arrays.asList(children));
	}

	/**
	 * The cost estimate that the query planner calculated for this node. Value has no meaning outside of this
	 * explanation and is only used to compare and order the nodes in the query plan.
	 *
	 * @return a cost estimate as a double value
	 */
	public Double getCostEstimate() {
		return costEstimate;
	}

	public void setCostEstimate(Double costEstimate) {
		if (costEstimate >= 0) {
			this.costEstimate = costEstimate;
		}
	}

	/**
	 * The number of results that this node was estimated to produce.
	 *
	 * @return result size estimate
	 */
	public Double getResultSizeEstimate() {
		return resultSizeEstimate;
	}

	public void setResultSizeEstimate(Double resultSizeEstimate) {
		if (resultSizeEstimate >= 0) {
			this.resultSizeEstimate = resultSizeEstimate;
		}
	}

	/**
	 * The actual number of results that this node produced while the query was executed.
	 *
	 * @return number of results that this query produced
	 */
	public Long getResultSizeActual() {
		return resultSizeActual;
	}

	public void setResultSizeActual(Long resultSizeActual) {
		if (resultSizeActual >= 0) {
			this.resultSizeActual = resultSizeActual;
		}
	}

	/**
	 * The total time in milliseconds that this node-tree (all children and so on) used while the query was executed.
	 *
	 * @return time in milliseconds that was used to execute the query
	 */
	public Double getTotalTimeActual() {
		// Not all nodes have their own totalTimeActual, but it can easily be calculated by looking that the child plans
		// (recursively). We need this value to calculate the selfTimeActual.
		if (totalTimeActual == null) {
			double sum = plans.stream()
					.map(GenericPlanNode::getTotalTimeActual)
					.filter(Objects::nonNull)
					.mapToDouble(d -> d)
					.sum();

			if (sum > 0) {
				return sum;
			}
		}
		return totalTimeActual;
	}

	public void setTotalTimeActual(Double totalTimeActual) {
		if (totalTimeActual >= 0) {
			this.totalTimeActual = totalTimeActual;
		}
	}

	public Long getHasNextCallCountActual() {
		return hasNextCallCountActual;
	}

	public void setHasNextCallCountActual(Long hasNextCallCountActual) {
		if (hasNextCallCountActual != null && hasNextCallCountActual >= 0) {
			this.hasNextCallCountActual = hasNextCallCountActual;
		}
	}

	public Long getHasNextTrueCountActual() {
		return hasNextTrueCountActual;
	}

	public void setHasNextTrueCountActual(Long hasNextTrueCountActual) {
		if (hasNextTrueCountActual != null && hasNextTrueCountActual >= 0) {
			this.hasNextTrueCountActual = hasNextTrueCountActual;
		}
	}

	public Long getHasNextTimeNanosActual() {
		return hasNextTimeNanosActual;
	}

	public void setHasNextTimeNanosActual(Long hasNextTimeNanosActual) {
		if (hasNextTimeNanosActual != null && hasNextTimeNanosActual >= 0) {
			this.hasNextTimeNanosActual = hasNextTimeNanosActual;
		}
	}

	public Long getNextCallCountActual() {
		return nextCallCountActual;
	}

	public void setNextCallCountActual(Long nextCallCountActual) {
		if (nextCallCountActual != null && nextCallCountActual >= 0) {
			this.nextCallCountActual = nextCallCountActual;
		}
	}

	public Long getNextTimeNanosActual() {
		return nextTimeNanosActual;
	}

	public void setNextTimeNanosActual(Long nextTimeNanosActual) {
		if (nextTimeNanosActual != null && nextTimeNanosActual >= 0) {
			this.nextTimeNanosActual = nextTimeNanosActual;
		}
	}

	public Long getJoinRightIteratorsCreatedActual() {
		return joinRightIteratorsCreatedActual;
	}

	public void setJoinRightIteratorsCreatedActual(Long joinRightIteratorsCreatedActual) {
		if (joinRightIteratorsCreatedActual != null && joinRightIteratorsCreatedActual >= 0) {
			this.joinRightIteratorsCreatedActual = joinRightIteratorsCreatedActual;
		}
	}

	public Long getJoinLeftBindingsConsumedActual() {
		return joinLeftBindingsConsumedActual;
	}

	public void setJoinLeftBindingsConsumedActual(Long joinLeftBindingsConsumedActual) {
		if (joinLeftBindingsConsumedActual != null && joinLeftBindingsConsumedActual >= 0) {
			this.joinLeftBindingsConsumedActual = joinLeftBindingsConsumedActual;
		}
	}

	public Long getJoinRightBindingsConsumedActual() {
		return joinRightBindingsConsumedActual;
	}

	public void setJoinRightBindingsConsumedActual(Long joinRightBindingsConsumedActual) {
		if (joinRightBindingsConsumedActual != null && joinRightBindingsConsumedActual >= 0) {
			this.joinRightBindingsConsumedActual = joinRightBindingsConsumedActual;
		}
	}

	public Long getSourceRowsScannedActual() {
		return sourceRowsScannedActual;
	}

	public void setSourceRowsScannedActual(Long sourceRowsScannedActual) {
		if (sourceRowsScannedActual != null && sourceRowsScannedActual >= 0) {
			this.sourceRowsScannedActual = sourceRowsScannedActual;
		}
	}

	public Long getSourceRowsMatchedActual() {
		return sourceRowsMatchedActual;
	}

	public void setSourceRowsMatchedActual(Long sourceRowsMatchedActual) {
		if (sourceRowsMatchedActual != null && sourceRowsMatchedActual >= 0) {
			this.sourceRowsMatchedActual = sourceRowsMatchedActual;
		}
	}

	public Long getSourceRowsFilteredActual() {
		return sourceRowsFilteredActual;
	}

	public void setSourceRowsFilteredActual(Long sourceRowsFilteredActual) {
		if (sourceRowsFilteredActual != null && sourceRowsFilteredActual >= 0) {
			this.sourceRowsFilteredActual = sourceRowsFilteredActual;
		}
	}

	public void setRuntimeTelemetryEnabled(boolean runtimeTelemetryEnabled) {
		this.runtimeTelemetryEnabled = runtimeTelemetryEnabled;
	}

	public Map<String, Long> getLongMetricsActual() {
		return longMetricsActual.isEmpty() ? null : longMetricsActual;
	}

	public void setLongMetricsActual(Map<String, Long> longMetricsActual) {
		this.longMetricsActual = longMetricsActual == null ? new LinkedHashMap<>()
				: new LinkedHashMap<>(longMetricsActual);
	}

	public Long getLongMetricActual(String metricName) {
		return longMetricsActual.get(metricName);
	}

	public void setLongMetricActual(String metricName, Long metricValue) {
		if (metricName == null || metricValue == null || metricValue < 0) {
			return;
		}
		longMetricsActual.put(metricName, metricValue);
	}

	public Map<String, Double> getDoubleMetricsActual() {
		return doubleMetricsActual.isEmpty() ? null : doubleMetricsActual;
	}

	public void setDoubleMetricsActual(Map<String, Double> doubleMetricsActual) {
		this.doubleMetricsActual = doubleMetricsActual == null ? new LinkedHashMap<>()
				: new LinkedHashMap<>(doubleMetricsActual);
	}

	public Double getDoubleMetricActual(String metricName) {
		return doubleMetricsActual.get(metricName);
	}

	public void setDoubleMetricActual(String metricName, Double metricValue) {
		if (metricName == null || metricValue == null || metricValue < 0) {
			return;
		}
		doubleMetricsActual.put(metricName, metricValue);
	}

	public Map<String, String> getStringMetricsActual() {
		return stringMetricsActual.isEmpty() ? null : stringMetricsActual;
	}

	public void setStringMetricsActual(Map<String, String> stringMetricsActual) {
		this.stringMetricsActual = stringMetricsActual == null ? new LinkedHashMap<>()
				: new LinkedHashMap<>(stringMetricsActual);
	}

	public String getStringMetricActual(String metricName) {
		return stringMetricsActual.get(metricName);
	}

	public void setStringMetricActual(String metricName, String metricValue) {
		if (metricName == null || metricValue == null || metricValue.isEmpty()) {
			return;
		}
		stringMetricsActual.put(metricName, metricValue);
	}

	public void setTimedOut(Boolean timedOut) {
		this.timedOut = timedOut;
	}

	public Boolean getTimedOut() {
		return timedOut;
	}

	/**
	 * The time that this node used by itself (eg. totalTimeActual - sum of plans[0..n].totalTimeActual)
	 */
	public Double getSelfTimeActual() {

		if (totalTimeActual == null) {
			return null;
		}

		double childTime = plans
				.stream()
				.map(GenericPlanNode::getTotalTimeActual)
				.filter(Objects::nonNull)
				.mapToDouble(t -> t)
				.sum();

		return totalTimeActual - childTime;

	}

	/**
	 * @return true if this node introduces a new scope
	 */
	public Boolean isNewScope() {
		return newScope;
	}

	public void setNewScope(boolean newScope) {
		if (newScope) {
			this.newScope = true;
		} else {
			this.newScope = null;
		}
	}

	/**
	 * Join nodes can use various algorithms for joining data.
	 *
	 * @return the name of the algorithm.
	 */
	public String getAlgorithm() {
		return algorithm;
	}

	public void setAlgorithm(String algorithm) {
		this.algorithm = algorithm;
	}

	private static final int prettyBoxDrawingType = 0;

	/**
	 * Human readable string. Do not attempt to parse this.
	 *
	 * @return an unparsable string
	 */
	@Override
	public String toString() {
		return getHumanReadable(0);
	}

	/**
	 * @param prettyBoxDrawingType for deciding if we should use single or double walled character for drawing the
	 *                             connectors between nodes in the query plan. Eg. ├ or ╠ and ─ o
	 * @return
	 */
	private String getHumanReadable(int prettyBoxDrawingType) {
		StringBuilder sb = new StringBuilder();

		if (timedOut != null && timedOut) {
			sb.append("Timed out while retrieving explanation! Explanation may be incomplete!").append(newLine);
			sb.append("You can change the timeout by setting .setMaxExecutionTime(...) on your query.")
					.append(newLine)
					.append(newLine);
		}

		sb.append(type);
		if (newScope != null && newScope) {
			sb.append(" (new scope)");
		}

		if (algorithm != null) {
			sb.append(" (").append(algorithm).append(")");
		}
		appendCostAnnotation(sb);
		sb.append(newLine);

		// we use box-drawing characters to "group" nodes in the plan visually when there are exactly two child plans
		// and
		// the child plans contain child plans
		if (plans.size() == 2 && plans.stream().anyMatch(p -> !p.plans.isEmpty())) {

			String start;
			String horizontal;
			String vertical;
			String end;

			if (prettyBoxDrawingType % 2 == 0) {
				start = "╠";
				horizontal = "══";
				vertical = "║";
				end = "╚";
			} else {
				start = "├";
				horizontal = "──";
				vertical = "│";
				end = "└";
			}

			String left = plans.get(0).getHumanReadable(prettyBoxDrawingType + 1);
			String right = plans.get(1).getHumanReadable(prettyBoxDrawingType + 1);
			boolean join = type.contains("Join");

			{
				String[] split = left.split(newLine);
				sb.append(start).append(horizontal).append(" ").append(split[0]);
				if (join)
					sb.append(" [left]");
				sb.append(newLine);
				for (int i = 1; i < split.length; i++) {
					sb.append(vertical).append("  ").append(split[i]).append(newLine);
				}
			}

			{
				String[] split = right.split(newLine);
				sb.append(end).append(horizontal).append(" ").append(split[0]);
				if (join)
					sb.append(" [right]");
				sb.append(newLine);

				for (int i = 1; i < split.length; i++) {
					sb.append("   ").append(split[i]).append(newLine);
				}
			}

		} else {

			for (int i = 0; i < plans.size(); i++) {
				GenericPlanNode child = plans.get(i);
				int j = i;
				sb.append(Arrays.stream(child.getHumanReadable(prettyBoxDrawingType + 1).split(newLine))
						.map(c -> {
							if (type.startsWith("StatementPattern") && child.type.startsWith("Var")) {
								return spoc[j] + ": " + c;
							}
							return c;
						})
						.map(c -> "   " + c)
						.reduce((a, b) -> a + newLine + b)
						.orElse("")).append(newLine);
			}
		}

		return sb.toString();
	}

	/**
	 * @return Human readable number. Eg. 12.1M for 1212213.4 and UNKNOWN for -1.
	 */
	static private String toHumanReadableNumber(Double number) {
		String humanReadbleString;
		if (number == null) {
			humanReadbleString = UNKNOWN;
		} else if (number == Double.POSITIVE_INFINITY) {
			humanReadbleString = "∞";
		} else if (number > 1_000_000) {
			humanReadbleString = Math.round(number / 100_000) / 10.0 + "M";
		} else if (number > 1_000) {
			humanReadbleString = Math.round(number / 100) / 10.0 + "K";
		} else if (number < 10 && number > 0) {
			humanReadbleString = String.format("%.2f", number);
		} else if (number >= 0) {
			humanReadbleString = Math.round(number) + "";
		} else {
			humanReadbleString = UNKNOWN;
		}

		return humanReadbleString;
	}

	static private String toHumanReadableNonZeroNumber(Long number) {
		if (number != null && number == 0L) {
			return UNKNOWN;
		}
		return toHumanReadableNumber(number);
	}

	/**
	 * @return Human readable number. Eg. 12.1M for 1212213.4 and UNKNOWN for -1.
	 */
	static private String toHumanReadableNumber(Long number) {
		String humanReadbleString;
		if (number == null) {
			humanReadbleString = UNKNOWN;
		} else if (number == Double.POSITIVE_INFINITY) {
			humanReadbleString = "∞";
		} else if (number > 1_000_000) {
			humanReadbleString = number / 100_000 / 10.0 + "M";
		} else if (number > 1_000) {
			humanReadbleString = number / 100 / 10.0 + "K";
		} else if (number >= 0) {
			humanReadbleString = number + "";
		} else {
			humanReadbleString = UNKNOWN;
		}

		return humanReadbleString;
	}

	/**
	 * @return Human readable time.
	 */
	static private String toHumanReadableTime(Double millis) {
		String humanReadbleString;

		if (millis == null) {
			humanReadbleString = UNKNOWN;
		} else if (millis > 1_000) {
			humanReadbleString = Math.round(millis / 100) / 10.0 + "s";
		} else if (millis >= 100) {
			humanReadbleString = Math.round(millis) + "ms";
		} else if (millis >= 10) {
			humanReadbleString = Math.round(millis * 10) / 10.0 + "ms";
		} else if (millis >= 1) {
			humanReadbleString = Math.round(millis * 100) / 100.0 + "ms";
		} else if (millis >= 0) {
			humanReadbleString = Math.round(millis * 1000) / 1000.0 + "ms";
		} else {
			humanReadbleString = UNKNOWN;
		}

		return humanReadbleString;
	}

	private void appendCostAnnotation(StringBuilder sb) {
		Long sourceRowsScanned = sourceRowsScannedForDisplay();
		Long sourceRowsMatched = sourceRowsMatchedForDisplay();
		Long sourceRowsFiltered = sourceRowsFilteredForDisplay();
		Map<String, String> metrics = new LinkedHashMap<>();

		putIfKnown(metrics, "costEstimate", toHumanReadableNumber(getCostEstimate()));
		putIfKnown(metrics, "resultSizeEstimate", toHumanReadableNumber(getResultSizeEstimate()));
		putIfKnown(metrics, "resultSizeActual", toHumanReadableNumber(getResultSizeActual()));
		putIfKnown(metrics, "totalTimeActual", toHumanReadableTime(getTotalTimeActual()));
		putIfKnown(metrics, "selfTimeActual", toHumanReadableTime(getSelfTimeActual()));
		putIfKnown(metrics, "hasNextCallCountActual", toHumanReadableNonZeroNumber(getHasNextCallCountActual()));
		putIfKnown(metrics, "hasNextTrueCountActual", toHumanReadableNonZeroNumber(getHasNextTrueCountActual()));
		putIfKnown(metrics, "hasNextTimeNanosActual", toHumanReadableNonZeroNumber(getHasNextTimeNanosActual()));
		putIfKnown(metrics, "nextCallCountActual", toHumanReadableNonZeroNumber(getNextCallCountActual()));
		putIfKnown(metrics, "nextTimeNanosActual", toHumanReadableNonZeroNumber(getNextTimeNanosActual()));

		if (isJoinNode()) {
			putIfKnown(metrics, "joinRightIteratorsCreatedActual",
					toHumanReadableNonZeroNumber(getJoinRightIteratorsCreatedActual()));
			putIfKnown(metrics, "joinLeftBindingsConsumedActual",
					toHumanReadableNonZeroNumber(getJoinLeftBindingsConsumedActual()));
			putIfKnown(metrics, "joinRightBindingsConsumedActual",
					toHumanReadableNonZeroNumber(getJoinRightBindingsConsumedActual()));
		}

		putIfKnown(metrics, "sourceRowsScannedActual", toHumanReadableNonZeroNumber(sourceRowsScanned));
		putIfKnown(metrics, "sourceRowsMatchedActual", toHumanReadableNonZeroNumber(sourceRowsMatched));
		putIfKnown(metrics, "sourceRowsFilteredActual",
				isFilterNode() ? toHumanReadableNumber(sourceRowsFiltered)
						: toHumanReadableNonZeroNumber(sourceRowsFiltered));

		appendMapTelemetry(metrics);
		if (runtimeTelemetryEnabled) {
			appendDerivedTelemetry(metrics, sourceRowsScanned, sourceRowsMatched, sourceRowsFiltered);
		}

		if (!metrics.isEmpty()) {
			sb.append(" (")
					.append(metrics.entrySet()
							.stream()
							.map(e -> e.getKey() + "=" + e.getValue())
							.reduce((a, b) -> a + ", " + b)
							.orElse(""))
					.append(")");
		}
	}

	private boolean isJoinNode() {
		return type != null && (type.startsWith("Join") || type.startsWith("LeftJoin"));
	}

	private boolean isLeftJoinNode() {
		return type != null && type.startsWith("LeftJoin");
	}

	private boolean isFilterNode() {
		return type != null && type.startsWith("Filter");
	}

	private boolean isOrderNode() {
		return type != null && type.startsWith("Order");
	}

	private boolean isGroupNode() {
		return type != null && type.startsWith("Group");
	}

	private boolean isSliceNode() {
		return type != null && type.startsWith("Slice");
	}

	private boolean isServiceNode() {
		return type != null && type.startsWith("Service");
	}

	private boolean isDistinctLikeNode() {
		return type != null && (type.startsWith("Distinct") || type.startsWith("Reduced"));
	}

	private boolean isSetOperatorNode() {
		return type != null
				&& (type.startsWith("Union") || type.startsWith("Intersection") || type.startsWith("Difference"));
	}

	private boolean isAccessNode() {
		return type != null
				&& (type.startsWith("StatementPattern")
						|| type.startsWith("TripleRef")
						|| type.startsWith("ZeroLengthPath")
						|| type.startsWith("ArbitraryLengthPath")
						|| type.startsWith("Service")
						|| type.startsWith("TupleFunctionCall"));
	}

	private Long sourceRowsScannedForDisplay() {
		if (!runtimeTelemetryEnabled) {
			return null;
		}
		if (!isFilterNode()) {
			return getSourceRowsScannedActual();
		}
		if (getSourceRowsScannedActual() != null) {
			return getSourceRowsScannedActual();
		}
		if (plans.size() == 1) {
			return plans.get(0).getResultSizeActual();
		}
		return null;
	}

	private Long sourceRowsMatchedForDisplay() {
		if (!runtimeTelemetryEnabled) {
			return null;
		}
		if (!isFilterNode()) {
			return getSourceRowsMatchedActual();
		}
		if (getSourceRowsMatchedActual() != null) {
			return getSourceRowsMatchedActual();
		}
		return getResultSizeActual();
	}

	private Long sourceRowsFilteredForDisplay() {
		if (!runtimeTelemetryEnabled) {
			return null;
		}
		if (!isFilterNode()) {
			return getSourceRowsFilteredActual();
		}
		if (getSourceRowsFilteredActual() != null) {
			return getSourceRowsFilteredActual();
		}

		Long scanned = sourceRowsScannedForDisplay();
		Long matched = sourceRowsMatchedForDisplay();
		if (scanned == null || matched == null) {
			return null;
		}
		return Math.max(0L, scanned - matched);
	}

	private void appendMapTelemetry(Map<String, String> metrics) {
		for (Map.Entry<String, Long> entry : longMetricsActual.entrySet()) {
			String metricName = entry.getKey();
			Long metricValue = entry.getValue();
			if (metricValue == null || metricValue <= 0) {
				continue;
			}
			if (!isMetricApplicableToNode(metricName) || metrics.containsKey(metricName)) {
				continue;
			}
			putIfKnown(metrics, metricName, toHumanReadableNumber(metricValue));
		}

		for (Map.Entry<String, Double> entry : doubleMetricsActual.entrySet()) {
			String metricName = entry.getKey();
			Double metricValue = entry.getValue();
			if (metricValue == null || metricValue <= 0) {
				continue;
			}
			if (!isMetricApplicableToNode(metricName) || metrics.containsKey(metricName)) {
				continue;
			}
			putIfKnown(metrics, metricName, toHumanReadableNumber(metricValue));
		}

		for (Map.Entry<String, String> entry : stringMetricsActual.entrySet()) {
			String metricName = entry.getKey();
			String metricValue = entry.getValue();
			if (metricValue == null || metricValue.isEmpty()) {
				continue;
			}
			if (!isMetricApplicableToNode(metricName) || metrics.containsKey(metricName)) {
				continue;
			}
			metrics.put(metricName, metricValue);
		}
	}

	private void appendDerivedTelemetry(Map<String, String> metrics, Long sourceRowsScanned, Long sourceRowsMatched,
			Long sourceRowsFiltered) {
		Long inputRows = totalInputRowsFromChildren();
		Long outputRows = getResultSizeActual();

		putIfKnownIfAbsent(metrics, TelemetryMetricNames.INPUT_ROWS_ACTUAL, toHumanReadableNumber(inputRows));
		putIfKnownIfAbsent(metrics, TelemetryMetricNames.OUTPUT_ROWS_ACTUAL, toHumanReadableNumber(outputRows));
		if (inputRows != null && outputRows != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.ROWS_DROPPED_ACTUAL,
					toHumanReadableNumber(Math.max(0L, inputRows - outputRows)));
			Double selectivity = ratio(outputRows, inputRows);
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.SELECTIVITY_ACTUAL, toHumanReadableNumber(selectivity));
			Double expansion = ratio(outputRows, Math.max(1L, inputRows));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.EXPANSION_FACTOR_ACTUAL, toHumanReadableNumber(expansion));
		}

		if (outputRows != null && getTotalTimeActual() != null && getTotalTimeActual() > 0) {
			double throughput = outputRows * 1000.0 / getTotalTimeActual();
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.THROUGHPUT_ROWS_PER_SEC_ACTUAL,
					toHumanReadableNumber(throughput));
		}

		if (getResultSizeEstimate() != null && getResultSizeEstimate() > 0 && outputRows != null && outputRows > 0) {
			double estimate = getResultSizeEstimate();
			double actual = outputRows.doubleValue();
			double qError = Math.max(estimate / actual, actual / estimate);
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.ESTIMATE_ERROR_Q, toHumanReadableNumber(qError));
		}

		List<Double> childQErrors = new ArrayList<>();
		for (GenericPlanNode child : plans) {
			if (child.getResultSizeEstimate() == null || child.getResultSizeEstimate() <= 0
					|| child.getResultSizeActual() == null || child.getResultSizeActual() <= 0) {
				continue;
			}
			double estimate = child.getResultSizeEstimate();
			double actual = child.getResultSizeActual().doubleValue();
			childQErrors.add(Math.max(estimate / actual, actual / estimate));
		}
		if (!childQErrors.isEmpty()) {
			long sampleCount = childQErrors.size();
			double mean = childQErrors.stream().mapToDouble(Double::doubleValue).average().orElse(0D);
			double variance = childQErrors.stream()
					.mapToDouble(value -> {
						double delta = value - mean;
						return delta * delta;
					})
					.average()
					.orElse(0D);
			double stddev = Math.sqrt(variance);
			double confidence = Math.min(1D, sampleCount / (sampleCount + stddev + 1D));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.SAMPLE_COUNT_ACTUAL, toHumanReadableNumber(sampleCount));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.VARIANCE_ACTUAL, toHumanReadableNumber(variance));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.STDDEV_ACTUAL, toHumanReadableNumber(stddev));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.CONFIDENCE_SCORE_ACTUAL,
					toHumanReadableNumber(confidence));
		}

		if (getCostEstimate() != null && getCostEstimate() > 0 && getTotalTimeActual() != null
				&& getTotalTimeActual() > 0) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.COST_ERROR_RATIO,
					toHumanReadableNumber(getTotalTimeActual() / getCostEstimate()));
		}

		if (getHasNextCallCountActual() != null && getHasNextTrueCountActual() != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.HAS_NEXT_FALSE_COUNT_ACTUAL,
					toHumanReadableNumber(Math.max(0L, getHasNextCallCountActual() - getHasNextTrueCountActual())));
		}
		if (getHasNextCallCountActual() != null && getHasNextCallCountActual() > 0
				&& getNextCallCountActual() != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.NEXT_PER_HAS_NEXT_RATIO_ACTUAL,
					toHumanReadableNumber(getNextCallCountActual().doubleValue() / getHasNextCallCountActual()));
		}
		if (getHasNextCallCountActual() != null && getHasNextCallCountActual() > 0
				&& getHasNextTimeNanosActual() != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.AVG_HAS_NEXT_NANOS_ACTUAL,
					toHumanReadableNumber(getHasNextTimeNanosActual().doubleValue() / getHasNextCallCountActual()));
		}
		if (getNextCallCountActual() != null && getNextCallCountActual() > 0 && getNextTimeNanosActual() != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.AVG_NEXT_NANOS_ACTUAL,
					toHumanReadableNumber(getNextTimeNanosActual().doubleValue() / getNextCallCountActual()));
		}

		if (isJoinNode()) {
			Long leftRows = getJoinLeftBindingsConsumedActual();
			Long rightRows = getJoinRightBindingsConsumedActual();
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.LEFT_ROWS_PROBED_ACTUAL, toHumanReadableNumber(leftRows));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.RIGHT_ROWS_SCANNED_ACTUAL,
					toHumanReadableNumber(rightRows));

			if (leftRows != null && leftRows > 0 && rightRows != null) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.AVG_RIGHT_ROWS_PER_LEFT_ACTUAL,
						toHumanReadableNumber(rightRows.doubleValue() / leftRows));
			}

			Long leftRowsWithMatch = longMetricsActual.get(TelemetryMetricNames.LEFT_ROWS_WITH_MATCH_ACTUAL);
			if (leftRowsWithMatch == null) {
				Long iteratorsCreated = getJoinRightIteratorsCreatedActual();
				Long emptyProbes = longMetricsActual.get(TelemetryMetricNames.EMPTY_RIGHT_PROBE_COUNT_ACTUAL);
				if (iteratorsCreated != null && emptyProbes != null) {
					leftRowsWithMatch = Math.max(0L, iteratorsCreated - emptyProbes);
				}
			}

			if (leftRows != null && leftRows > 0 && leftRowsWithMatch != null) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.JOIN_MATCH_RATE_ACTUAL,
						toHumanReadableNumber(leftRowsWithMatch.doubleValue() / leftRows));
			}

			if (leftRows != null && leftRows > 0 && outputRows != null) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.JOIN_OUTPUT_PER_LEFT_ACTUAL,
						toHumanReadableNumber(outputRows.doubleValue() / leftRows));
			}

			if (isLeftJoinNode() && getJoinRightIteratorsCreatedActual() != null && leftRowsWithMatch != null) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.LEFT_JOIN_NULL_EXTENDED_ROWS_ACTUAL,
						toHumanReadableNumber(Math.max(0L, getJoinRightIteratorsCreatedActual() - leftRowsWithMatch)));
			}
		}

		if (isFilterNode() && sourceRowsScanned != null && sourceRowsScanned > 0 && sourceRowsFiltered != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.FILTER_REJECT_RATE_ACTUAL,
					toHumanReadableNumber(sourceRowsFiltered.doubleValue() / sourceRowsScanned));
		}

		if (isServiceNode()) {
			Long totalRequests = longMetricsActual.get(TelemetryMetricNames.REMOTE_REQUEST_COUNT_ACTUAL);
			if (totalRequests != null && totalRequests > 0) {
				long typedRequests = 0L;
				typedRequests += Math.max(0L, longMetricsActual.getOrDefault(
						TelemetryMetricNames.REMOTE_ASK_REQUEST_COUNT_ACTUAL, 0L));
				typedRequests += Math.max(0L, longMetricsActual.getOrDefault(
						TelemetryMetricNames.REMOTE_SELECT_REQUEST_COUNT_ACTUAL, 0L));
				typedRequests += Math.max(0L, longMetricsActual.getOrDefault(
						TelemetryMetricNames.REMOTE_EVALUATE_REQUEST_COUNT_ACTUAL, 0L));
				long derivedRetries = Math.max(0L, totalRequests - typedRequests);
				if (derivedRetries > 0) {
					putIfKnownIfAbsent(metrics, TelemetryMetricNames.REMOTE_RETRY_COUNT_ACTUAL,
							toHumanReadableNumber(derivedRetries));
				}
			}
		}

		if (isSetOperatorNode() && plans.size() >= 2) {
			Long left = plans.get(0).getResultSizeActual();
			Long right = plans.get(1).getResultSizeActual();
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.LEFT_ROWS_CONSUMED_ACTUAL, toHumanReadableNumber(left));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.RIGHT_ROWS_CONSUMED_ACTUAL, toHumanReadableNumber(right));

			if (type.startsWith("Union")) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.LEFT_ROWS_OUTPUT_CONTRIBUTION_ACTUAL,
						toHumanReadableNumber(left));
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.RIGHT_ROWS_OUTPUT_CONTRIBUTION_ACTUAL,
						toHumanReadableNumber(right));
			} else if (type.startsWith("Intersection")) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.OVERLAP_ROWS_ACTUAL,
						toHumanReadableNumber(outputRows));
			} else if (type.startsWith("Difference") && left != null && outputRows != null) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.OVERLAP_ROWS_ACTUAL,
						toHumanReadableNumber(Math.max(0L, left - outputRows)));
			}
		}

		if (isDistinctLikeNode() && inputRows != null && outputRows != null && inputRows > 0) {
			long duplicatesRemoved = Math.max(0L, inputRows - outputRows);
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.DUPLICATES_REMOVED_ACTUAL,
					toHumanReadableNumber(duplicatesRemoved));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.DEDUP_RATE_ACTUAL,
					toHumanReadableNumber(duplicatesRemoved / (double) inputRows));
		}

		if (isSliceNode() && !plans.isEmpty() && plans.get(0).getResultSizeActual() != null && outputRows != null) {
			Long childRows = plans.get(0).getResultSizeActual();
			long offset = sliceOffsetFromType();
			long skipped = Math.min(offset, childRows);
			long droppedByLimit = Math.max(0L, childRows - skipped - outputRows);
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.ROWS_SKIPPED_BY_OFFSET_ACTUAL,
					toHumanReadableNumber(skipped));
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.ROWS_DROPPED_BY_LIMIT_ACTUAL,
					toHumanReadableNumber(droppedByLimit));
		}

		if (isGroupNode()) {
			Long groups = longMetricsActual.get(TelemetryMetricNames.GROUPS_CREATED_ACTUAL);
			if (groups == null) {
				groups = outputRows;
			}
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.GROUPS_CREATED_ACTUAL, toHumanReadableNumber(groups));
			if (inputRows != null && groups != null && groups > 0) {
				putIfKnownIfAbsent(metrics, TelemetryMetricNames.AVG_GROUP_SIZE_ACTUAL,
						toHumanReadableNumber(inputRows.doubleValue() / groups));
			}
		}

		if (isAccessNode() && sourceRowsScanned != null && sourceRowsScanned > 0 && sourceRowsMatched != null) {
			putIfKnownIfAbsent(metrics, TelemetryMetricNames.INDEX_HIT_RATE_ACTUAL,
					toHumanReadableNumber(sourceRowsMatched.doubleValue() / sourceRowsScanned));
		}
	}

	private boolean isMetricApplicableToNode(String metricName) {
		if (JOIN_ONLY_METRICS.contains(metricName)) {
			return isJoinNode();
		}
		if (FILTER_ONLY_METRICS.contains(metricName)) {
			return isFilterNode();
		}
		if (ORDER_ONLY_METRICS.contains(metricName)) {
			return isOrderNode();
		}
		if (GROUP_ONLY_METRICS.contains(metricName)) {
			return isGroupNode();
		}
		if (SLICE_ONLY_METRICS.contains(metricName)) {
			return isSliceNode();
		}
		if (SERVICE_ONLY_METRICS.contains(metricName)) {
			return isServiceNode();
		}
		if (SET_OPERATOR_ONLY_METRICS.contains(metricName)) {
			return isSetOperatorNode();
		}
		if (ACCESS_ONLY_METRICS.contains(metricName)) {
			return isAccessNode();
		}
		return true;
	}

	private Long totalInputRowsFromChildren() {
		if (plans.isEmpty()) {
			return null;
		}
		long sum = 0;
		boolean found = false;
		for (GenericPlanNode plan : plans) {
			Long childRows = plan.getResultSizeActual();
			if (childRows != null && childRows >= 0) {
				sum += childRows;
				found = true;
			}
		}
		return found ? sum : null;
	}

	private long sliceOffsetFromType() {
		return parseSliceLong(OFFSET_PATTERN);
	}

	private long parseSliceLong(Pattern pattern) {
		if (type == null) {
			return 0L;
		}
		Matcher matcher = pattern.matcher(type);
		if (!matcher.find()) {
			return 0L;
		}
		return Long.parseLong(matcher.group(1));
	}

	private static Double ratio(Long numerator, Long denominator) {
		if (numerator == null || denominator == null || denominator <= 0) {
			return null;
		}
		return numerator.doubleValue() / denominator.doubleValue();
	}

	private static void putIfKnown(Map<String, String> target, String metricName, String metricValue) {
		if (metricValue != null && !UNKNOWN.equals(metricValue)) {
			target.put(metricName, metricValue);
		}
	}

	private static void putIfKnownIfAbsent(Map<String, String> target, String metricName, String metricValue) {
		if (target.containsKey(metricName)) {
			return;
		}
		putIfKnown(target, metricName, metricValue);
	}

	public String toDot() {

		return toDotInternal(getMaxResultSizeActual(this), getMaxTotalTime(this), getMaxSelfTime(this));

	}

	private static double getMaxTotalTime(GenericPlanNode genericPlanNode) {
		return Math.max(genericPlanNode.getTotalTimeActual() != null ? genericPlanNode.getTotalTimeActual() : 0,
				genericPlanNode.plans.stream().mapToDouble(GenericPlanNode::getMaxTotalTime).max().orElse(0));
	}

	private static double getMaxSelfTime(GenericPlanNode genericPlanNode) {
		return Math.max(genericPlanNode.getSelfTimeActual() != null ? genericPlanNode.getSelfTimeActual() : 0,
				genericPlanNode.plans.stream().mapToDouble(GenericPlanNode::getMaxSelfTime).max().orElse(0));
	}

	private static double getMaxResultSizeActual(GenericPlanNode genericPlanNode) {
		return Math.max(genericPlanNode.getResultSizeActual() != null ? genericPlanNode.getResultSizeActual() : 0,
				genericPlanNode.plans.stream().mapToDouble(GenericPlanNode::getMaxResultSizeActual).max().orElse(0));
	}

	private String toDotInternal(double maxResultSizeActual, double maxTotalTime, double maxSelfTime) {
		StringBuilder sb = new StringBuilder();
		sb.append("   ");

		if (newScope != null && newScope) {
			sb.append("subgraph cluster_")
					.append(getID())
					.append(" {")
					.append(newLine)
					.append("   color=grey")
					.append(newLine);
		}

		String resultSizeActualColor = getProportionalRedColor(maxResultSizeActual, getResultSizeActual());
		String totalTimeColor = getProportionalRedColor(maxTotalTime, getTotalTimeActual());
		String selfTimeColor = getProportionalRedColor(maxSelfTime, getSelfTimeActual());

		sb
				.append(getID())
				.append(" [label=")
				.append("<<table BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"3\" >");

		sb.append(Stream.of(
				"<tr><td COLSPAN=\"2\" BGCOLOR=\"" + totalTimeColor + "\"><U>" + StringEscapeUtils.escapeHtml4(type)
						+ "</U></td></tr>",
				"<tr><td>Algorithm</td><td>" + (algorithm != null ? algorithm : UNKNOWN) + "</td></tr>",
				"<tr><td><B>New scope</B></td><td>" + (newScope != null && newScope ? "<B>true</B>" : UNKNOWN)
						+ "</td></tr>",
				"<tr><td>Cost estimate</td><td>" + toHumanReadableNumber(getCostEstimate()) + "</td></tr>",
				"<tr><td>Result size estimate</td><td>" + toHumanReadableNumber(getResultSizeEstimate()) + "</td></tr>",
				"<tr><td >Result size actual</td><td>" + toHumanReadableNumber(getResultSizeActual()) + "</td></tr>",
//			"<tr><td >Result size actual</td><td BGCOLOR=\"" + resultSizeActualColor + "\">" + toHumanReadableNumber(getResultSizeActual()) + "</td></tr>",
				"<tr><td >Total time actual</td><td BGCOLOR=\"" + totalTimeColor + "\">"
						+ toHumanReadableTime(getTotalTimeActual()) + "</td></tr>",
				"<tr><td >Self time actual</td><td BGCOLOR=\"" + selfTimeColor + "\">"
						+ toHumanReadableTime(getSelfTimeActual()) + "</td></tr>")
				.filter(s -> !s.contains(UNKNOWN)) // simple but hacky way of removing essentially null values
				.reduce((a, b) -> a + " " + b)
				.orElse(""));

		sb.append("</table>>").append(" shape=plaintext];").append(newLine);
		for (int i = 0; i < plans.size(); i++) {
			GenericPlanNode p = plans.get(i);
			String linkLabel = "index " + i;

			if (plans.size() == 2) {
				linkLabel = i == 0 ? "left" : "right";
			} else if (plans.size() == 1) {
				linkLabel = "";
			}

			sb.append("   ")
					.append(getID())
					.append(" -> ")
					.append(p.getID())
					.append(" [label=\"")
					.append(linkLabel)
					.append("\"]")
					.append(" ;")
					.append(newLine);
		}

		plans.forEach(p -> sb.append(p.toDotInternal(maxResultSizeActual, maxTotalTime, maxSelfTime)));

		if (newScope != null && newScope) {
			sb.append(newLine).append("}").append(newLine);
		}
		return sb.toString();
	}

	private String getProportionalRedColor(Double max, Double value) {
		String mainColor = "#FFFFFF";
		if (value != null) {
			double colorInt = Math.abs(256 / max * value - 256);
			String hexColor = String.format("%02X", (0xFFFFFF & ((int) Math.floor(colorInt))));

			mainColor = "#FF" + hexColor + hexColor;
		}
		return mainColor;
	}

	private String getProportionalRedColor(Double max, Long value) {
		if (value != null) {
			return getProportionalRedColor(max, value + 0.0);
		}
		return "#FFFFFF";
	}

	@JsonIgnore
	public String getID() {
		return id;
	}
}
