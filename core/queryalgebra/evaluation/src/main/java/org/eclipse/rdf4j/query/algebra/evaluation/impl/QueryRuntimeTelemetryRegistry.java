/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.LongAdder;

import org.eclipse.rdf4j.query.algebra.Filter;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.LeftJoin;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.ValueExpr;
import org.eclipse.rdf4j.query.algebra.Var;

/**
 * Process-local runtime telemetry history keyed by normalized statement-pattern signature.
 */
public final class QueryRuntimeTelemetryRegistry {

	private static final int MAX_PATTERN_KEYS = 1024;
	private static final int EVICTION_CHECK_INTERVAL = 512;
	private static final ConcurrentHashMap<String, TelemetryAggregate> BY_PATTERN_KEY = new ConcurrentHashMap<>();
	// Intentionally best-effort. MAX_PATTERN_KEYS is a soft ceiling, so occasional delayed checks are acceptable.
	// Keeping this as a plain counter avoids adding extra contention to every telemetry record() call.
	private static int EVICTION_CHECK_COUNTER = 0;
	private static final AtomicBoolean EVICTION_IN_PROGRESS = new AtomicBoolean();

	private QueryRuntimeTelemetryRegistry() {

	}

	public static void clear() {
		BY_PATTERN_KEY.clear();
		EVICTION_CHECK_COUNTER = 0;
	}

	public static void record(QueryModelNode node) {
		String key = keyFor(node);
		if (key == null) {
			return;
		}

		long sourceRowsScannedActual = node.getSourceRowsScannedActual();
		long sourceRowsMatchedActual = node.getSourceRowsMatchedActual();
		long sourceRowsFilteredActual = node.getSourceRowsFilteredActual();
		long joinRightIteratorsCreatedActual = node.getJoinRightIteratorsCreatedActual();
		long joinLeftBindingsConsumedActual = node.getJoinLeftBindingsConsumedActual();
		long joinRightBindingsConsumedActual = node.getJoinRightBindingsConsumedActual();

		if (sourceRowsScannedActual < 0 && sourceRowsMatchedActual < 0 && sourceRowsFilteredActual < 0
				&& joinRightIteratorsCreatedActual < 0 && joinLeftBindingsConsumedActual < 0
				&& joinRightBindingsConsumedActual < 0) {
			return;
		}

		TelemetryAggregate aggregate = aggregateForKey(key);
		aggregate.record(sourceRowsScannedActual, sourceRowsMatchedActual, sourceRowsFilteredActual,
				joinRightIteratorsCreatedActual, joinLeftBindingsConsumedActual, joinRightBindingsConsumedActual);

		recordFilterDerivedStatementPatternTelemetry(node, joinRightIteratorsCreatedActual,
				joinLeftBindingsConsumedActual, joinRightBindingsConsumedActual);
		maybeEvictLeastRecentlyUsedEntries();
	}

	public static TelemetrySnapshot snapshotFor(TupleExpr tupleExpr) {
		String key = keyFor(tupleExpr);
		if (key == null) {
			return TelemetrySnapshot.empty();
		}
		TelemetryAggregate aggregate = BY_PATTERN_KEY.get(key);
		if (aggregate == null) {
			return TelemetrySnapshot.empty();
		}
		aggregate.touch();
		return aggregate.snapshot();
	}

	private static String keyFor(QueryModelNode node) {
		if (!(node instanceof TupleExpr)) {
			return null;
		}

		return tupleExprKey((TupleExpr) node);
	}

	private static String tupleExprKey(TupleExpr tupleExpr) {
		if (tupleExpr == null) {
			return null;
		}
		if (tupleExpr instanceof StatementPattern) {
			return statementPatternKey((StatementPattern) tupleExpr);
		}
		if (tupleExpr instanceof Filter) {
			Filter filter = (Filter) tupleExpr;
			return "FILTER|arg=" + tupleExprKey(filter.getArg()) + "|condition=" + valueExprKey(filter.getCondition());
		}
		if (tupleExpr instanceof Join) {
			Join join = (Join) tupleExpr;
			return "JOIN|left=" + tupleExprKey(join.getLeftArg()) + "|right=" + tupleExprKey(join.getRightArg());
		}
		if (tupleExpr instanceof LeftJoin) {
			LeftJoin leftJoin = (LeftJoin) tupleExpr;
			return "LEFT_JOIN|left=" + tupleExprKey(leftJoin.getLeftArg()) + "|right="
					+ tupleExprKey(leftJoin.getRightArg())
					+ "|condition=" + valueExprKey(leftJoin.getCondition());
		}
		return tupleExpr.getClass().getSimpleName() + "|" + tupleExpr.getSignature();
	}

	private static String statementPatternKey(StatementPattern statementPattern) {
		return "SP|s=" + varKey(statementPattern.getSubjectVar())
				+ "|p=" + varKey(statementPattern.getPredicateVar())
				+ "|o=" + varKey(statementPattern.getObjectVar())
				+ "|c=" + varKey(statementPattern.getContextVar());
	}

	private static String valueExprKey(ValueExpr valueExpr) {
		if (valueExpr == null) {
			return "<null>";
		}
		return valueExpr.toString().replaceAll("\\s+", " ").trim();
	}

	private static void recordFilterDerivedStatementPatternTelemetry(QueryModelNode node,
			long joinRightIteratorsCreatedActual, long joinLeftBindingsConsumedActual,
			long joinRightBindingsConsumedActual) {
		if (!(node instanceof Filter)) {
			return;
		}

		TupleExpr filterArg = ((Filter) node).getArg();
		if (!(filterArg instanceof StatementPattern)) {
			return;
		}

		long sourceRowsScannedActual = joinLeftBindingsConsumedActual;
		long sourceRowsMatchedActual = joinRightBindingsConsumedActual;
		long sourceRowsFilteredActual = -1;
		if (sourceRowsScannedActual >= 0 && sourceRowsMatchedActual >= 0) {
			sourceRowsFilteredActual = Math.max(0L, sourceRowsScannedActual - sourceRowsMatchedActual);
		}

		long derivedJoinRightIteratorsCreatedActual = joinRightIteratorsCreatedActual >= 0
				? joinRightIteratorsCreatedActual
				: joinLeftBindingsConsumedActual;
		long derivedJoinLeftBindingsConsumedActual = joinLeftBindingsConsumedActual;
		long derivedJoinRightBindingsConsumedActual = joinRightBindingsConsumedActual;

		String statementPatternKey = statementPatternKey((StatementPattern) filterArg);
		TelemetryAggregate aggregate = aggregateForKey(statementPatternKey);
		if (aggregate == null) {
			return;
		}
		aggregate.record(sourceRowsScannedActual, sourceRowsMatchedActual, sourceRowsFilteredActual,
				derivedJoinRightIteratorsCreatedActual, derivedJoinLeftBindingsConsumedActual,
				derivedJoinRightBindingsConsumedActual);
	}

	private static TelemetryAggregate aggregateForKey(String key) {
		TelemetryAggregate aggregate = BY_PATTERN_KEY.computeIfAbsent(key, unused -> new TelemetryAggregate());
		aggregate.touch();
		return aggregate;
	}

	private static void maybeEvictLeastRecentlyUsedEntries() {
		if (!shouldRunEvictionCheck()) {
			return;
		}
		if (!EVICTION_IN_PROGRESS.compareAndSet(false, true)) {
			return;
		}
		try {
			evictLeastRecentlyUsedEntries();
		} finally {
			EVICTION_IN_PROGRESS.set(false);
		}
	}

	private static boolean shouldRunEvictionCheck() {
		// Non-atomic increment is intentional: checks are sampling-based and eviction remains eventual.
		return ++EVICTION_CHECK_COUNTER > EVICTION_CHECK_INTERVAL;
	}

	private static void evictLeastRecentlyUsedEntries() {
		EVICTION_CHECK_COUNTER = 0;
		int size = BY_PATTERN_KEY.size();
		while (size > MAX_PATTERN_KEYS) {
			String leastRecentlyUsedKey = findLeastRecentlyUsedKey();
			if (leastRecentlyUsedKey == null) {
				return;
			}
			BY_PATTERN_KEY.remove(leastRecentlyUsedKey);
			size = BY_PATTERN_KEY.size();
		}
	}

	private static String findLeastRecentlyUsedKey() {
		String leastRecentlyUsedKey = null;
		long leastRecentAccess = Long.MAX_VALUE;

		for (Map.Entry<String, TelemetryAggregate> entry : BY_PATTERN_KEY.entrySet()) {
			TelemetryAggregate aggregate = entry.getValue();
			if (aggregate == null) {
				continue;
			}
			long lastAccessEpochMillis = aggregate.lastAccessEpochMillis();
			if (lastAccessEpochMillis < leastRecentAccess) {
				leastRecentAccess = lastAccessEpochMillis;
				leastRecentlyUsedKey = entry.getKey();
			}
		}

		return leastRecentlyUsedKey;
	}

	private static String varKey(Var var) {
		if (var == null) {
			return "<null>";
		}

		if (var.hasValue()) {
			return "const:" + var.getValue().stringValue();
		}

		String name = var.getName();
		return "var:" + (name == null ? "<anon>" : name);
	}

	private static final class TelemetryAggregate {
		private volatile long lastAccessEpochMillis = System.currentTimeMillis();
		private final LongAdder sourceRowsScannedSum = new LongAdder();
		private final LongAdder sourceRowsScannedCount = new LongAdder();
		private final LongAdder sourceRowsMatchedSum = new LongAdder();
		private final LongAdder sourceRowsMatchedCount = new LongAdder();
		private final LongAdder sourceRowsFilteredSum = new LongAdder();
		private final LongAdder sourceRowsFilteredCount = new LongAdder();
		private final LongAdder joinRightIteratorsCreatedSum = new LongAdder();
		private final LongAdder joinRightIteratorsCreatedCount = new LongAdder();
		private final LongAdder joinLeftBindingsConsumedSum = new LongAdder();
		private final LongAdder joinLeftBindingsConsumedCount = new LongAdder();
		private final LongAdder joinRightBindingsConsumedSum = new LongAdder();
		private final LongAdder joinRightBindingsConsumedCount = new LongAdder();

		private void touch() {
			lastAccessEpochMillis = System.currentTimeMillis();
		}

		private long lastAccessEpochMillis() {
			return lastAccessEpochMillis;
		}

		private void record(long sourceRowsScannedActual, long sourceRowsMatchedActual, long sourceRowsFilteredActual,
				long joinRightIteratorsCreatedActual, long joinLeftBindingsConsumedActual,
				long joinRightBindingsConsumedActual) {
			touch();
			recordMetric(sourceRowsScannedActual, sourceRowsScannedSum, sourceRowsScannedCount);
			recordMetric(sourceRowsMatchedActual, sourceRowsMatchedSum, sourceRowsMatchedCount);
			recordMetric(sourceRowsFilteredActual, sourceRowsFilteredSum, sourceRowsFilteredCount);
			recordMetric(joinRightIteratorsCreatedActual, joinRightIteratorsCreatedSum, joinRightIteratorsCreatedCount);
			recordMetric(joinLeftBindingsConsumedActual, joinLeftBindingsConsumedSum, joinLeftBindingsConsumedCount);
			recordMetric(joinRightBindingsConsumedActual, joinRightBindingsConsumedSum, joinRightBindingsConsumedCount);
		}

		private TelemetrySnapshot snapshot() {
			return new TelemetrySnapshot(average(sourceRowsScannedSum, sourceRowsScannedCount),
					average(sourceRowsMatchedSum, sourceRowsMatchedCount),
					average(sourceRowsFilteredSum, sourceRowsFilteredCount),
					average(joinRightIteratorsCreatedSum, joinRightIteratorsCreatedCount),
					average(joinLeftBindingsConsumedSum, joinLeftBindingsConsumedCount),
					average(joinRightBindingsConsumedSum, joinRightBindingsConsumedCount));
		}

		private static void recordMetric(long value, LongAdder sum, LongAdder count) {
			if (value < 0) {
				return;
			}
			sum.add(value);
			count.increment();
		}

		private static long average(LongAdder sum, LongAdder count) {
			long sampleCount = count.longValue();
			if (sampleCount <= 0) {
				return -1;
			}
			return Math.max(0L, Math.round(sum.doubleValue() / sampleCount));
		}
	}

	public static final class TelemetrySnapshot {
		private static final TelemetrySnapshot EMPTY = new TelemetrySnapshot(-1, -1, -1, -1, -1, -1);

		private final long sourceRowsScannedActual;
		private final long sourceRowsMatchedActual;
		private final long sourceRowsFilteredActual;
		private final long joinRightIteratorsCreatedActual;
		private final long joinLeftBindingsConsumedActual;
		private final long joinRightBindingsConsumedActual;

		private TelemetrySnapshot(long sourceRowsScannedActual, long sourceRowsMatchedActual,
				long sourceRowsFilteredActual, long joinRightIteratorsCreatedActual,
				long joinLeftBindingsConsumedActual, long joinRightBindingsConsumedActual) {
			this.sourceRowsScannedActual = sourceRowsScannedActual;
			this.sourceRowsMatchedActual = sourceRowsMatchedActual;
			this.sourceRowsFilteredActual = sourceRowsFilteredActual;
			this.joinRightIteratorsCreatedActual = joinRightIteratorsCreatedActual;
			this.joinLeftBindingsConsumedActual = joinLeftBindingsConsumedActual;
			this.joinRightBindingsConsumedActual = joinRightBindingsConsumedActual;
		}

		public static TelemetrySnapshot empty() {
			return EMPTY;
		}

		public long sourceRowsScannedActual() {
			return sourceRowsScannedActual;
		}

		public long sourceRowsMatchedActual() {
			return sourceRowsMatchedActual;
		}

		public long sourceRowsFilteredActual() {
			return sourceRowsFilteredActual;
		}

		public long joinRightIteratorsCreatedActual() {
			return joinRightIteratorsCreatedActual;
		}

		public long joinLeftBindingsConsumedActual() {
			return joinLeftBindingsConsumedActual;
		}

		public long joinRightBindingsConsumedActual() {
			return joinRightBindingsConsumedActual;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof TelemetrySnapshot)) {
				return false;
			}
			TelemetrySnapshot that = (TelemetrySnapshot) o;
			return sourceRowsScannedActual == that.sourceRowsScannedActual
					&& sourceRowsMatchedActual == that.sourceRowsMatchedActual
					&& sourceRowsFilteredActual == that.sourceRowsFilteredActual
					&& joinRightIteratorsCreatedActual == that.joinRightIteratorsCreatedActual
					&& joinLeftBindingsConsumedActual == that.joinLeftBindingsConsumedActual
					&& joinRightBindingsConsumedActual == that.joinRightBindingsConsumedActual;
		}

		@Override
		public int hashCode() {
			return Objects.hash(sourceRowsScannedActual, sourceRowsMatchedActual, sourceRowsFilteredActual,
					joinRightIteratorsCreatedActual, joinLeftBindingsConsumedActual, joinRightBindingsConsumedActual);
		}
	}
}
