/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.federation;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.locks.LockSupport;

import org.eclipse.rdf4j.common.iteration.CloseableIteratorIteration;
import org.eclipse.rdf4j.common.iteration.SingletonIteration;
import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.algebra.Service;
import org.eclipse.rdf4j.query.algebra.SingletonSet;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.EvaluationStrategy;
import org.eclipse.rdf4j.query.algebra.evaluation.impl.evaluationsteps.ServiceQueryEvaluationStep;
import org.eclipse.rdf4j.query.explanation.TelemetryMetricNames;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.eclipse.rdf4j.query.impl.MapBindingSet;
import org.junit.jupiter.api.Test;

class ServiceJoinIteratorTelemetryTest {

	@Test
	void recordsLatencyQuantilesForFallbackRequests() throws Exception {
		Service service = new Service(
				Var.of("serviceRef"),
				new SingletonSet(),
				"{ VALUES ?x { 1 } }",
				Collections.emptyMap(),
				null,
				false);
		service.setRuntimeTelemetryEnabled(true);

		FederatedService federatedService = mock(FederatedService.class);
		when(federatedService.ask(eq(service), any(BindingSet.class), eq(service.getBaseURI())))
				.thenAnswer(invocation -> {
					LockSupport.parkNanos(1_000_000L);
					return true;
				});

		FederatedServiceResolver resolver = mock(FederatedServiceResolver.class);
		when(resolver.getService("http://example.com/service-1")).thenReturn(federatedService);
		when(resolver.getService("http://example.com/service-2")).thenReturn(federatedService);

		ServiceQueryEvaluationStep serviceStep = new ServiceQueryEvaluationStep(service, service.getServiceRef(),
				resolver);
		EvaluationStrategy strategy = mock(EvaluationStrategy.class);
		when(strategy.evaluate(eq(service), any(BindingSet.class)))
				.thenAnswer(invocation -> serviceStep.evaluate(invocation.getArgument(1)));

		BindingSet first = singleBindingSet("serviceRef", "http://example.com/service-1");
		BindingSet second = singleBindingSet("serviceRef", "http://example.com/service-2");
		try (ServiceJoinIterator iterator = new ServiceJoinIterator(
				new CloseableIteratorIteration<>(List.of(first, second).iterator()),
				service,
				EmptyBindingSet.getInstance(),
				strategy)) {
			while (iterator.hasNext()) {
				iterator.next();
			}
		}

		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_REQUEST_COUNT_ACTUAL)).isEqualTo(2L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_EVALUATE_REQUEST_COUNT_ACTUAL))
				.isEqualTo(2L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_LATENCY_TOTAL_NANOS_ACTUAL))
				.isGreaterThan(0L);
		assertThat(service.getDoubleMetricActual(TelemetryMetricNames.REMOTE_LATENCY_P50_NANOS_ACTUAL))
				.isGreaterThan(0D);
		assertThat(service.getDoubleMetricActual(TelemetryMetricNames.REMOTE_LATENCY_P95_NANOS_ACTUAL))
				.isGreaterThan(0D);
	}

	@Test
	void avoidsDoubleCountingRemoteRequestTelemetryInFallbackMode() throws Exception {
		Service service = new Service(
				Var.of("serviceRef"),
				new SingletonSet(),
				"{ VALUES ?x { 1 } }",
				Collections.emptyMap(),
				null,
				false);
		service.setRuntimeTelemetryEnabled(true);

		FederatedService federatedService = mock(FederatedService.class);
		when(federatedService.ask(eq(service), any(BindingSet.class), eq(service.getBaseURI()))).thenReturn(true);

		FederatedServiceResolver resolver = mock(FederatedServiceResolver.class);
		when(resolver.getService("http://example.com/service")).thenReturn(federatedService);

		ServiceQueryEvaluationStep serviceStep = new ServiceQueryEvaluationStep(service, service.getServiceRef(),
				resolver);
		EvaluationStrategy strategy = mock(EvaluationStrategy.class);
		when(strategy.evaluate(eq(service), any(BindingSet.class)))
				.thenAnswer(invocation -> serviceStep.evaluate(invocation.getArgument(1)));

		BindingSet leftBindings = singleBindingSet("serviceRef", "http://example.com/service");
		try (ServiceJoinIterator iterator = new ServiceJoinIterator(
				new CloseableIteratorIteration<>(List.of(leftBindings).iterator()),
				service,
				EmptyBindingSet.getInstance(),
				strategy)) {
			assertThat(iterator.hasNext()).isTrue();
			iterator.next();
			assertThat(iterator.hasNext()).isFalse();
		}

		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_REQUEST_COUNT_ACTUAL)).isEqualTo(1L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_EVALUATE_REQUEST_COUNT_ACTUAL))
				.isEqualTo(1L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_ASK_REQUEST_COUNT_ACTUAL)).isEqualTo(1L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_BYTES_RECEIVED_ACTUAL)).isEqualTo(4L);
	}

	@Test
	void skipsRequestAndResponseByteAccountingWhenRuntimeTelemetryDisabled() throws Exception {
		Service service = new Service(
				Var.of("serviceRef"),
				new SingletonSet(),
				"{ VALUES ?x { 1 } }",
				Collections.emptyMap(),
				null,
				false);
		service.setRuntimeTelemetryEnabled(false);

		BindingSet responseRow = mock(BindingSet.class);
		when(responseRow.toString()).thenThrow(new AssertionError("response byte accounting should be disabled"));
		EvaluationStrategy strategy = mock(EvaluationStrategy.class);
		when(strategy.evaluate(eq(service), any(BindingSet.class))).thenReturn(new SingletonIteration<>(responseRow));

		Value serviceRefValue = mock(Value.class);
		when(serviceRefValue.stringValue()).thenReturn("http://example.com/service");
		when(serviceRefValue.toString()).thenThrow(new AssertionError("request byte accounting should be disabled"));
		MapBindingSet leftBindings = new MapBindingSet();
		leftBindings.addBinding("serviceRef", serviceRefValue);

		try (ServiceJoinIterator iterator = new ServiceJoinIterator(
				new CloseableIteratorIteration<>(List.of(leftBindings).iterator()),
				service,
				EmptyBindingSet.getInstance(),
				strategy)) {
			assertThat(iterator.hasNext()).isTrue();
			assertThat(iterator.next()).isSameAs(responseRow);
			assertThat(iterator.hasNext()).isFalse();
		}

		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_BYTES_SENT_ACTUAL)).isEqualTo(-1L);
		assertThat(service.getLongMetricActual(TelemetryMetricNames.REMOTE_BYTES_RECEIVED_ACTUAL)).isEqualTo(-1L);
	}

	private static BindingSet singleBindingSet(String name, String value) {
		MapBindingSet bindingSet = new MapBindingSet();
		bindingSet.addBinding(name, SimpleValueFactory.getInstance().createLiteral(value));
		return bindingSet;
	}
}
