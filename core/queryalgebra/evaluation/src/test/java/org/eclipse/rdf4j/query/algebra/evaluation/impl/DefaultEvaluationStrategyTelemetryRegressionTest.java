/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.evaluation.impl;

import static org.assertj.core.api.Assertions.assertThat;

import java.lang.reflect.Field;
import java.util.Map;

import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.query.Dataset;
import org.eclipse.rdf4j.query.algebra.MathExpr;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.ValueConstant;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.algebra.evaluation.QueryValueEvaluationStep;
import org.eclipse.rdf4j.query.impl.EmptyBindingSet;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

class DefaultEvaluationStrategyTelemetryRegressionTest {

	@AfterEach
	void clearRegistry() {
		QueryRuntimeTelemetryRegistry.clear();
	}

	@Test
	void telemetryWrappedConstantValueStepRemainsConstant() {
		DefaultEvaluationStrategy strategy = new DefaultEvaluationStrategy(new EmptyTripleSource(), null);
		MathExpr expr = new MathExpr(
				new ValueConstant(SimpleValueFactory.getInstance().createLiteral(1)),
				new ValueConstant(SimpleValueFactory.getInstance().createLiteral(2)),
				MathExpr.MathOp.PLUS);
		expr.setRuntimeTelemetryEnabled(true);

		QueryValueEvaluationStep prepared = strategy.precompile(expr,
				new QueryEvaluationContext.Minimal((Dataset) null));

		assertThat(prepared.isConstant()).isTrue();
		assertThat(prepared.evaluate(EmptyBindingSet.getInstance()).stringValue()).isEqualTo("3");
	}

	@Test
	void telemetryRegistryDoesNotGrowUnboundedForUniquePatterns() {
		int uniquePatternCount = 2048;

		for (int i = 0; i < uniquePatternCount; i++) {
			QueryRuntimeTelemetryRegistry.record(statementPatternWithMetrics(i));
		}

		assertThat(registrySize()).isLessThan(uniquePatternCount);
	}

	@Test
	void telemetryRegistryEvictsLeastRecentlyUsedPattern() {
		int capacity = maxPatternKeys();
		int evictionCheckInterval = evictionCheckInterval();

		for (int i = 0; i < capacity; i++) {
			QueryRuntimeTelemetryRegistry.record(statementPatternWithMetrics(i));
		}

		// Refresh key 0 so key 1 becomes the least recently used.
		QueryRuntimeTelemetryRegistry.record(statementPatternWithMetrics(0));

		assertThat(registrySize()).isEqualTo(capacity);

		int newPatternIndex = capacity;
		QueryRuntimeTelemetryRegistry.record(statementPatternWithMetrics(newPatternIndex));

		assertThat(QueryRuntimeTelemetryRegistry.snapshotFor(statementPatternWithMetrics(0)).sourceRowsScannedActual())
				.isEqualTo(1L);
		assertThat(QueryRuntimeTelemetryRegistry.snapshotFor(statementPatternWithMetrics(newPatternIndex))
				.sourceRowsScannedActual()).isEqualTo(newPatternIndex + 1L);

		for (int i = 0; i < evictionCheckInterval; i++) {
			QueryRuntimeTelemetryRegistry.record(statementPatternWithMetrics(0));
		}

		assertThat(registrySize()).isEqualTo(capacity);
		int presentUntouchedCount = 0;
		for (int i = 1; i < capacity; i++) {
			if (QueryRuntimeTelemetryRegistry.snapshotFor(statementPatternWithMetrics(i))
					.sourceRowsScannedActual() >= 0) {
				presentUntouchedCount++;
			}
		}
		assertThat(presentUntouchedCount).isEqualTo(capacity - 2);
	}

	private static StatementPattern statementPatternWithMetrics(int index) {
		StatementPattern statementPattern = new StatementPattern(
				Var.of("s", SimpleValueFactory.getInstance().createIRI("urn:test:s" + index)),
				Var.of("p", RDF.TYPE),
				Var.of("o", SimpleValueFactory.getInstance().createIRI("urn:test:o")));
		statementPattern.setSourceRowsScannedActual(index + 1L);
		return statementPattern;
	}

	private static int registrySize() {
		try {
			Field byPatternKey = QueryRuntimeTelemetryRegistry.class.getDeclaredField("BY_PATTERN_KEY");
			byPatternKey.setAccessible(true);
			return ((Map<?, ?>) byPatternKey.get(null)).size();
		} catch (ReflectiveOperationException e) {
			throw new AssertionError("Unable to inspect runtime telemetry registry size", e);
		}
	}

	private static int maxPatternKeys() {
		try {
			Field maxPatternKeys = QueryRuntimeTelemetryRegistry.class.getDeclaredField("MAX_PATTERN_KEYS");
			maxPatternKeys.setAccessible(true);
			return maxPatternKeys.getInt(null);
		} catch (ReflectiveOperationException e) {
			throw new AssertionError("Unable to inspect runtime telemetry registry capacity", e);
		}
	}

	private static int evictionCheckInterval() {
		try {
			Field evictionCheckInterval = QueryRuntimeTelemetryRegistry.class
					.getDeclaredField("EVICTION_CHECK_INTERVAL");
			evictionCheckInterval.setAccessible(true);
			return evictionCheckInterval.getInt(null);
		} catch (ReflectiveOperationException e) {
			throw new AssertionError("Unable to inspect runtime telemetry eviction check interval", e);
		}
	}
}
