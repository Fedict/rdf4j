/*******************************************************************************
 * Copyright (c) 2026 Eclipse RDF4J contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *******************************************************************************/
// Some portions generated by Codex
package org.eclipse.rdf4j.query.algebra.helpers;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;

import org.eclipse.rdf4j.query.algebra.Extension;
import org.eclipse.rdf4j.query.algebra.ExtensionElem;
import org.eclipse.rdf4j.query.algebra.Join;
import org.eclipse.rdf4j.query.algebra.Projection;
import org.eclipse.rdf4j.query.algebra.ProjectionElem;
import org.eclipse.rdf4j.query.algebra.ProjectionElemList;
import org.eclipse.rdf4j.query.algebra.QueryModelNode;
import org.eclipse.rdf4j.query.algebra.StatementPattern;
import org.eclipse.rdf4j.query.algebra.TupleExpr;
import org.eclipse.rdf4j.query.algebra.Var;
import org.eclipse.rdf4j.query.explanation.GenericPlanNode;
import org.eclipse.rdf4j.query.explanation.TelemetryMetricNames;
import org.junit.jupiter.api.Test;

public class QueryModelTreeToGenericPlanNodeTest {

	@Test
	public void includesRuntimeTelemetryForAllPlanNodes() {
		TupleExpr tupleExpr = new Join(
				new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o")),
				new StatementPattern(Var.of("s"), Var.of("p2"), Var.of("o2")));

		tupleExpr.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			protected void meetNode(QueryModelNode node) throws RuntimeException {
				node.setRuntimeTelemetryEnabled(true);
				node.setHasNextCallCountActual(11);
				node.setHasNextTrueCountActual(7);
				node.setHasNextTimeNanosActual(1000);
				node.setNextCallCountActual(9);
				node.setNextTimeNanosActual(2000);
				node.setJoinRightIteratorsCreatedActual(13);
				node.setJoinLeftBindingsConsumedActual(15);
				node.setJoinRightBindingsConsumedActual(17);
				node.setSourceRowsScannedActual(19);
				node.setSourceRowsMatchedActual(23);
				node.setSourceRowsFilteredActual(31);
				node.setLongMetricActual(TelemetryMetricNames.OPEN_COUNT_ACTUAL, 2);
				node.setDoubleMetricActual(TelemetryMetricNames.SELECTIVITY_ACTUAL, 0.25);
				node.setStringMetricActual(TelemetryMetricNames.METRIC_ORIGIN + "."
						+ TelemetryMetricNames.SELECTIVITY_ACTUAL, "derived");
				super.meetNode(node);
			}
		});

		QueryModelTreeToGenericPlanNode converter = new QueryModelTreeToGenericPlanNode(tupleExpr);
		tupleExpr.visit(converter);
		GenericPlanNode root = converter.getGenericPlanNode();

		assertThat(root).isNotNull();
		assertTelemetryRecursively(root);
	}

	@Test
	public void leavesRuntimeTelemetryUnsetWhenNodeDidNotCollectMetrics() {
		TupleExpr tupleExpr = new Join(
				new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o")),
				new StatementPattern(Var.of("s"), Var.of("p2"), Var.of("o2")));

		QueryModelTreeToGenericPlanNode converter = new QueryModelTreeToGenericPlanNode(tupleExpr);
		tupleExpr.visit(converter);
		GenericPlanNode root = converter.getGenericPlanNode();

		assertThat(root).isNotNull();
		assertUnsetTelemetryRecursively(root);
	}

	@Test
	public void derivesVariableShapeMetricsFromTupleExprBindingNames() {
		StatementPattern statementPattern = new StatementPattern(Var.of("s"), Var.of("p"), Var.of("o"));
		Extension extension = new Extension(statementPattern, new ExtensionElem(Var.of("o"), "derivedVar"));
		Projection projection = new Projection(extension,
				new ProjectionElemList(new ProjectionElem("s"), new ProjectionElem("derivedVar")));
		projection.visit(new AbstractQueryModelVisitor<RuntimeException>() {
			@Override
			protected void meetNode(QueryModelNode node) throws RuntimeException {
				node.setRuntimeTelemetryEnabled(true);
				super.meetNode(node);
			}
		});

		QueryModelTreeToGenericPlanNode converter = new QueryModelTreeToGenericPlanNode(projection);
		projection.visit(converter);
		GenericPlanNode root = converter.getGenericPlanNode();

		assertThat(root).isNotNull();
		assertThat(root.getLongMetricsActual())
				.containsEntry(TelemetryMetricNames.VARS_DROPPED_ACTUAL, 2L);
		assertThat(root.getStringMetricsActual())
				.containsEntry(TelemetryMetricNames.METRIC_ORIGIN + "." + TelemetryMetricNames.VARS_DROPPED_ACTUAL,
						"derived");

		GenericPlanNode extensionPlan = root.getPlans()
				.stream()
				.filter(plan -> plan.getType().startsWith("Extension"))
				.findFirst()
				.orElseThrow();
		assertThat(extensionPlan.getLongMetricsActual())
				.containsEntry(TelemetryMetricNames.VARS_ADDED_ACTUAL, 1L);
		assertThat(extensionPlan.getStringMetricsActual())
				.containsEntry(TelemetryMetricNames.METRIC_ORIGIN + "." + TelemetryMetricNames.VARS_ADDED_ACTUAL,
						"derived");
	}

	private static void assertTelemetryRecursively(GenericPlanNode node) {
		assertThat(node.getHasNextCallCountActual()).isEqualTo(11);
		assertThat(node.getHasNextTrueCountActual()).isEqualTo(7);
		assertThat(node.getHasNextTimeNanosActual()).isEqualTo(1000);
		assertThat(node.getNextCallCountActual()).isEqualTo(9);
		assertThat(node.getNextTimeNanosActual()).isEqualTo(2000);
		assertThat(node.getJoinRightIteratorsCreatedActual()).isEqualTo(13);
		assertThat(node.getJoinLeftBindingsConsumedActual()).isEqualTo(15);
		assertThat(node.getJoinRightBindingsConsumedActual()).isEqualTo(17);
		assertThat(node.getSourceRowsScannedActual()).isEqualTo(19);
		assertThat(node.getSourceRowsMatchedActual()).isEqualTo(23);
		assertThat(node.getSourceRowsFilteredActual()).isEqualTo(31);
		assertThat(node.getLongMetricsActual()).containsEntry(TelemetryMetricNames.OPEN_COUNT_ACTUAL, 2L);
		assertThat(node.getDoubleMetricsActual()).containsEntry(TelemetryMetricNames.SELECTIVITY_ACTUAL, 0.25);
		assertThat(node.getStringMetricsActual())
				.containsEntry(TelemetryMetricNames.METRIC_ORIGIN + "." + TelemetryMetricNames.SELECTIVITY_ACTUAL,
						"derived");

		List<GenericPlanNode> children = node.getPlans();
		if (children != null) {
			for (GenericPlanNode child : children) {
				assertTelemetryRecursively(child);
			}
		}
	}

	private static void assertUnsetTelemetryRecursively(GenericPlanNode node) {
		assertThat(node.getHasNextCallCountActual()).isNull();
		assertThat(node.getHasNextTrueCountActual()).isNull();
		assertThat(node.getHasNextTimeNanosActual()).isNull();
		assertThat(node.getNextCallCountActual()).isNull();
		assertThat(node.getNextTimeNanosActual()).isNull();
		assertThat(node.getJoinRightIteratorsCreatedActual()).isNull();
		assertThat(node.getJoinLeftBindingsConsumedActual()).isNull();
		assertThat(node.getJoinRightBindingsConsumedActual()).isNull();
		assertThat(node.getSourceRowsScannedActual()).isNull();
		assertThat(node.getSourceRowsMatchedActual()).isNull();
		assertThat(node.getSourceRowsFilteredActual()).isNull();
		assertThat(node.getLongMetricsActual()).isNull();
		assertThat(node.getDoubleMetricsActual()).isNull();
		assertThat(node.getStringMetricsActual()).isNull();

		List<GenericPlanNode> children = node.getPlans();
		if (children != null) {
			for (GenericPlanNode child : children) {
				assertUnsetTelemetryRecursively(child);
			}
		}
	}
}
